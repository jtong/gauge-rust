// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

/// / Default request. Tells the runner to shutdown.
#[derive(PartialEq,Clone,Default)]
pub struct KillProcessRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a KillProcessRequest {
    fn default() -> &'a KillProcessRequest {
        <KillProcessRequest as ::protobuf::Message>::default_instance()
    }
}

impl KillProcessRequest {
    pub fn new() -> KillProcessRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KillProcessRequest>(
            "KillProcessRequest",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for KillProcessRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> KillProcessRequest {
        KillProcessRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static KillProcessRequest {
        static instance: KillProcessRequest = KillProcessRequest {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for KillProcessRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KillProcessRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KillProcessRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Sends to any request which needs a execution status as response
/// / usually step execution, hooks etc will return this
#[derive(PartialEq,Clone,Default)]
pub struct ExecutionStatusResponse {
    // message fields
    pub executionResult: ::protobuf::MessageField<super::spec::ProtoExecutionResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecutionStatusResponse {
    fn default() -> &'a ExecutionStatusResponse {
        <ExecutionStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExecutionStatusResponse {
    pub fn new() -> ExecutionStatusResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::spec::ProtoExecutionResult>(
            "executionResult",
            |m: &ExecutionStatusResponse| { &m.executionResult },
            |m: &mut ExecutionStatusResponse| { &mut m.executionResult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecutionStatusResponse>(
            "ExecutionStatusResponse",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for ExecutionStatusResponse {
    fn is_initialized(&self) -> bool {
        if self.executionResult.is_none() {
            return false;
        }
        for v in &self.executionResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.executionResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.executionResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.executionResult.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ExecutionStatusResponse {
        ExecutionStatusResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static ExecutionStatusResponse {
        static instance: ExecutionStatusResponse = ExecutionStatusResponse {
            executionResult: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ExecutionStatusResponse {
    fn clear(&mut self) {
        self.executionResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutionStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutionStatusResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Sent at start of Suite Execution. Tells the runner to execute `before_suite` hook.
#[derive(PartialEq,Clone,Default)]
pub struct ExecutionStartingRequest {
    // message fields
    pub currentExecutionInfo: ::protobuf::MessageField<ExecutionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecutionStartingRequest {
    fn default() -> &'a ExecutionStartingRequest {
        <ExecutionStartingRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecutionStartingRequest {
    pub fn new() -> ExecutionStartingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecutionInfo>(
            "currentExecutionInfo",
            |m: &ExecutionStartingRequest| { &m.currentExecutionInfo },
            |m: &mut ExecutionStartingRequest| { &mut m.currentExecutionInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecutionStartingRequest>(
            "ExecutionStartingRequest",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for ExecutionStartingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.currentExecutionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.currentExecutionInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ExecutionStartingRequest {
        ExecutionStartingRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static ExecutionStartingRequest {
        static instance: ExecutionStartingRequest = ExecutionStartingRequest {
            currentExecutionInfo: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ExecutionStartingRequest {
    fn clear(&mut self) {
        self.currentExecutionInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutionStartingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutionStartingRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Sent at end of Suite Execution. Tells the runner to execute `after_suite` hook.
#[derive(PartialEq,Clone,Default)]
pub struct ExecutionEndingRequest {
    // message fields
    pub currentExecutionInfo: ::protobuf::MessageField<ExecutionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecutionEndingRequest {
    fn default() -> &'a ExecutionEndingRequest {
        <ExecutionEndingRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecutionEndingRequest {
    pub fn new() -> ExecutionEndingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecutionInfo>(
            "currentExecutionInfo",
            |m: &ExecutionEndingRequest| { &m.currentExecutionInfo },
            |m: &mut ExecutionEndingRequest| { &mut m.currentExecutionInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecutionEndingRequest>(
            "ExecutionEndingRequest",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for ExecutionEndingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.currentExecutionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.currentExecutionInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ExecutionEndingRequest {
        ExecutionEndingRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 3)
    }

    fn default_instance() -> &'static ExecutionEndingRequest {
        static instance: ExecutionEndingRequest = ExecutionEndingRequest {
            currentExecutionInfo: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ExecutionEndingRequest {
    fn clear(&mut self) {
        self.currentExecutionInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutionEndingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutionEndingRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Sent at start of Spec Execution. Tells the runner to execute `before_spec` hook.
#[derive(PartialEq,Clone,Default)]
pub struct SpecExecutionStartingRequest {
    // message fields
    pub currentExecutionInfo: ::protobuf::MessageField<ExecutionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpecExecutionStartingRequest {
    fn default() -> &'a SpecExecutionStartingRequest {
        <SpecExecutionStartingRequest as ::protobuf::Message>::default_instance()
    }
}

impl SpecExecutionStartingRequest {
    pub fn new() -> SpecExecutionStartingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecutionInfo>(
            "currentExecutionInfo",
            |m: &SpecExecutionStartingRequest| { &m.currentExecutionInfo },
            |m: &mut SpecExecutionStartingRequest| { &mut m.currentExecutionInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpecExecutionStartingRequest>(
            "SpecExecutionStartingRequest",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for SpecExecutionStartingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.currentExecutionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.currentExecutionInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SpecExecutionStartingRequest {
        SpecExecutionStartingRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static SpecExecutionStartingRequest {
        static instance: SpecExecutionStartingRequest = SpecExecutionStartingRequest {
            currentExecutionInfo: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SpecExecutionStartingRequest {
    fn clear(&mut self) {
        self.currentExecutionInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpecExecutionStartingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpecExecutionStartingRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Sent at end of Spec Execution. Tells the runner to execute `after_spec` hook.
#[derive(PartialEq,Clone,Default)]
pub struct SpecExecutionEndingRequest {
    // message fields
    pub currentExecutionInfo: ::protobuf::MessageField<ExecutionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpecExecutionEndingRequest {
    fn default() -> &'a SpecExecutionEndingRequest {
        <SpecExecutionEndingRequest as ::protobuf::Message>::default_instance()
    }
}

impl SpecExecutionEndingRequest {
    pub fn new() -> SpecExecutionEndingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecutionInfo>(
            "currentExecutionInfo",
            |m: &SpecExecutionEndingRequest| { &m.currentExecutionInfo },
            |m: &mut SpecExecutionEndingRequest| { &mut m.currentExecutionInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpecExecutionEndingRequest>(
            "SpecExecutionEndingRequest",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for SpecExecutionEndingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.currentExecutionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.currentExecutionInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SpecExecutionEndingRequest {
        SpecExecutionEndingRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static SpecExecutionEndingRequest {
        static instance: SpecExecutionEndingRequest = SpecExecutionEndingRequest {
            currentExecutionInfo: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SpecExecutionEndingRequest {
    fn clear(&mut self) {
        self.currentExecutionInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpecExecutionEndingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpecExecutionEndingRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Sent at start of Scenario Execution. Tells the runner to execute `before_scenario` hook.
#[derive(PartialEq,Clone,Default)]
pub struct ScenarioExecutionStartingRequest {
    // message fields
    pub currentExecutionInfo: ::protobuf::MessageField<ExecutionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScenarioExecutionStartingRequest {
    fn default() -> &'a ScenarioExecutionStartingRequest {
        <ScenarioExecutionStartingRequest as ::protobuf::Message>::default_instance()
    }
}

impl ScenarioExecutionStartingRequest {
    pub fn new() -> ScenarioExecutionStartingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecutionInfo>(
            "currentExecutionInfo",
            |m: &ScenarioExecutionStartingRequest| { &m.currentExecutionInfo },
            |m: &mut ScenarioExecutionStartingRequest| { &mut m.currentExecutionInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScenarioExecutionStartingRequest>(
            "ScenarioExecutionStartingRequest",
            6,
            fields,
        )
    }
}

impl ::protobuf::Message for ScenarioExecutionStartingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.currentExecutionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.currentExecutionInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ScenarioExecutionStartingRequest {
        ScenarioExecutionStartingRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 6)
    }

    fn default_instance() -> &'static ScenarioExecutionStartingRequest {
        static instance: ScenarioExecutionStartingRequest = ScenarioExecutionStartingRequest {
            currentExecutionInfo: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ScenarioExecutionStartingRequest {
    fn clear(&mut self) {
        self.currentExecutionInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScenarioExecutionStartingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScenarioExecutionStartingRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Sent at end of Scenario Execution. Tells the runner to execute `after_scenario` hook.
#[derive(PartialEq,Clone,Default)]
pub struct ScenarioExecutionEndingRequest {
    // message fields
    pub currentExecutionInfo: ::protobuf::MessageField<ExecutionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScenarioExecutionEndingRequest {
    fn default() -> &'a ScenarioExecutionEndingRequest {
        <ScenarioExecutionEndingRequest as ::protobuf::Message>::default_instance()
    }
}

impl ScenarioExecutionEndingRequest {
    pub fn new() -> ScenarioExecutionEndingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecutionInfo>(
            "currentExecutionInfo",
            |m: &ScenarioExecutionEndingRequest| { &m.currentExecutionInfo },
            |m: &mut ScenarioExecutionEndingRequest| { &mut m.currentExecutionInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScenarioExecutionEndingRequest>(
            "ScenarioExecutionEndingRequest",
            7,
            fields,
        )
    }
}

impl ::protobuf::Message for ScenarioExecutionEndingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.currentExecutionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.currentExecutionInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ScenarioExecutionEndingRequest {
        ScenarioExecutionEndingRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 7)
    }

    fn default_instance() -> &'static ScenarioExecutionEndingRequest {
        static instance: ScenarioExecutionEndingRequest = ScenarioExecutionEndingRequest {
            currentExecutionInfo: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ScenarioExecutionEndingRequest {
    fn clear(&mut self) {
        self.currentExecutionInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScenarioExecutionEndingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScenarioExecutionEndingRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Sent at start of Step Execution. Tells the runner to execute `before_step` hook.
#[derive(PartialEq,Clone,Default)]
pub struct StepExecutionStartingRequest {
    // message fields
    pub currentExecutionInfo: ::protobuf::MessageField<ExecutionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a StepExecutionStartingRequest {
    fn default() -> &'a StepExecutionStartingRequest {
        <StepExecutionStartingRequest as ::protobuf::Message>::default_instance()
    }
}

impl StepExecutionStartingRequest {
    pub fn new() -> StepExecutionStartingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecutionInfo>(
            "currentExecutionInfo",
            |m: &StepExecutionStartingRequest| { &m.currentExecutionInfo },
            |m: &mut StepExecutionStartingRequest| { &mut m.currentExecutionInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepExecutionStartingRequest>(
            "StepExecutionStartingRequest",
            8,
            fields,
        )
    }
}

impl ::protobuf::Message for StepExecutionStartingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.currentExecutionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.currentExecutionInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> StepExecutionStartingRequest {
        StepExecutionStartingRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 8)
    }

    fn default_instance() -> &'static StepExecutionStartingRequest {
        static instance: StepExecutionStartingRequest = StepExecutionStartingRequest {
            currentExecutionInfo: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for StepExecutionStartingRequest {
    fn clear(&mut self) {
        self.currentExecutionInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StepExecutionStartingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepExecutionStartingRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Sent at end of Step Execution. Tells the runner to execute `after_step` hook.
#[derive(PartialEq,Clone,Default)]
pub struct StepExecutionEndingRequest {
    // message fields
    pub currentExecutionInfo: ::protobuf::MessageField<ExecutionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a StepExecutionEndingRequest {
    fn default() -> &'a StepExecutionEndingRequest {
        <StepExecutionEndingRequest as ::protobuf::Message>::default_instance()
    }
}

impl StepExecutionEndingRequest {
    pub fn new() -> StepExecutionEndingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecutionInfo>(
            "currentExecutionInfo",
            |m: &StepExecutionEndingRequest| { &m.currentExecutionInfo },
            |m: &mut StepExecutionEndingRequest| { &mut m.currentExecutionInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepExecutionEndingRequest>(
            "StepExecutionEndingRequest",
            9,
            fields,
        )
    }
}

impl ::protobuf::Message for StepExecutionEndingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.currentExecutionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.currentExecutionInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.currentExecutionInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> StepExecutionEndingRequest {
        StepExecutionEndingRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 9)
    }

    fn default_instance() -> &'static StepExecutionEndingRequest {
        static instance: StepExecutionEndingRequest = StepExecutionEndingRequest {
            currentExecutionInfo: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for StepExecutionEndingRequest {
    fn clear(&mut self) {
        self.currentExecutionInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StepExecutionEndingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepExecutionEndingRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Contains details of the execution. 
/// / Depending on the context (Step, Scenario, Spec or Suite), the respective fields are set.
#[derive(PartialEq,Clone,Default)]
pub struct ExecutionInfo {
    // message fields
    /// / Holds the information of the current Spec. Valid in context of Spec execution.
    pub currentSpec: ::protobuf::MessageField<SpecInfo>,
    /// / Holds the information of the current Scenario. Valid in context of Scenario execution.
    pub currentScenario: ::protobuf::MessageField<ScenarioInfo>,
    /// / Holds the information of the current Step. Valid in context of Step execution.
    pub currentStep: ::protobuf::MessageField<StepInfo>,
    /// / Stacktrace of the execution. Valid only if there is an error in execution.
    stacktrace: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecutionInfo {
    fn default() -> &'a ExecutionInfo {
        <ExecutionInfo as ::protobuf::Message>::default_instance()
    }
}

impl ExecutionInfo {
    pub fn new() -> ExecutionInfo {
        ::std::default::Default::default()
    }

    // optional string stacktrace = 4;

    pub fn get_stacktrace(&self) -> &str {
        match self.stacktrace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stacktrace(&mut self) {
        self.stacktrace = ::std::option::Option::None;
    }

    pub fn has_stacktrace(&self) -> bool {
        self.stacktrace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stacktrace(&mut self, v: ::std::string::String) {
        self.stacktrace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stacktrace(&mut self) -> &mut ::std::string::String {
        if self.stacktrace.is_none() {
            self.stacktrace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stacktrace.as_mut().unwrap()
    }

    // Take field
    pub fn take_stacktrace(&mut self) -> ::std::string::String {
        self.stacktrace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SpecInfo>(
            "currentSpec",
            |m: &ExecutionInfo| { &m.currentSpec },
            |m: &mut ExecutionInfo| { &mut m.currentSpec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScenarioInfo>(
            "currentScenario",
            |m: &ExecutionInfo| { &m.currentScenario },
            |m: &mut ExecutionInfo| { &mut m.currentScenario },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StepInfo>(
            "currentStep",
            |m: &ExecutionInfo| { &m.currentStep },
            |m: &mut ExecutionInfo| { &mut m.currentStep },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "stacktrace",
            |m: &ExecutionInfo| { &m.stacktrace },
            |m: &mut ExecutionInfo| { &mut m.stacktrace },
            ExecutionInfo::get_stacktrace,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecutionInfo>(
            "ExecutionInfo",
            10,
            fields,
        )
    }
}

impl ::protobuf::Message for ExecutionInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.currentSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.currentScenario {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.currentStep {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.currentSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.currentScenario)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.currentStep)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stacktrace = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.currentSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.currentScenario.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.currentStep.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stacktrace.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.currentSpec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.currentScenario.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.currentStep.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.stacktrace.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ExecutionInfo {
        ExecutionInfo::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 10)
    }

    fn default_instance() -> &'static ExecutionInfo {
        static instance: ExecutionInfo = ExecutionInfo {
            currentSpec: ::protobuf::MessageField::none(),
            currentScenario: ::protobuf::MessageField::none(),
            currentStep: ::protobuf::MessageField::none(),
            stacktrace: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ExecutionInfo {
    fn clear(&mut self) {
        self.currentSpec.clear();
        self.currentScenario.clear();
        self.currentStep.clear();
        self.stacktrace = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutionInfo {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Contains details of the Spec execution.
#[derive(PartialEq,Clone,Default)]
pub struct SpecInfo {
    // message fields
    /// / Name of the current Spec being executed.
    name: ::std::option::Option<::std::string::String>,
    /// / Full File path containing the current Spec being executed.
    fileName: ::std::option::Option<::std::string::String>,
    /// / Flag to indicate if the current Spec execution failed.
    isFailed: ::std::option::Option<bool>,
    /// / Tags relevant to the current Spec execution.
    pub tags: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpecInfo {
    fn default() -> &'a SpecInfo {
        <SpecInfo as ::protobuf::Message>::default_instance()
    }
}

impl SpecInfo {
    pub fn new() -> SpecInfo {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string fileName = 2;

    pub fn get_fileName(&self) -> &str {
        match self.fileName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fileName(&mut self) {
        self.fileName = ::std::option::Option::None;
    }

    pub fn has_fileName(&self) -> bool {
        self.fileName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileName(&mut self, v: ::std::string::String) {
        self.fileName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileName(&mut self) -> &mut ::std::string::String {
        if self.fileName.is_none() {
            self.fileName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fileName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileName(&mut self) -> ::std::string::String {
        self.fileName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool isFailed = 3;

    pub fn get_isFailed(&self) -> bool {
        self.isFailed.unwrap_or(false)
    }

    pub fn clear_isFailed(&mut self) {
        self.isFailed = ::std::option::Option::None;
    }

    pub fn has_isFailed(&self) -> bool {
        self.isFailed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isFailed(&mut self, v: bool) {
        self.isFailed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "name",
            |m: &SpecInfo| { &m.name },
            |m: &mut SpecInfo| { &mut m.name },
            SpecInfo::get_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "fileName",
            |m: &SpecInfo| { &m.fileName },
            |m: &mut SpecInfo| { &mut m.fileName },
            SpecInfo::get_fileName,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "isFailed",
            |m: &SpecInfo| { &m.isFailed },
            |m: &mut SpecInfo| { &mut m.isFailed },
            SpecInfo::get_isFailed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &SpecInfo| { &m.tags },
            |m: &mut SpecInfo| { &mut m.tags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpecInfo>(
            "SpecInfo",
            11,
            fields,
        )
    }
}

impl ::protobuf::Message for SpecInfo {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.fileName.is_none() {
            return false;
        }
        if self.isFailed.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fileName = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.isFailed = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.fileName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.isFailed {
            my_size += 2;
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.fileName.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.isFailed {
            os.write_bool(3, v)?;
        }
        for v in &self.tags {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SpecInfo {
        SpecInfo::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 11)
    }

    fn default_instance() -> &'static SpecInfo {
        static instance: SpecInfo = SpecInfo {
            name: ::std::option::Option::None,
            fileName: ::std::option::Option::None,
            isFailed: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SpecInfo {
    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.fileName = ::std::option::Option::None;
        self.isFailed = ::std::option::Option::None;
        self.tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpecInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpecInfo {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Contains details of the Scenario execution.
#[derive(PartialEq,Clone,Default)]
pub struct ScenarioInfo {
    // message fields
    /// / Name of the current Scenario being executed.
    name: ::std::option::Option<::std::string::String>,
    /// / Flag to indicate if the current Scenario execution failed.
    isFailed: ::std::option::Option<bool>,
    /// / Tags relevant to the current Scenario execution.
    pub tags: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScenarioInfo {
    fn default() -> &'a ScenarioInfo {
        <ScenarioInfo as ::protobuf::Message>::default_instance()
    }
}

impl ScenarioInfo {
    pub fn new() -> ScenarioInfo {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool isFailed = 2;

    pub fn get_isFailed(&self) -> bool {
        self.isFailed.unwrap_or(false)
    }

    pub fn clear_isFailed(&mut self) {
        self.isFailed = ::std::option::Option::None;
    }

    pub fn has_isFailed(&self) -> bool {
        self.isFailed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isFailed(&mut self, v: bool) {
        self.isFailed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "name",
            |m: &ScenarioInfo| { &m.name },
            |m: &mut ScenarioInfo| { &mut m.name },
            ScenarioInfo::get_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "isFailed",
            |m: &ScenarioInfo| { &m.isFailed },
            |m: &mut ScenarioInfo| { &mut m.isFailed },
            ScenarioInfo::get_isFailed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &ScenarioInfo| { &m.tags },
            |m: &mut ScenarioInfo| { &mut m.tags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScenarioInfo>(
            "ScenarioInfo",
            12,
            fields,
        )
    }
}

impl ::protobuf::Message for ScenarioInfo {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.isFailed.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.isFailed = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.isFailed {
            my_size += 2;
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.isFailed {
            os.write_bool(2, v)?;
        }
        for v in &self.tags {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ScenarioInfo {
        ScenarioInfo::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 12)
    }

    fn default_instance() -> &'static ScenarioInfo {
        static instance: ScenarioInfo = ScenarioInfo {
            name: ::std::option::Option::None,
            isFailed: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ScenarioInfo {
    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.isFailed = ::std::option::Option::None;
        self.tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScenarioInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScenarioInfo {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Contains details of the Step execution.
#[derive(PartialEq,Clone,Default)]
pub struct StepInfo {
    // message fields
    /// / The current request to execute Step
    pub step: ::protobuf::MessageField<ExecuteStepRequest>,
    /// / Flag to indicate if the current Step execution failed.
    isFailed: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a StepInfo {
    fn default() -> &'a StepInfo {
        <StepInfo as ::protobuf::Message>::default_instance()
    }
}

impl StepInfo {
    pub fn new() -> StepInfo {
        ::std::default::Default::default()
    }

    // required bool isFailed = 2;

    pub fn get_isFailed(&self) -> bool {
        self.isFailed.unwrap_or(false)
    }

    pub fn clear_isFailed(&mut self) {
        self.isFailed = ::std::option::Option::None;
    }

    pub fn has_isFailed(&self) -> bool {
        self.isFailed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isFailed(&mut self, v: bool) {
        self.isFailed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecuteStepRequest>(
            "step",
            |m: &StepInfo| { &m.step },
            |m: &mut StepInfo| { &mut m.step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "isFailed",
            |m: &StepInfo| { &m.isFailed },
            |m: &mut StepInfo| { &mut m.isFailed },
            StepInfo::get_isFailed,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepInfo>(
            "StepInfo",
            13,
            fields,
        )
    }
}

impl ::protobuf::Message for StepInfo {
    fn is_initialized(&self) -> bool {
        if self.step.is_none() {
            return false;
        }
        if self.isFailed.is_none() {
            return false;
        }
        for v in &self.step {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.step)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.isFailed = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.step.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.isFailed {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.step.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.isFailed {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> StepInfo {
        StepInfo::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 13)
    }

    fn default_instance() -> &'static StepInfo {
        static instance: StepInfo = StepInfo {
            step: ::protobuf::MessageField::none(),
            isFailed: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for StepInfo {
    fn clear(&mut self) {
        self.step.clear();
        self.isFailed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StepInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepInfo {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request sent ot the runner to Execute a Step
#[derive(PartialEq,Clone,Default)]
pub struct ExecuteStepRequest {
    // message fields
    /// / Contains the actual text of the Step being executed. 
    /// / This contains the parameters as defined in the Spec.
    actualStepText: ::std::option::Option<::std::string::String>,
    /// / Contains the parsed text of the Step being executed. 
    /// / The paramters are replaced with placeholders.
    parsedStepText: ::std::option::Option<::std::string::String>,
    /// / Flag to indicate if the execution of the Scenario, containing the current Step, failed.
    scenarioFailing: ::std::option::Option<bool>,
    /// / Collection of parameters applicable to the current Step.
    pub parameters: ::std::vec::Vec<super::spec::Parameter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteStepRequest {
    fn default() -> &'a ExecuteStepRequest {
        <ExecuteStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteStepRequest {
    pub fn new() -> ExecuteStepRequest {
        ::std::default::Default::default()
    }

    // required string actualStepText = 1;

    pub fn get_actualStepText(&self) -> &str {
        match self.actualStepText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_actualStepText(&mut self) {
        self.actualStepText = ::std::option::Option::None;
    }

    pub fn has_actualStepText(&self) -> bool {
        self.actualStepText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actualStepText(&mut self, v: ::std::string::String) {
        self.actualStepText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actualStepText(&mut self) -> &mut ::std::string::String {
        if self.actualStepText.is_none() {
            self.actualStepText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.actualStepText.as_mut().unwrap()
    }

    // Take field
    pub fn take_actualStepText(&mut self) -> ::std::string::String {
        self.actualStepText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string parsedStepText = 2;

    pub fn get_parsedStepText(&self) -> &str {
        match self.parsedStepText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parsedStepText(&mut self) {
        self.parsedStepText = ::std::option::Option::None;
    }

    pub fn has_parsedStepText(&self) -> bool {
        self.parsedStepText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parsedStepText(&mut self, v: ::std::string::String) {
        self.parsedStepText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parsedStepText(&mut self) -> &mut ::std::string::String {
        if self.parsedStepText.is_none() {
            self.parsedStepText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parsedStepText.as_mut().unwrap()
    }

    // Take field
    pub fn take_parsedStepText(&mut self) -> ::std::string::String {
        self.parsedStepText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool scenarioFailing = 3;

    pub fn get_scenarioFailing(&self) -> bool {
        self.scenarioFailing.unwrap_or(false)
    }

    pub fn clear_scenarioFailing(&mut self) {
        self.scenarioFailing = ::std::option::Option::None;
    }

    pub fn has_scenarioFailing(&self) -> bool {
        self.scenarioFailing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scenarioFailing(&mut self, v: bool) {
        self.scenarioFailing = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "actualStepText",
            |m: &ExecuteStepRequest| { &m.actualStepText },
            |m: &mut ExecuteStepRequest| { &mut m.actualStepText },
            ExecuteStepRequest::get_actualStepText,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "parsedStepText",
            |m: &ExecuteStepRequest| { &m.parsedStepText },
            |m: &mut ExecuteStepRequest| { &mut m.parsedStepText },
            ExecuteStepRequest::get_parsedStepText,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "scenarioFailing",
            |m: &ExecuteStepRequest| { &m.scenarioFailing },
            |m: &mut ExecuteStepRequest| { &mut m.scenarioFailing },
            ExecuteStepRequest::get_scenarioFailing,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parameters",
            |m: &ExecuteStepRequest| { &m.parameters },
            |m: &mut ExecuteStepRequest| { &mut m.parameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecuteStepRequest>(
            "ExecuteStepRequest",
            14,
            fields,
        )
    }
}

impl ::protobuf::Message for ExecuteStepRequest {
    fn is_initialized(&self) -> bool {
        if self.actualStepText.is_none() {
            return false;
        }
        if self.parsedStepText.is_none() {
            return false;
        }
        for v in &self.parameters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.actualStepText = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parsedStepText = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scenarioFailing = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.parameters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.actualStepText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.parsedStepText.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.scenarioFailing {
            my_size += 2;
        }
        for value in &self.parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.actualStepText.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.parsedStepText.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.scenarioFailing {
            os.write_bool(3, v)?;
        }
        for v in &self.parameters {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ExecuteStepRequest {
        ExecuteStepRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 14)
    }

    fn default_instance() -> &'static ExecuteStepRequest {
        static instance: ExecuteStepRequest = ExecuteStepRequest {
            actualStepText: ::std::option::Option::None,
            parsedStepText: ::std::option::Option::None,
            scenarioFailing: ::std::option::Option::None,
            parameters: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ExecuteStepRequest {
    fn clear(&mut self) {
        self.actualStepText = ::std::option::Option::None;
        self.parsedStepText = ::std::option::Option::None;
        self.scenarioFailing = ::std::option::Option::None;
        self.parameters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteStepRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request sent ot the runner to check if given Step is valid. 
/// / The runner should check if there is an implementation defined for the given Step Text.
#[derive(PartialEq,Clone,Default)]
pub struct StepValidateRequest {
    // message fields
    /// / The text is used to lookup Step implementation
    stepText: ::std::option::Option<::std::string::String>,
    /// / The number of paramters in the Step
    numberOfParameters: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a StepValidateRequest {
    fn default() -> &'a StepValidateRequest {
        <StepValidateRequest as ::protobuf::Message>::default_instance()
    }
}

impl StepValidateRequest {
    pub fn new() -> StepValidateRequest {
        ::std::default::Default::default()
    }

    // required string stepText = 1;

    pub fn get_stepText(&self) -> &str {
        match self.stepText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stepText(&mut self) {
        self.stepText = ::std::option::Option::None;
    }

    pub fn has_stepText(&self) -> bool {
        self.stepText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stepText(&mut self, v: ::std::string::String) {
        self.stepText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stepText(&mut self) -> &mut ::std::string::String {
        if self.stepText.is_none() {
            self.stepText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stepText.as_mut().unwrap()
    }

    // Take field
    pub fn take_stepText(&mut self) -> ::std::string::String {
        self.stepText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 numberOfParameters = 2;

    pub fn get_numberOfParameters(&self) -> i32 {
        self.numberOfParameters.unwrap_or(0)
    }

    pub fn clear_numberOfParameters(&mut self) {
        self.numberOfParameters = ::std::option::Option::None;
    }

    pub fn has_numberOfParameters(&self) -> bool {
        self.numberOfParameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numberOfParameters(&mut self, v: i32) {
        self.numberOfParameters = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "stepText",
            |m: &StepValidateRequest| { &m.stepText },
            |m: &mut StepValidateRequest| { &mut m.stepText },
            StepValidateRequest::get_stepText,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "numberOfParameters",
            |m: &StepValidateRequest| { &m.numberOfParameters },
            |m: &mut StepValidateRequest| { &mut m.numberOfParameters },
            StepValidateRequest::get_numberOfParameters,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepValidateRequest>(
            "StepValidateRequest",
            15,
            fields,
        )
    }
}

impl ::protobuf::Message for StepValidateRequest {
    fn is_initialized(&self) -> bool {
        if self.stepText.is_none() {
            return false;
        }
        if self.numberOfParameters.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stepText = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.numberOfParameters = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stepText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.numberOfParameters {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stepText.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.numberOfParameters {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> StepValidateRequest {
        StepValidateRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 15)
    }

    fn default_instance() -> &'static StepValidateRequest {
        static instance: StepValidateRequest = StepValidateRequest {
            stepText: ::std::option::Option::None,
            numberOfParameters: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for StepValidateRequest {
    fn clear(&mut self) {
        self.stepText = ::std::option::Option::None;
        self.numberOfParameters = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StepValidateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepValidateRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response of StepValidateRequest.
/// / The runner tells the caller if the Request was valid, 
/// / i.e. an implementation exists for given Step text.
/// / Returns an error message if it is an error response.
#[derive(PartialEq,Clone,Default)]
pub struct StepValidateResponse {
    // message fields
    isValid: ::std::option::Option<bool>,
    errorMessage: ::std::option::Option<::std::string::String>,
    errorType: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<step_validate_response::ErrorType>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a StepValidateResponse {
    fn default() -> &'a StepValidateResponse {
        <StepValidateResponse as ::protobuf::Message>::default_instance()
    }
}

impl StepValidateResponse {
    pub fn new() -> StepValidateResponse {
        ::std::default::Default::default()
    }

    // required bool isValid = 1;

    pub fn get_isValid(&self) -> bool {
        self.isValid.unwrap_or(false)
    }

    pub fn clear_isValid(&mut self) {
        self.isValid = ::std::option::Option::None;
    }

    pub fn has_isValid(&self) -> bool {
        self.isValid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isValid(&mut self, v: bool) {
        self.isValid = ::std::option::Option::Some(v);
    }

    // optional string errorMessage = 2;

    pub fn get_errorMessage(&self) -> &str {
        match self.errorMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_errorMessage(&mut self) {
        self.errorMessage = ::std::option::Option::None;
    }

    pub fn has_errorMessage(&self) -> bool {
        self.errorMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorMessage(&mut self, v: ::std::string::String) {
        self.errorMessage = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorMessage(&mut self) -> &mut ::std::string::String {
        if self.errorMessage.is_none() {
            self.errorMessage = ::std::option::Option::Some(::std::string::String::new());
        }
        self.errorMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_errorMessage(&mut self) -> ::std::string::String {
        self.errorMessage.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .gauge.messages.StepValidateResponse.ErrorType errorType = 3;

    pub fn get_errorType(&self) -> step_validate_response::ErrorType {
        match self.errorType {
            Some(e) => e.enum_value_or(step_validate_response::ErrorType::STEP_IMPLEMENTATION_NOT_FOUND),
            None => step_validate_response::ErrorType::STEP_IMPLEMENTATION_NOT_FOUND,
        }
    }

    pub fn clear_errorType(&mut self) {
        self.errorType = ::std::option::Option::None;
    }

    pub fn has_errorType(&self) -> bool {
        self.errorType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorType(&mut self, v: step_validate_response::ErrorType) {
        self.errorType = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "isValid",
            |m: &StepValidateResponse| { &m.isValid },
            |m: &mut StepValidateResponse| { &mut m.isValid },
            StepValidateResponse::get_isValid,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "errorMessage",
            |m: &StepValidateResponse| { &m.errorMessage },
            |m: &mut StepValidateResponse| { &mut m.errorMessage },
            StepValidateResponse::get_errorMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, step_validate_response::ErrorType>(
            "errorType",
            |m: &StepValidateResponse| { &m.errorType },
            |m: &mut StepValidateResponse| { &mut m.errorType },
            step_validate_response::ErrorType::STEP_IMPLEMENTATION_NOT_FOUND,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepValidateResponse>(
            "StepValidateResponse",
            16,
            fields,
        )
    }
}

impl ::protobuf::Message for StepValidateResponse {
    fn is_initialized(&self) -> bool {
        if self.isValid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.isValid = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.errorMessage = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.errorType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.isValid {
            my_size += 2;
        }
        if let Some(v) = self.errorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.errorType {
            my_size += ::protobuf::rt::enum_or_unknown_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.isValid {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.errorMessage.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.errorType {
            os.write_enum(3, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> StepValidateResponse {
        StepValidateResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 16)
    }

    fn default_instance() -> &'static StepValidateResponse {
        static instance: StepValidateResponse = StepValidateResponse {
            isValid: ::std::option::Option::None,
            errorMessage: ::std::option::Option::None,
            errorType: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for StepValidateResponse {
    fn clear(&mut self) {
        self.isValid = ::std::option::Option::None;
        self.errorMessage = ::std::option::Option::None;
        self.errorType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StepValidateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepValidateResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StepValidateResponse`
pub mod step_validate_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum ErrorType {
        STEP_IMPLEMENTATION_NOT_FOUND = 0,
        DUPLICATE_STEP_IMPLEMENTATION = 1,
    }

    impl ::protobuf::ProtobufEnum for ErrorType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ErrorType> {
            match value {
                0 => ::std::option::Option::Some(ErrorType::STEP_IMPLEMENTATION_NOT_FOUND),
                1 => ::std::option::Option::Some(ErrorType::DUPLICATE_STEP_IMPLEMENTATION),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [ErrorType] = &[
                ErrorType::STEP_IMPLEMENTATION_NOT_FOUND,
                ErrorType::DUPLICATE_STEP_IMPLEMENTATION,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 0)
        }
    }

    impl ::std::default::Default for ErrorType {
        fn default() -> Self {
            ErrorType::STEP_IMPLEMENTATION_NOT_FOUND
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ErrorType {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl ErrorType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<ErrorType>("StepValidateResponse.ErrorType", 0)
        }
    }
}

/// / Result of the Suite Execution.
#[derive(PartialEq,Clone,Default)]
pub struct SuiteExecutionResult {
    // message fields
    pub suiteResult: ::protobuf::MessageField<super::spec::ProtoSuiteResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SuiteExecutionResult {
    fn default() -> &'a SuiteExecutionResult {
        <SuiteExecutionResult as ::protobuf::Message>::default_instance()
    }
}

impl SuiteExecutionResult {
    pub fn new() -> SuiteExecutionResult {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::spec::ProtoSuiteResult>(
            "suiteResult",
            |m: &SuiteExecutionResult| { &m.suiteResult },
            |m: &mut SuiteExecutionResult| { &mut m.suiteResult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SuiteExecutionResult>(
            "SuiteExecutionResult",
            17,
            fields,
        )
    }
}

impl ::protobuf::Message for SuiteExecutionResult {
    fn is_initialized(&self) -> bool {
        if self.suiteResult.is_none() {
            return false;
        }
        for v in &self.suiteResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.suiteResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.suiteResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.suiteResult.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SuiteExecutionResult {
        SuiteExecutionResult::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 17)
    }

    fn default_instance() -> &'static SuiteExecutionResult {
        static instance: SuiteExecutionResult = SuiteExecutionResult {
            suiteResult: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SuiteExecutionResult {
    fn clear(&mut self) {
        self.suiteResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SuiteExecutionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SuiteExecutionResult {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Requests Gauge to give all Step Names.
#[derive(PartialEq,Clone,Default)]
pub struct StepNamesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a StepNamesRequest {
    fn default() -> &'a StepNamesRequest {
        <StepNamesRequest as ::protobuf::Message>::default_instance()
    }
}

impl StepNamesRequest {
    pub fn new() -> StepNamesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepNamesRequest>(
            "StepNamesRequest",
            18,
            fields,
        )
    }
}

impl ::protobuf::Message for StepNamesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> StepNamesRequest {
        StepNamesRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 18)
    }

    fn default_instance() -> &'static StepNamesRequest {
        static instance: StepNamesRequest = StepNamesRequest {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for StepNamesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StepNamesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepNamesRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response to StepNamesRequest
#[derive(PartialEq,Clone,Default)]
pub struct StepNamesResponse {
    // message fields
    /// / Collection of strings corresponding to Step texts.
    pub steps: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a StepNamesResponse {
    fn default() -> &'a StepNamesResponse {
        <StepNamesResponse as ::protobuf::Message>::default_instance()
    }
}

impl StepNamesResponse {
    pub fn new() -> StepNamesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &StepNamesResponse| { &m.steps },
            |m: &mut StepNamesResponse| { &mut m.steps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepNamesResponse>(
            "StepNamesResponse",
            19,
            fields,
        )
    }
}

impl ::protobuf::Message for StepNamesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.steps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.steps {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.steps {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> StepNamesResponse {
        StepNamesResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 19)
    }

    fn default_instance() -> &'static StepNamesResponse {
        static instance: StepNamesResponse = StepNamesResponse {
            steps: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for StepNamesResponse {
    fn clear(&mut self) {
        self.steps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StepNamesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepNamesResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request runner to initialize Scenario DataStore
/// / Scenario Datastore is reset after every Scenario execution.
#[derive(PartialEq,Clone,Default)]
pub struct ScenarioDataStoreInitRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScenarioDataStoreInitRequest {
    fn default() -> &'a ScenarioDataStoreInitRequest {
        <ScenarioDataStoreInitRequest as ::protobuf::Message>::default_instance()
    }
}

impl ScenarioDataStoreInitRequest {
    pub fn new() -> ScenarioDataStoreInitRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScenarioDataStoreInitRequest>(
            "ScenarioDataStoreInitRequest",
            20,
            fields,
        )
    }
}

impl ::protobuf::Message for ScenarioDataStoreInitRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ScenarioDataStoreInitRequest {
        ScenarioDataStoreInitRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 20)
    }

    fn default_instance() -> &'static ScenarioDataStoreInitRequest {
        static instance: ScenarioDataStoreInitRequest = ScenarioDataStoreInitRequest {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ScenarioDataStoreInitRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScenarioDataStoreInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScenarioDataStoreInitRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request runner to initialize Spec DataStore
/// / Spec Datastore is reset after every Spec execution.
#[derive(PartialEq,Clone,Default)]
pub struct SpecDataStoreInitRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpecDataStoreInitRequest {
    fn default() -> &'a SpecDataStoreInitRequest {
        <SpecDataStoreInitRequest as ::protobuf::Message>::default_instance()
    }
}

impl SpecDataStoreInitRequest {
    pub fn new() -> SpecDataStoreInitRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpecDataStoreInitRequest>(
            "SpecDataStoreInitRequest",
            21,
            fields,
        )
    }
}

impl ::protobuf::Message for SpecDataStoreInitRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SpecDataStoreInitRequest {
        SpecDataStoreInitRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 21)
    }

    fn default_instance() -> &'static SpecDataStoreInitRequest {
        static instance: SpecDataStoreInitRequest = SpecDataStoreInitRequest {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SpecDataStoreInitRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpecDataStoreInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpecDataStoreInitRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request runner to initialize Suite DataStore
/// / Suite Datastore is reset after every Suite execution.
#[derive(PartialEq,Clone,Default)]
pub struct SuiteDataStoreInitRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a SuiteDataStoreInitRequest {
    fn default() -> &'a SuiteDataStoreInitRequest {
        <SuiteDataStoreInitRequest as ::protobuf::Message>::default_instance()
    }
}

impl SuiteDataStoreInitRequest {
    pub fn new() -> SuiteDataStoreInitRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SuiteDataStoreInitRequest>(
            "SuiteDataStoreInitRequest",
            22,
            fields,
        )
    }
}

impl ::protobuf::Message for SuiteDataStoreInitRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> SuiteDataStoreInitRequest {
        SuiteDataStoreInitRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 22)
    }

    fn default_instance() -> &'static SuiteDataStoreInitRequest {
        static instance: SuiteDataStoreInitRequest = SuiteDataStoreInitRequest {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for SuiteDataStoreInitRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SuiteDataStoreInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SuiteDataStoreInitRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Holds the new and old positions of a parameter.
/// / Used when refactoring a Step.
#[derive(PartialEq,Clone,Default)]
pub struct ParameterPosition {
    // message fields
    oldPosition: ::std::option::Option<i32>,
    newPosition: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ParameterPosition {
    fn default() -> &'a ParameterPosition {
        <ParameterPosition as ::protobuf::Message>::default_instance()
    }
}

impl ParameterPosition {
    pub fn new() -> ParameterPosition {
        ::std::default::Default::default()
    }

    // required int32 oldPosition = 1;

    pub fn get_oldPosition(&self) -> i32 {
        self.oldPosition.unwrap_or(0)
    }

    pub fn clear_oldPosition(&mut self) {
        self.oldPosition = ::std::option::Option::None;
    }

    pub fn has_oldPosition(&self) -> bool {
        self.oldPosition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldPosition(&mut self, v: i32) {
        self.oldPosition = ::std::option::Option::Some(v);
    }

    // required int32 newPosition = 2;

    pub fn get_newPosition(&self) -> i32 {
        self.newPosition.unwrap_or(0)
    }

    pub fn clear_newPosition(&mut self) {
        self.newPosition = ::std::option::Option::None;
    }

    pub fn has_newPosition(&self) -> bool {
        self.newPosition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newPosition(&mut self, v: i32) {
        self.newPosition = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "oldPosition",
            |m: &ParameterPosition| { &m.oldPosition },
            |m: &mut ParameterPosition| { &mut m.oldPosition },
            ParameterPosition::get_oldPosition,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "newPosition",
            |m: &ParameterPosition| { &m.newPosition },
            |m: &mut ParameterPosition| { &mut m.newPosition },
            ParameterPosition::get_newPosition,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParameterPosition>(
            "ParameterPosition",
            23,
            fields,
        )
    }
}

impl ::protobuf::Message for ParameterPosition {
    fn is_initialized(&self) -> bool {
        if self.oldPosition.is_none() {
            return false;
        }
        if self.newPosition.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oldPosition = ::std::option::Option::Some(is.read_int32()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.newPosition = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.oldPosition {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.newPosition {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.oldPosition {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.newPosition {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ParameterPosition {
        ParameterPosition::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 23)
    }

    fn default_instance() -> &'static ParameterPosition {
        static instance: ParameterPosition = ParameterPosition {
            oldPosition: ::std::option::Option::None,
            newPosition: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ParameterPosition {
    fn clear(&mut self) {
        self.oldPosition = ::std::option::Option::None;
        self.newPosition = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParameterPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParameterPosition {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Tells the runner to refactor the specified Step.
#[derive(PartialEq,Clone,Default)]
pub struct RefactorRequest {
    // message fields
    /// / Old value, used to lookup Step to refactor
    pub oldStepValue: ::protobuf::MessageField<super::spec::ProtoStepValue>,
    /// / New value, the to-be value of Step being refactored.
    pub newStepValue: ::protobuf::MessageField<super::spec::ProtoStepValue>,
    /// / Holds parameter positions of all parameters. Contains old and new parameter positions.
    pub paramPositions: ::std::vec::Vec<ParameterPosition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefactorRequest {
    fn default() -> &'a RefactorRequest {
        <RefactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl RefactorRequest {
    pub fn new() -> RefactorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::spec::ProtoStepValue>(
            "oldStepValue",
            |m: &RefactorRequest| { &m.oldStepValue },
            |m: &mut RefactorRequest| { &mut m.oldStepValue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::spec::ProtoStepValue>(
            "newStepValue",
            |m: &RefactorRequest| { &m.newStepValue },
            |m: &mut RefactorRequest| { &mut m.newStepValue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "paramPositions",
            |m: &RefactorRequest| { &m.paramPositions },
            |m: &mut RefactorRequest| { &mut m.paramPositions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RefactorRequest>(
            "RefactorRequest",
            24,
            fields,
        )
    }
}

impl ::protobuf::Message for RefactorRequest {
    fn is_initialized(&self) -> bool {
        if self.oldStepValue.is_none() {
            return false;
        }
        if self.newStepValue.is_none() {
            return false;
        }
        for v in &self.oldStepValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newStepValue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.paramPositions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.oldStepValue)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.newStepValue)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.paramPositions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.oldStepValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.newStepValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.paramPositions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.oldStepValue.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.newStepValue.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.paramPositions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RefactorRequest {
        RefactorRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 24)
    }

    fn default_instance() -> &'static RefactorRequest {
        static instance: RefactorRequest = RefactorRequest {
            oldStepValue: ::protobuf::MessageField::none(),
            newStepValue: ::protobuf::MessageField::none(),
            paramPositions: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RefactorRequest {
    fn clear(&mut self) {
        self.oldStepValue.clear();
        self.newStepValue.clear();
        self.paramPositions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefactorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefactorRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response of a RefactorRequest
#[derive(PartialEq,Clone,Default)]
pub struct RefactorResponse {
    // message fields
    /// / Flag indicating the success of Refactor operation.
    success: ::std::option::Option<bool>,
    /// / Error message, valid only if Refactor wasn't successful
    error: ::std::option::Option<::std::string::String>,
    /// / List of files that were affected because of the refactoring.
    pub filesChanged: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefactorResponse {
    fn default() -> &'a RefactorResponse {
        <RefactorResponse as ::protobuf::Message>::default_instance()
    }
}

impl RefactorResponse {
    pub fn new() -> RefactorResponse {
        ::std::default::Default::default()
    }

    // required bool success = 1;

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    // optional string error = 2;

    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "success",
            |m: &RefactorResponse| { &m.success },
            |m: &mut RefactorResponse| { &mut m.success },
            RefactorResponse::get_success,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "error",
            |m: &RefactorResponse| { &m.error },
            |m: &mut RefactorResponse| { &mut m.error },
            RefactorResponse::get_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filesChanged",
            |m: &RefactorResponse| { &m.filesChanged },
            |m: &mut RefactorResponse| { &mut m.filesChanged },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RefactorResponse>(
            "RefactorResponse",
            25,
            fields,
        )
    }
}

impl ::protobuf::Message for RefactorResponse {
    fn is_initialized(&self) -> bool {
        if self.success.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.filesChanged)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.filesChanged {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.error.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.filesChanged {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> RefactorResponse {
        RefactorResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 25)
    }

    fn default_instance() -> &'static RefactorResponse {
        static instance: RefactorResponse = RefactorResponse {
            success: ::std::option::Option::None,
            error: ::std::option::Option::None,
            filesChanged: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for RefactorResponse {
    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.filesChanged.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefactorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefactorResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request for details on a Single Step.
#[derive(PartialEq,Clone,Default)]
pub struct StepNameRequest {
    // message fields
    /// / Step text to lookup the Step. 
    /// / This is the parsed step value, i.e. with placeholders for parameters.
    stepValue: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a StepNameRequest {
    fn default() -> &'a StepNameRequest {
        <StepNameRequest as ::protobuf::Message>::default_instance()
    }
}

impl StepNameRequest {
    pub fn new() -> StepNameRequest {
        ::std::default::Default::default()
    }

    // required string stepValue = 1;

    pub fn get_stepValue(&self) -> &str {
        match self.stepValue.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stepValue(&mut self) {
        self.stepValue = ::std::option::Option::None;
    }

    pub fn has_stepValue(&self) -> bool {
        self.stepValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stepValue(&mut self, v: ::std::string::String) {
        self.stepValue = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stepValue(&mut self) -> &mut ::std::string::String {
        if self.stepValue.is_none() {
            self.stepValue = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stepValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_stepValue(&mut self) -> ::std::string::String {
        self.stepValue.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "stepValue",
            |m: &StepNameRequest| { &m.stepValue },
            |m: &mut StepNameRequest| { &mut m.stepValue },
            StepNameRequest::get_stepValue,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepNameRequest>(
            "StepNameRequest",
            26,
            fields,
        )
    }
}

impl ::protobuf::Message for StepNameRequest {
    fn is_initialized(&self) -> bool {
        if self.stepValue.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stepValue = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stepValue.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stepValue.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> StepNameRequest {
        StepNameRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 26)
    }

    fn default_instance() -> &'static StepNameRequest {
        static instance: StepNameRequest = StepNameRequest {
            stepValue: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for StepNameRequest {
    fn clear(&mut self) {
        self.stepValue = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StepNameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepNameRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response to StepNameRequest.
#[derive(PartialEq,Clone,Default)]
pub struct StepNameResponse {
    // message fields
    /// / Flag indicating if there is a match for the given Step Text.
    isStepPresent: ::std::option::Option<bool>,
    /// / The Step name of the given step. 
    pub stepName: ::std::vec::Vec<::std::string::String>,
    /// / Flag indicating if the given Step is an alias.
    hasAlias: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a StepNameResponse {
    fn default() -> &'a StepNameResponse {
        <StepNameResponse as ::protobuf::Message>::default_instance()
    }
}

impl StepNameResponse {
    pub fn new() -> StepNameResponse {
        ::std::default::Default::default()
    }

    // required bool isStepPresent = 1;

    pub fn get_isStepPresent(&self) -> bool {
        self.isStepPresent.unwrap_or(false)
    }

    pub fn clear_isStepPresent(&mut self) {
        self.isStepPresent = ::std::option::Option::None;
    }

    pub fn has_isStepPresent(&self) -> bool {
        self.isStepPresent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isStepPresent(&mut self, v: bool) {
        self.isStepPresent = ::std::option::Option::Some(v);
    }

    // required bool hasAlias = 3;

    pub fn get_hasAlias(&self) -> bool {
        self.hasAlias.unwrap_or(false)
    }

    pub fn clear_hasAlias(&mut self) {
        self.hasAlias = ::std::option::Option::None;
    }

    pub fn has_hasAlias(&self) -> bool {
        self.hasAlias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasAlias(&mut self, v: bool) {
        self.hasAlias = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "isStepPresent",
            |m: &StepNameResponse| { &m.isStepPresent },
            |m: &mut StepNameResponse| { &mut m.isStepPresent },
            StepNameResponse::get_isStepPresent,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stepName",
            |m: &StepNameResponse| { &m.stepName },
            |m: &mut StepNameResponse| { &mut m.stepName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "hasAlias",
            |m: &StepNameResponse| { &m.hasAlias },
            |m: &mut StepNameResponse| { &mut m.hasAlias },
            StepNameResponse::get_hasAlias,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StepNameResponse>(
            "StepNameResponse",
            27,
            fields,
        )
    }
}

impl ::protobuf::Message for StepNameResponse {
    fn is_initialized(&self) -> bool {
        if self.isStepPresent.is_none() {
            return false;
        }
        if self.hasAlias.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.isStepPresent = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.stepName)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hasAlias = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.isStepPresent {
            my_size += 2;
        }
        for value in &self.stepName {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.hasAlias {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.isStepPresent {
            os.write_bool(1, v)?;
        }
        for v in &self.stepName {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.hasAlias {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> StepNameResponse {
        StepNameResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 27)
    }

    fn default_instance() -> &'static StepNameResponse {
        static instance: StepNameResponse = StepNameResponse {
            isStepPresent: ::std::option::Option::None,
            stepName: ::std::vec::Vec::new(),
            hasAlias: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for StepNameResponse {
    fn clear(&mut self) {
        self.isStepPresent = ::std::option::Option::None;
        self.stepName.clear();
        self.hasAlias = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StepNameResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepNameResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response when a unsupported message request is sent.
#[derive(PartialEq,Clone,Default)]
pub struct UnsupportedMessageResponse {
    // message fields
    message: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnsupportedMessageResponse {
    fn default() -> &'a UnsupportedMessageResponse {
        <UnsupportedMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl UnsupportedMessageResponse {
    pub fn new() -> UnsupportedMessageResponse {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "message",
            |m: &UnsupportedMessageResponse| { &m.message },
            |m: &mut UnsupportedMessageResponse| { &mut m.message },
            UnsupportedMessageResponse::get_message,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnsupportedMessageResponse>(
            "UnsupportedMessageResponse",
            28,
            fields,
        )
    }
}

impl ::protobuf::Message for UnsupportedMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> UnsupportedMessageResponse {
        UnsupportedMessageResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 28)
    }

    fn default_instance() -> &'static UnsupportedMessageResponse {
        static instance: UnsupportedMessageResponse = UnsupportedMessageResponse {
            message: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for UnsupportedMessageResponse {
    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnsupportedMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsupportedMessageResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / This is the message which gets transferred all the time
/// / with proper message type set
/// / One of the Request/Response fields will have value, depending on the MessageType set.
#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message fields
    messageType: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<message::MessageType>>,
    /// / A unique id to represent this message. A response to the message should copy over this value.
    /// / This is used to synchronize messages & responses
    messageId: ::std::option::Option<i64>,
    /// / [ExecutionStartingRequest](#gauge.messages.ExecutionStartingRequest)
    pub executionStartingRequest: ::protobuf::MessageField<ExecutionStartingRequest>,
    /// / [SpecExecutionStartingRequest](#gauge.messages.SpecExecutionStartingRequest)
    pub specExecutionStartingRequest: ::protobuf::MessageField<SpecExecutionStartingRequest>,
    /// / [SpecExecutionEndingRequest](#gauge.messages.SpecExecutionEndingRequest)
    pub specExecutionEndingRequest: ::protobuf::MessageField<SpecExecutionEndingRequest>,
    /// / [ScenarioExecutionStartingRequest](#gauge.messages.ScenarioExecutionStartingRequest)
    pub scenarioExecutionStartingRequest: ::protobuf::MessageField<ScenarioExecutionStartingRequest>,
    /// / [ScenarioExecutionEndingRequest](#gauge.messages.ScenarioExecutionEndingRequest)
    pub scenarioExecutionEndingRequest: ::protobuf::MessageField<ScenarioExecutionEndingRequest>,
    /// / [StepExecutionStartingRequest](#gauge.messages.StepExecutionStartingRequest)
    pub stepExecutionStartingRequest: ::protobuf::MessageField<StepExecutionStartingRequest>,
    /// / [StepExecutionEndingRequest](#gauge.messages.StepExecutionEndingRequest)
    pub stepExecutionEndingRequest: ::protobuf::MessageField<StepExecutionEndingRequest>,
    /// / [ExecuteStepRequest](#gauge.messages.ExecuteStepRequest)
    pub executeStepRequest: ::protobuf::MessageField<ExecuteStepRequest>,
    /// / [ExecutionEndingRequest](#gauge.messages.ExecutionEndingRequest)
    pub executionEndingRequest: ::protobuf::MessageField<ExecutionEndingRequest>,
    /// / [StepValidateRequest](#gauge.messages.StepValidateRequest)
    pub stepValidateRequest: ::protobuf::MessageField<StepValidateRequest>,
    /// / [StepValidateResponse](#gauge.messages.StepValidateResponse)
    pub stepValidateResponse: ::protobuf::MessageField<StepValidateResponse>,
    /// / [ExecutionStatusResponse](#gauge.messages.ExecutionStatusResponse)
    pub executionStatusResponse: ::protobuf::MessageField<ExecutionStatusResponse>,
    /// / [StepNamesRequest](#gauge.messages.StepNamesRequest)
    pub stepNamesRequest: ::protobuf::MessageField<StepNamesRequest>,
    /// / [StepNamesResponse](#gauge.messages.StepNamesResponse)
    pub stepNamesResponse: ::protobuf::MessageField<StepNamesResponse>,
    /// / [SuiteExecutionResult ](#gauge.messages.SuiteExecutionResult )
    pub suiteExecutionResult: ::protobuf::MessageField<SuiteExecutionResult>,
    /// / [KillProcessRequest](#gauge.messages.KillProcessRequest)
    pub killProcessRequest: ::protobuf::MessageField<KillProcessRequest>,
    /// / [ScenarioDataStoreInitRequest](#gauge.messages.ScenarioDataStoreInitRequest)
    pub scenarioDataStoreInitRequest: ::protobuf::MessageField<ScenarioDataStoreInitRequest>,
    /// / [SpecDataStoreInitRequest](#gauge.messages.SpecDataStoreInitRequest)
    pub specDataStoreInitRequest: ::protobuf::MessageField<SpecDataStoreInitRequest>,
    /// / [SuiteDataStoreInitRequest](#gauge.messages.SuiteDataStoreInitRequest)
    pub suiteDataStoreInitRequest: ::protobuf::MessageField<SuiteDataStoreInitRequest>,
    /// / [StepNameRequest](#gauge.messages.StepNameRequest)
    pub stepNameRequest: ::protobuf::MessageField<StepNameRequest>,
    /// / [StepNameResponse](#gauge.messages.StepNameResponse)
    pub stepNameResponse: ::protobuf::MessageField<StepNameResponse>,
    /// / [RefactorRequest](#gauge.messages.RefactorRequest)
    pub refactorRequest: ::protobuf::MessageField<RefactorRequest>,
    /// / [RefactorResponse](#gauge.messages.RefactorResponse)
    pub refactorResponse: ::protobuf::MessageField<RefactorResponse>,
    /// / [UnsupportedMessageResponse](#gauge.messages.UnsupportedMessageResponse)
    pub unsupportedMessageResponse: ::protobuf::MessageField<UnsupportedMessageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // required .gauge.messages.Message.MessageType messageType = 1;

    pub fn get_messageType(&self) -> message::MessageType {
        match self.messageType {
            Some(e) => e.enum_value_or(message::MessageType::ExecutionStarting),
            None => message::MessageType::ExecutionStarting,
        }
    }

    pub fn clear_messageType(&mut self) {
        self.messageType = ::std::option::Option::None;
    }

    pub fn has_messageType(&self) -> bool {
        self.messageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageType(&mut self, v: message::MessageType) {
        self.messageType = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // required int64 messageId = 2;

    pub fn get_messageId(&self) -> i64 {
        self.messageId.unwrap_or(0)
    }

    pub fn clear_messageId(&mut self) {
        self.messageId = ::std::option::Option::None;
    }

    pub fn has_messageId(&self) -> bool {
        self.messageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageId(&mut self, v: i64) {
        self.messageId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, message::MessageType>(
            "messageType",
            |m: &Message| { &m.messageType },
            |m: &mut Message| { &mut m.messageType },
            message::MessageType::ExecutionStarting,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "messageId",
            |m: &Message| { &m.messageId },
            |m: &mut Message| { &mut m.messageId },
            Message::get_messageId,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecutionStartingRequest>(
            "executionStartingRequest",
            |m: &Message| { &m.executionStartingRequest },
            |m: &mut Message| { &mut m.executionStartingRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SpecExecutionStartingRequest>(
            "specExecutionStartingRequest",
            |m: &Message| { &m.specExecutionStartingRequest },
            |m: &mut Message| { &mut m.specExecutionStartingRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SpecExecutionEndingRequest>(
            "specExecutionEndingRequest",
            |m: &Message| { &m.specExecutionEndingRequest },
            |m: &mut Message| { &mut m.specExecutionEndingRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScenarioExecutionStartingRequest>(
            "scenarioExecutionStartingRequest",
            |m: &Message| { &m.scenarioExecutionStartingRequest },
            |m: &mut Message| { &mut m.scenarioExecutionStartingRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScenarioExecutionEndingRequest>(
            "scenarioExecutionEndingRequest",
            |m: &Message| { &m.scenarioExecutionEndingRequest },
            |m: &mut Message| { &mut m.scenarioExecutionEndingRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StepExecutionStartingRequest>(
            "stepExecutionStartingRequest",
            |m: &Message| { &m.stepExecutionStartingRequest },
            |m: &mut Message| { &mut m.stepExecutionStartingRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StepExecutionEndingRequest>(
            "stepExecutionEndingRequest",
            |m: &Message| { &m.stepExecutionEndingRequest },
            |m: &mut Message| { &mut m.stepExecutionEndingRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecuteStepRequest>(
            "executeStepRequest",
            |m: &Message| { &m.executeStepRequest },
            |m: &mut Message| { &mut m.executeStepRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecutionEndingRequest>(
            "executionEndingRequest",
            |m: &Message| { &m.executionEndingRequest },
            |m: &mut Message| { &mut m.executionEndingRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StepValidateRequest>(
            "stepValidateRequest",
            |m: &Message| { &m.stepValidateRequest },
            |m: &mut Message| { &mut m.stepValidateRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StepValidateResponse>(
            "stepValidateResponse",
            |m: &Message| { &m.stepValidateResponse },
            |m: &mut Message| { &mut m.stepValidateResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExecutionStatusResponse>(
            "executionStatusResponse",
            |m: &Message| { &m.executionStatusResponse },
            |m: &mut Message| { &mut m.executionStatusResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StepNamesRequest>(
            "stepNamesRequest",
            |m: &Message| { &m.stepNamesRequest },
            |m: &mut Message| { &mut m.stepNamesRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StepNamesResponse>(
            "stepNamesResponse",
            |m: &Message| { &m.stepNamesResponse },
            |m: &mut Message| { &mut m.stepNamesResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SuiteExecutionResult>(
            "suiteExecutionResult",
            |m: &Message| { &m.suiteExecutionResult },
            |m: &mut Message| { &mut m.suiteExecutionResult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, KillProcessRequest>(
            "killProcessRequest",
            |m: &Message| { &m.killProcessRequest },
            |m: &mut Message| { &mut m.killProcessRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScenarioDataStoreInitRequest>(
            "scenarioDataStoreInitRequest",
            |m: &Message| { &m.scenarioDataStoreInitRequest },
            |m: &mut Message| { &mut m.scenarioDataStoreInitRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SpecDataStoreInitRequest>(
            "specDataStoreInitRequest",
            |m: &Message| { &m.specDataStoreInitRequest },
            |m: &mut Message| { &mut m.specDataStoreInitRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SuiteDataStoreInitRequest>(
            "suiteDataStoreInitRequest",
            |m: &Message| { &m.suiteDataStoreInitRequest },
            |m: &mut Message| { &mut m.suiteDataStoreInitRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StepNameRequest>(
            "stepNameRequest",
            |m: &Message| { &m.stepNameRequest },
            |m: &mut Message| { &mut m.stepNameRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StepNameResponse>(
            "stepNameResponse",
            |m: &Message| { &m.stepNameResponse },
            |m: &mut Message| { &mut m.stepNameResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RefactorRequest>(
            "refactorRequest",
            |m: &Message| { &m.refactorRequest },
            |m: &mut Message| { &mut m.refactorRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RefactorResponse>(
            "refactorResponse",
            |m: &Message| { &m.refactorResponse },
            |m: &mut Message| { &mut m.refactorResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UnsupportedMessageResponse>(
            "unsupportedMessageResponse",
            |m: &Message| { &m.unsupportedMessageResponse },
            |m: &mut Message| { &mut m.unsupportedMessageResponse },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            29,
            fields,
        )
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        if self.messageType.is_none() {
            return false;
        }
        if self.messageId.is_none() {
            return false;
        }
        for v in &self.executionStartingRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.specExecutionStartingRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.specExecutionEndingRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scenarioExecutionStartingRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scenarioExecutionEndingRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stepExecutionStartingRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stepExecutionEndingRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.executeStepRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.executionEndingRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stepValidateRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stepValidateResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.executionStatusResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stepNamesRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stepNamesResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.suiteExecutionResult {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.killProcessRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scenarioDataStoreInitRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.specDataStoreInitRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.suiteDataStoreInitRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stepNameRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stepNameResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refactorRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.refactorResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unsupportedMessageResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.messageType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.messageId = ::std::option::Option::Some(is.read_int64()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.executionStartingRequest)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.specExecutionStartingRequest)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.specExecutionEndingRequest)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.scenarioExecutionStartingRequest)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.scenarioExecutionEndingRequest)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepExecutionStartingRequest)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepExecutionEndingRequest)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.executeStepRequest)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.executionEndingRequest)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepValidateRequest)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepValidateResponse)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.executionStatusResponse)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepNamesRequest)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepNamesResponse)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.suiteExecutionResult)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.killProcessRequest)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.scenarioDataStoreInitRequest)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.specDataStoreInitRequest)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.suiteDataStoreInitRequest)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepNameRequest)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepNameResponse)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.refactorRequest)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.refactorResponse)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.unsupportedMessageResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.messageType {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.messageId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.executionStartingRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.specExecutionStartingRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.specExecutionEndingRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.scenarioExecutionStartingRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.scenarioExecutionEndingRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stepExecutionStartingRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stepExecutionEndingRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.executeStepRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.executionEndingRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stepValidateRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stepValidateResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.executionStatusResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stepNamesRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stepNamesResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.suiteExecutionResult.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.killProcessRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.scenarioDataStoreInitRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.specDataStoreInitRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.suiteDataStoreInitRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stepNameRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stepNameResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.refactorRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.refactorResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.unsupportedMessageResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.messageType {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.messageId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.executionStartingRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.specExecutionStartingRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.specExecutionEndingRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.scenarioExecutionStartingRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.scenarioExecutionEndingRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.stepExecutionStartingRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.stepExecutionEndingRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.executeStepRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.executionEndingRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.stepValidateRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.stepValidateResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.executionStatusResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.stepNamesRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.stepNamesResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.suiteExecutionResult.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.killProcessRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.scenarioDataStoreInitRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.specDataStoreInitRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.suiteDataStoreInitRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.stepNameRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.stepNameResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.refactorRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.refactorResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.unsupportedMessageResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 29)
    }

    fn default_instance() -> &'static Message {
        static instance: Message = Message {
            messageType: ::std::option::Option::None,
            messageId: ::std::option::Option::None,
            executionStartingRequest: ::protobuf::MessageField::none(),
            specExecutionStartingRequest: ::protobuf::MessageField::none(),
            specExecutionEndingRequest: ::protobuf::MessageField::none(),
            scenarioExecutionStartingRequest: ::protobuf::MessageField::none(),
            scenarioExecutionEndingRequest: ::protobuf::MessageField::none(),
            stepExecutionStartingRequest: ::protobuf::MessageField::none(),
            stepExecutionEndingRequest: ::protobuf::MessageField::none(),
            executeStepRequest: ::protobuf::MessageField::none(),
            executionEndingRequest: ::protobuf::MessageField::none(),
            stepValidateRequest: ::protobuf::MessageField::none(),
            stepValidateResponse: ::protobuf::MessageField::none(),
            executionStatusResponse: ::protobuf::MessageField::none(),
            stepNamesRequest: ::protobuf::MessageField::none(),
            stepNamesResponse: ::protobuf::MessageField::none(),
            suiteExecutionResult: ::protobuf::MessageField::none(),
            killProcessRequest: ::protobuf::MessageField::none(),
            scenarioDataStoreInitRequest: ::protobuf::MessageField::none(),
            specDataStoreInitRequest: ::protobuf::MessageField::none(),
            suiteDataStoreInitRequest: ::protobuf::MessageField::none(),
            stepNameRequest: ::protobuf::MessageField::none(),
            stepNameResponse: ::protobuf::MessageField::none(),
            refactorRequest: ::protobuf::MessageField::none(),
            refactorResponse: ::protobuf::MessageField::none(),
            unsupportedMessageResponse: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.messageType = ::std::option::Option::None;
        self.messageId = ::std::option::Option::None;
        self.executionStartingRequest.clear();
        self.specExecutionStartingRequest.clear();
        self.specExecutionEndingRequest.clear();
        self.scenarioExecutionStartingRequest.clear();
        self.scenarioExecutionEndingRequest.clear();
        self.stepExecutionStartingRequest.clear();
        self.stepExecutionEndingRequest.clear();
        self.executeStepRequest.clear();
        self.executionEndingRequest.clear();
        self.stepValidateRequest.clear();
        self.stepValidateResponse.clear();
        self.executionStatusResponse.clear();
        self.stepNamesRequest.clear();
        self.stepNamesResponse.clear();
        self.suiteExecutionResult.clear();
        self.killProcessRequest.clear();
        self.scenarioDataStoreInitRequest.clear();
        self.specDataStoreInitRequest.clear();
        self.suiteDataStoreInitRequest.clear();
        self.stepNameRequest.clear();
        self.stepNameResponse.clear();
        self.refactorRequest.clear();
        self.refactorResponse.clear();
        self.unsupportedMessageResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Message`
pub mod message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum MessageType {
        ExecutionStarting = 0,
        SpecExecutionStarting = 1,
        SpecExecutionEnding = 2,
        ScenarioExecutionStarting = 3,
        ScenarioExecutionEnding = 4,
        StepExecutionStarting = 5,
        StepExecutionEnding = 6,
        ExecuteStep = 7,
        ExecutionEnding = 8,
        StepValidateRequest = 9,
        StepValidateResponse = 10,
        ExecutionStatusResponse = 11,
        StepNamesRequest = 12,
        StepNamesResponse = 13,
        KillProcessRequest = 14,
        SuiteExecutionResult = 15,
        ScenarioDataStoreInit = 16,
        SpecDataStoreInit = 17,
        SuiteDataStoreInit = 18,
        StepNameRequest = 19,
        StepNameResponse = 20,
        RefactorRequest = 21,
        RefactorResponse = 22,
        UnsupportedMessageResponse = 23,
    }

    impl ::protobuf::ProtobufEnum for MessageType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MessageType> {
            match value {
                0 => ::std::option::Option::Some(MessageType::ExecutionStarting),
                1 => ::std::option::Option::Some(MessageType::SpecExecutionStarting),
                2 => ::std::option::Option::Some(MessageType::SpecExecutionEnding),
                3 => ::std::option::Option::Some(MessageType::ScenarioExecutionStarting),
                4 => ::std::option::Option::Some(MessageType::ScenarioExecutionEnding),
                5 => ::std::option::Option::Some(MessageType::StepExecutionStarting),
                6 => ::std::option::Option::Some(MessageType::StepExecutionEnding),
                7 => ::std::option::Option::Some(MessageType::ExecuteStep),
                8 => ::std::option::Option::Some(MessageType::ExecutionEnding),
                9 => ::std::option::Option::Some(MessageType::StepValidateRequest),
                10 => ::std::option::Option::Some(MessageType::StepValidateResponse),
                11 => ::std::option::Option::Some(MessageType::ExecutionStatusResponse),
                12 => ::std::option::Option::Some(MessageType::StepNamesRequest),
                13 => ::std::option::Option::Some(MessageType::StepNamesResponse),
                14 => ::std::option::Option::Some(MessageType::KillProcessRequest),
                15 => ::std::option::Option::Some(MessageType::SuiteExecutionResult),
                16 => ::std::option::Option::Some(MessageType::ScenarioDataStoreInit),
                17 => ::std::option::Option::Some(MessageType::SpecDataStoreInit),
                18 => ::std::option::Option::Some(MessageType::SuiteDataStoreInit),
                19 => ::std::option::Option::Some(MessageType::StepNameRequest),
                20 => ::std::option::Option::Some(MessageType::StepNameResponse),
                21 => ::std::option::Option::Some(MessageType::RefactorRequest),
                22 => ::std::option::Option::Some(MessageType::RefactorResponse),
                23 => ::std::option::Option::Some(MessageType::UnsupportedMessageResponse),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [MessageType] = &[
                MessageType::ExecutionStarting,
                MessageType::SpecExecutionStarting,
                MessageType::SpecExecutionEnding,
                MessageType::ScenarioExecutionStarting,
                MessageType::ScenarioExecutionEnding,
                MessageType::StepExecutionStarting,
                MessageType::StepExecutionEnding,
                MessageType::ExecuteStep,
                MessageType::ExecutionEnding,
                MessageType::StepValidateRequest,
                MessageType::StepValidateResponse,
                MessageType::ExecutionStatusResponse,
                MessageType::StepNamesRequest,
                MessageType::StepNamesResponse,
                MessageType::KillProcessRequest,
                MessageType::SuiteExecutionResult,
                MessageType::ScenarioDataStoreInit,
                MessageType::SpecDataStoreInit,
                MessageType::SuiteDataStoreInit,
                MessageType::StepNameRequest,
                MessageType::StepNameResponse,
                MessageType::RefactorRequest,
                MessageType::RefactorResponse,
                MessageType::UnsupportedMessageResponse,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 1)
        }
    }

    impl ::std::default::Default for MessageType {
        fn default() -> Self {
            MessageType::ExecutionStarting
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MessageType {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl MessageType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<MessageType>("Message.MessageType", 1)
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0emessages.proto\x12\x0egauge.messages\x1a\nspec.proto\"\x14\n\x12Ki\
    llProcessRequest\"i\n\x17ExecutionStatusResponse\x12N\n\x0fexecutionResu\
    lt\x18\x01\x20\x02(\x0b2$.gauge.messages.ProtoExecutionResultR\x0fexecut\
    ionResult\"m\n\x18ExecutionStartingRequest\x12Q\n\x14currentExecutionInf\
    o\x18\x01\x20\x01(\x0b2\x1d.gauge.messages.ExecutionInfoR\x14currentExec\
    utionInfo\"k\n\x16ExecutionEndingRequest\x12Q\n\x14currentExecutionInfo\
    \x18\x01\x20\x01(\x0b2\x1d.gauge.messages.ExecutionInfoR\x14currentExecu\
    tionInfo\"q\n\x1cSpecExecutionStartingRequest\x12Q\n\x14currentExecution\
    Info\x18\x01\x20\x01(\x0b2\x1d.gauge.messages.ExecutionInfoR\x14currentE\
    xecutionInfo\"o\n\x1aSpecExecutionEndingRequest\x12Q\n\x14currentExecuti\
    onInfo\x18\x01\x20\x01(\x0b2\x1d.gauge.messages.ExecutionInfoR\x14curren\
    tExecutionInfo\"u\n\x20ScenarioExecutionStartingRequest\x12Q\n\x14curren\
    tExecutionInfo\x18\x01\x20\x01(\x0b2\x1d.gauge.messages.ExecutionInfoR\
    \x14currentExecutionInfo\"s\n\x1eScenarioExecutionEndingRequest\x12Q\n\
    \x14currentExecutionInfo\x18\x01\x20\x01(\x0b2\x1d.gauge.messages.Execut\
    ionInfoR\x14currentExecutionInfo\"q\n\x1cStepExecutionStartingRequest\
    \x12Q\n\x14currentExecutionInfo\x18\x01\x20\x01(\x0b2\x1d.gauge.messages\
    .ExecutionInfoR\x14currentExecutionInfo\"o\n\x1aStepExecutionEndingReque\
    st\x12Q\n\x14currentExecutionInfo\x18\x01\x20\x01(\x0b2\x1d.gauge.messag\
    es.ExecutionInfoR\x14currentExecutionInfo\"\xef\x01\n\rExecutionInfo\x12\
    :\n\x0bcurrentSpec\x18\x01\x20\x01(\x0b2\x18.gauge.messages.SpecInfoR\
    \x0bcurrentSpec\x12F\n\x0fcurrentScenario\x18\x02\x20\x01(\x0b2\x1c.gaug\
    e.messages.ScenarioInfoR\x0fcurrentScenario\x12:\n\x0bcurrentStep\x18\
    \x03\x20\x01(\x0b2\x18.gauge.messages.StepInfoR\x0bcurrentStep\x12\x1e\n\
    \nstacktrace\x18\x04\x20\x01(\tR\nstacktrace\"j\n\x08SpecInfo\x12\x12\n\
    \x04name\x18\x01\x20\x02(\tR\x04name\x12\x1a\n\x08fileName\x18\x02\x20\
    \x02(\tR\x08fileName\x12\x1a\n\x08isFailed\x18\x03\x20\x02(\x08R\x08isFa\
    iled\x12\x12\n\x04tags\x18\x04\x20\x03(\tR\x04tags\"R\n\x0cScenarioInfo\
    \x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12\x1a\n\x08isFailed\x18\
    \x02\x20\x02(\x08R\x08isFailed\x12\x12\n\x04tags\x18\x03\x20\x03(\tR\x04\
    tags\"^\n\x08StepInfo\x126\n\x04step\x18\x01\x20\x02(\x0b2\".gauge.messa\
    ges.ExecuteStepRequestR\x04step\x12\x1a\n\x08isFailed\x18\x02\x20\x02(\
    \x08R\x08isFailed\"\xc9\x01\n\x12ExecuteStepRequest\x12&\n\x0eactualStep\
    Text\x18\x01\x20\x02(\tR\x0eactualStepText\x12&\n\x0eparsedStepText\x18\
    \x02\x20\x02(\tR\x0eparsedStepText\x12(\n\x0fscenarioFailing\x18\x03\x20\
    \x01(\x08R\x0fscenarioFailing\x129\n\nparameters\x18\x04\x20\x03(\x0b2\
    \x19.gauge.messages.ParameterR\nparameters\"a\n\x13StepValidateRequest\
    \x12\x1a\n\x08stepText\x18\x01\x20\x02(\tR\x08stepText\x12.\n\x12numberO\
    fParameters\x18\x02\x20\x02(\x05R\x12numberOfParameters\"\xf5\x01\n\x14S\
    tepValidateResponse\x12\x18\n\x07isValid\x18\x01\x20\x02(\x08R\x07isVali\
    d\x12\"\n\x0cerrorMessage\x18\x02\x20\x01(\tR\x0cerrorMessage\x12L\n\ter\
    rorType\x18\x03\x20\x01(\x0e2..gauge.messages.StepValidateResponse.Error\
    TypeR\terrorType\"Q\n\tErrorType\x12!\n\x1dSTEP_IMPLEMENTATION_NOT_FOUND\
    \x10\0\x12!\n\x1dDUPLICATE_STEP_IMPLEMENTATION\x10\x01\"Z\n\x14SuiteExec\
    utionResult\x12B\n\x0bsuiteResult\x18\x01\x20\x02(\x0b2\x20.gauge.messag\
    es.ProtoSuiteResultR\x0bsuiteResult\"\x12\n\x10StepNamesRequest\")\n\x11\
    StepNamesResponse\x12\x14\n\x05steps\x18\x01\x20\x03(\tR\x05steps\"\x1e\
    \n\x1cScenarioDataStoreInitRequest\"\x1a\n\x18SpecDataStoreInitRequest\"\
    \x1b\n\x19SuiteDataStoreInitRequest\"W\n\x11ParameterPosition\x12\x20\n\
    \x0boldPosition\x18\x01\x20\x02(\x05R\x0boldPosition\x12\x20\n\x0bnewPos\
    ition\x18\x02\x20\x02(\x05R\x0bnewPosition\"\xe4\x01\n\x0fRefactorReques\
    t\x12B\n\x0coldStepValue\x18\x01\x20\x02(\x0b2\x1e.gauge.messages.ProtoS\
    tepValueR\x0coldStepValue\x12B\n\x0cnewStepValue\x18\x02\x20\x02(\x0b2\
    \x1e.gauge.messages.ProtoStepValueR\x0cnewStepValue\x12I\n\x0eparamPosit\
    ions\x18\x03\x20\x03(\x0b2!.gauge.messages.ParameterPositionR\x0eparamPo\
    sitions\"f\n\x10RefactorResponse\x12\x18\n\x07success\x18\x01\x20\x02(\
    \x08R\x07success\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05error\x12\"\n\
    \x0cfilesChanged\x18\x03\x20\x03(\tR\x0cfilesChanged\"/\n\x0fStepNameReq\
    uest\x12\x1c\n\tstepValue\x18\x01\x20\x02(\tR\tstepValue\"p\n\x10StepNam\
    eResponse\x12$\n\risStepPresent\x18\x01\x20\x02(\x08R\risStepPresent\x12\
    \x1a\n\x08stepName\x18\x02\x20\x03(\tR\x08stepName\x12\x1a\n\x08hasAlias\
    \x18\x03\x20\x02(\x08R\x08hasAlias\"6\n\x1aUnsupportedMessageResponse\
    \x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"\xda\x17\n\x07Mess\
    age\x12E\n\x0bmessageType\x18\x01\x20\x02(\x0e2#.gauge.messages.Message.\
    MessageTypeR\x0bmessageType\x12\x1c\n\tmessageId\x18\x02\x20\x02(\x03R\t\
    messageId\x12d\n\x18executionStartingRequest\x18\x03\x20\x01(\x0b2(.gaug\
    e.messages.ExecutionStartingRequestR\x18executionStartingRequest\x12p\n\
    \x1cspecExecutionStartingRequest\x18\x04\x20\x01(\x0b2,.gauge.messages.S\
    pecExecutionStartingRequestR\x1cspecExecutionStartingRequest\x12j\n\x1as\
    pecExecutionEndingRequest\x18\x05\x20\x01(\x0b2*.gauge.messages.SpecExec\
    utionEndingRequestR\x1aspecExecutionEndingRequest\x12|\n\x20scenarioExec\
    utionStartingRequest\x18\x06\x20\x01(\x0b20.gauge.messages.ScenarioExecu\
    tionStartingRequestR\x20scenarioExecutionStartingRequest\x12v\n\x1escena\
    rioExecutionEndingRequest\x18\x07\x20\x01(\x0b2..gauge.messages.Scenario\
    ExecutionEndingRequestR\x1escenarioExecutionEndingRequest\x12p\n\x1cstep\
    ExecutionStartingRequest\x18\x08\x20\x01(\x0b2,.gauge.messages.StepExecu\
    tionStartingRequestR\x1cstepExecutionStartingRequest\x12j\n\x1astepExecu\
    tionEndingRequest\x18\t\x20\x01(\x0b2*.gauge.messages.StepExecutionEndin\
    gRequestR\x1astepExecutionEndingRequest\x12R\n\x12executeStepRequest\x18\
    \n\x20\x01(\x0b2\".gauge.messages.ExecuteStepRequestR\x12executeStepRequ\
    est\x12^\n\x16executionEndingRequest\x18\x0b\x20\x01(\x0b2&.gauge.messag\
    es.ExecutionEndingRequestR\x16executionEndingRequest\x12U\n\x13stepValid\
    ateRequest\x18\x0c\x20\x01(\x0b2#.gauge.messages.StepValidateRequestR\
    \x13stepValidateRequest\x12X\n\x14stepValidateResponse\x18\r\x20\x01(\
    \x0b2$.gauge.messages.StepValidateResponseR\x14stepValidateResponse\x12a\
    \n\x17executionStatusResponse\x18\x0e\x20\x01(\x0b2'.gauge.messages.Exec\
    utionStatusResponseR\x17executionStatusResponse\x12L\n\x10stepNamesReque\
    st\x18\x0f\x20\x01(\x0b2\x20.gauge.messages.StepNamesRequestR\x10stepNam\
    esRequest\x12O\n\x11stepNamesResponse\x18\x10\x20\x01(\x0b2!.gauge.messa\
    ges.StepNamesResponseR\x11stepNamesResponse\x12X\n\x14suiteExecutionResu\
    lt\x18\x11\x20\x01(\x0b2$.gauge.messages.SuiteExecutionResultR\x14suiteE\
    xecutionResult\x12R\n\x12killProcessRequest\x18\x12\x20\x01(\x0b2\".gaug\
    e.messages.KillProcessRequestR\x12killProcessRequest\x12p\n\x1cscenarioD\
    ataStoreInitRequest\x18\x13\x20\x01(\x0b2,.gauge.messages.ScenarioDataSt\
    oreInitRequestR\x1cscenarioDataStoreInitRequest\x12d\n\x18specDataStoreI\
    nitRequest\x18\x14\x20\x01(\x0b2(.gauge.messages.SpecDataStoreInitReques\
    tR\x18specDataStoreInitRequest\x12g\n\x19suiteDataStoreInitRequest\x18\
    \x15\x20\x01(\x0b2).gauge.messages.SuiteDataStoreInitRequestR\x19suiteDa\
    taStoreInitRequest\x12I\n\x0fstepNameRequest\x18\x16\x20\x01(\x0b2\x1f.g\
    auge.messages.StepNameRequestR\x0fstepNameRequest\x12L\n\x10stepNameResp\
    onse\x18\x17\x20\x01(\x0b2\x20.gauge.messages.StepNameResponseR\x10stepN\
    ameResponse\x12I\n\x0frefactorRequest\x18\x18\x20\x01(\x0b2\x1f.gauge.me\
    ssages.RefactorRequestR\x0frefactorRequest\x12L\n\x10refactorResponse\
    \x18\x19\x20\x01(\x0b2\x20.gauge.messages.RefactorResponseR\x10refactorR\
    esponse\x12j\n\x1aunsupportedMessageResponse\x18\x1a\x20\x01(\x0b2*.gaug\
    e.messages.UnsupportedMessageResponseR\x1aunsupportedMessageResponse\"\
    \xdd\x04\n\x0bMessageType\x12\x15\n\x11ExecutionStarting\x10\0\x12\x19\n\
    \x15SpecExecutionStarting\x10\x01\x12\x17\n\x13SpecExecutionEnding\x10\
    \x02\x12\x1d\n\x19ScenarioExecutionStarting\x10\x03\x12\x1b\n\x17Scenari\
    oExecutionEnding\x10\x04\x12\x19\n\x15StepExecutionStarting\x10\x05\x12\
    \x17\n\x13StepExecutionEnding\x10\x06\x12\x0f\n\x0bExecuteStep\x10\x07\
    \x12\x13\n\x0fExecutionEnding\x10\x08\x12\x17\n\x13StepValidateRequest\
    \x10\t\x12\x18\n\x14StepValidateResponse\x10\n\x12\x1b\n\x17ExecutionSta\
    tusResponse\x10\x0b\x12\x14\n\x10StepNamesRequest\x10\x0c\x12\x15\n\x11S\
    tepNamesResponse\x10\r\x12\x16\n\x12KillProcessRequest\x10\x0e\x12\x18\n\
    \x14SuiteExecutionResult\x10\x0f\x12\x19\n\x15ScenarioDataStoreInit\x10\
    \x10\x12\x15\n\x11SpecDataStoreInit\x10\x11\x12\x16\n\x12SuiteDataStoreI\
    nit\x10\x12\x12\x13\n\x0fStepNameRequest\x10\x13\x12\x14\n\x10StepNameRe\
    sponse\x10\x14\x12\x13\n\x0fRefactorRequest\x10\x15\x12\x14\n\x10Refacto\
    rResponse\x10\x16\x12\x1e\n\x1aUnsupportedMessageResponse\x10\x17J\xcbp\
    \n\x07\x12\x05\x13\0\xbf\x02\x01\n\xa5\x06\n\x01\x0c\x12\x03\x13\0\x12\
    \x1a_\x20The\x20comments\x20are\x20exported\x20to\x20Markdown,\x20hence\
    \x20they\x20may\x20contain\x20markdown\x20syntax\x20and\x20cross-refs.\n\
    2#\x20Copyright\x202015\x20ThoughtWorks,\x20Inc.\n2#\x20This\x20file\x20\
    is\x20part\x20of\x20gauge-proto.\n2\xf3\x01\x20gauge-proto\x20is\x20free\
    \x20software:\x20you\x20can\x20redistribute\x20it\x20and/or\x20modify\n\
    \x20it\x20under\x20the\x20terms\x20of\x20the\x20GNU\x20General\x20Public\
    \x20License\x20as\x20published\x20by\n\x20the\x20Free\x20Software\x20Fou\
    ndation,\x20either\x20version\x203\x20of\x20the\x20License,\x20or\n\x20(\
    at\x20your\x20option)\x20any\x20later\x20version.\n2\xed\x01\x20gauge-pr\
    oto\x20is\x20distributed\x20in\x20the\x20hope\x20that\x20it\x20will\x20b\
    e\x20useful,\n\x20but\x20WITHOUT\x20ANY\x20WARRANTY;\x20without\x20even\
    \x20the\x20implied\x20warranty\x20of\n\x20MERCHANTABILITY\x20or\x20FITNE\
    SS\x20FOR\x20A\x20PARTICULAR\x20PURPOSE.\x20\x20See\x20the\n\x20GNU\x20G\
    eneral\x20Public\x20License\x20for\x20more\x20details.\n2\x89\x01\x20You\
    \x20should\x20have\x20received\x20a\x20copy\x20of\x20the\x20GNU\x20Gener\
    al\x20Public\x20License\n\x20along\x20with\x20gauge-proto.\x20\x20If\x20\
    not,\x20see\x20<http://www.gnu.org/licenses/>.\n\n\x08\n\x01\x02\x12\x03\
    \x14\0\x17\n\t\n\x02\x03\0\x12\x03\x16\0\x14\n=\n\x02\x04\0\x12\x04\x19\
    \0\x1a\x01\x1a1/\x20Default\x20request.\x20Tells\x20the\x20runner\x20to\
    \x20shutdown.\n\n\n\n\x03\x04\0\x01\x12\x03\x19\x08\x1a\n\x83\x01\n\x02\
    \x04\x01\x12\x04\x1e\0\x20\x01\x1aw/\x20Sends\x20to\x20any\x20request\
    \x20which\x20needs\x20a\x20execution\x20status\x20as\x20response\n/\x20u\
    sually\x20step\x20execution,\x20hooks\x20etc\x20will\x20return\x20this\n\
    \n\n\n\x03\x04\x01\x01\x12\x03\x1e\x08\x1f\n\x0b\n\x04\x04\x01\x02\0\x12\
    \x03\x1f\x02C\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x1f\x02\n\n\x0c\n\
    \x05\x04\x01\x02\0\x06\x12\x03\x1f\x0b.\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03\x1f/>\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x1fAB\na\n\x02\x04\
    \x02\x12\x04#\0%\x01\x1aU/\x20Sent\x20at\x20start\x20of\x20Suite\x20Exec\
    ution.\x20Tells\x20the\x20runner\x20to\x20execute\x20`before_suite`\x20h\
    ook.\n\n\n\n\x03\x04\x02\x01\x12\x03#\x08\x20\n\x0b\n\x04\x04\x02\x02\0\
    \x12\x03$\x044\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03$\x04\x0c\n\x0c\n\
    \x05\x04\x02\x02\0\x06\x12\x03$\r\x1a\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x03$\x1b/\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03$23\n^\n\x02\x04\x03\x12\
    \x04(\0*\x01\x1aR/\x20Sent\x20at\x20end\x20of\x20Suite\x20Execution.\x20\
    Tells\x20the\x20runner\x20to\x20execute\x20`after_suite`\x20hook.\n\n\n\
    \n\x03\x04\x03\x01\x12\x03(\x08\x1e\n\x0b\n\x04\x04\x03\x02\0\x12\x03)\
    \x044\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03)\x04\x0c\n\x0c\n\x05\x04\x03\
    \x02\0\x06\x12\x03)\r\x1a\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03)\x1b/\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x03)23\n_\n\x02\x04\x04\x12\x04-\0/\x01\
    \x1aS/\x20Sent\x20at\x20start\x20of\x20Spec\x20Execution.\x20Tells\x20th\
    e\x20runner\x20to\x20execute\x20`before_spec`\x20hook.\n\n\n\n\x03\x04\
    \x04\x01\x12\x03-\x08$\n\x0b\n\x04\x04\x04\x02\0\x12\x03.\x044\n\x0c\n\
    \x05\x04\x04\x02\0\x04\x12\x03.\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x06\
    \x12\x03.\r\x1a\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03.\x1b/\n\x0c\n\x05\
    \x04\x04\x02\0\x03\x12\x03.23\n\\\n\x02\x04\x05\x12\x042\04\x01\x1aP/\
    \x20Sent\x20at\x20end\x20of\x20Spec\x20Execution.\x20Tells\x20the\x20run\
    ner\x20to\x20execute\x20`after_spec`\x20hook.\n\n\n\n\x03\x04\x05\x01\
    \x12\x032\x08\"\n\x0b\n\x04\x04\x05\x02\0\x12\x033\x044\n\x0c\n\x05\x04\
    \x05\x02\0\x04\x12\x033\x04\x0c\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x033\r\
    \x1a\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x033\x1b/\n\x0c\n\x05\x04\x05\x02\
    \0\x03\x12\x03323\ng\n\x02\x04\x06\x12\x047\09\x01\x1a[/\x20Sent\x20at\
    \x20start\x20of\x20Scenario\x20Execution.\x20Tells\x20the\x20runner\x20t\
    o\x20execute\x20`before_scenario`\x20hook.\n\n\n\n\x03\x04\x06\x01\x12\
    \x037\x08(\n\x0b\n\x04\x04\x06\x02\0\x12\x038\x044\n\x0c\n\x05\x04\x06\
    \x02\0\x04\x12\x038\x04\x0c\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x038\r\x1a\
    \n\x0c\n\x05\x04\x06\x02\0\x01\x12\x038\x1b/\n\x0c\n\x05\x04\x06\x02\0\
    \x03\x12\x03823\nd\n\x02\x04\x07\x12\x04<\0>\x01\x1aX/\x20Sent\x20at\x20\
    end\x20of\x20Scenario\x20Execution.\x20Tells\x20the\x20runner\x20to\x20e\
    xecute\x20`after_scenario`\x20hook.\n\n\n\n\x03\x04\x07\x01\x12\x03<\x08\
    &\n\x0b\n\x04\x04\x07\x02\0\x12\x03=\x044\n\x0c\n\x05\x04\x07\x02\0\x04\
    \x12\x03=\x04\x0c\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03=\r\x1a\n\x0c\n\
    \x05\x04\x07\x02\0\x01\x12\x03=\x1b/\n\x0c\n\x05\x04\x07\x02\0\x03\x12\
    \x03=23\n_\n\x02\x04\x08\x12\x04A\0C\x01\x1aS/\x20Sent\x20at\x20start\
    \x20of\x20Step\x20Execution.\x20Tells\x20the\x20runner\x20to\x20execute\
    \x20`before_step`\x20hook.\n\n\n\n\x03\x04\x08\x01\x12\x03A\x08$\n\x0b\n\
    \x04\x04\x08\x02\0\x12\x03B\x044\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03B\
    \x04\x0c\n\x0c\n\x05\x04\x08\x02\0\x06\x12\x03B\r\x1a\n\x0c\n\x05\x04\
    \x08\x02\0\x01\x12\x03B\x1b/\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03B23\n\
    \\\n\x02\x04\t\x12\x04F\0H\x01\x1aP/\x20Sent\x20at\x20end\x20of\x20Step\
    \x20Execution.\x20Tells\x20the\x20runner\x20to\x20execute\x20`after_step\
    `\x20hook.\n\n\n\n\x03\x04\t\x01\x12\x03F\x08\"\n\x0b\n\x04\x04\t\x02\0\
    \x12\x03G\x044\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03G\x04\x0c\n\x0c\n\x05\
    \x04\t\x02\0\x06\x12\x03G\r\x1a\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03G\x1b\
    /\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03G23\n\x8e\x01\n\x02\x04\n\x12\x04L\
    \0U\x01\x1a\x81\x01/\x20Contains\x20details\x20of\x20the\x20execution.\
    \x20\n/\x20Depending\x20on\x20the\x20context\x20(Step,\x20Scenario,\x20S\
    pec\x20or\x20Suite),\x20the\x20respective\x20fields\x20are\x20set.\n\n\n\
    \n\x03\x04\n\x01\x12\x03L\x08\x15\n^\n\x04\x04\n\x02\0\x12\x03N\x04&\x1a\
    Q/\x20Holds\x20the\x20information\x20of\x20the\x20current\x20Spec.\x20Va\
    lid\x20in\x20context\x20of\x20Spec\x20execution.\n\n\x0c\n\x05\x04\n\x02\
    \0\x04\x12\x03N\x04\x0c\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03N\r\x15\n\x0c\
    \n\x05\x04\n\x02\0\x01\x12\x03N\x16!\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03\
    N$%\nf\n\x04\x04\n\x02\x01\x12\x03P\x04.\x1aY/\x20Holds\x20the\x20inform\
    ation\x20of\x20the\x20current\x20Scenario.\x20Valid\x20in\x20context\x20\
    of\x20Scenario\x20execution.\n\n\x0c\n\x05\x04\n\x02\x01\x04\x12\x03P\
    \x04\x0c\n\x0c\n\x05\x04\n\x02\x01\x06\x12\x03P\r\x19\n\x0c\n\x05\x04\n\
    \x02\x01\x01\x12\x03P\x1a)\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03P,-\n^\n\
    \x04\x04\n\x02\x02\x12\x03R\x04&\x1aQ/\x20Holds\x20the\x20information\
    \x20of\x20the\x20current\x20Step.\x20Valid\x20in\x20context\x20of\x20Ste\
    p\x20execution.\n\n\x0c\n\x05\x04\n\x02\x02\x04\x12\x03R\x04\x0c\n\x0c\n\
    \x05\x04\n\x02\x02\x06\x12\x03R\r\x15\n\x0c\n\x05\x04\n\x02\x02\x01\x12\
    \x03R\x16!\n\x0c\n\x05\x04\n\x02\x02\x03\x12\x03R$%\nZ\n\x04\x04\n\x02\
    \x03\x12\x03T\x04#\x1aM/\x20Stacktrace\x20of\x20the\x20execution.\x20Val\
    id\x20only\x20if\x20there\x20is\x20an\x20error\x20in\x20execution.\n\n\
    \x0c\n\x05\x04\n\x02\x03\x04\x12\x03T\x04\x0c\n\x0c\n\x05\x04\n\x02\x03\
    \x05\x12\x03T\r\x13\n\x0c\n\x05\x04\n\x02\x03\x01\x12\x03T\x14\x1e\n\x0c\
    \n\x05\x04\n\x02\x03\x03\x12\x03T!\"\n6\n\x02\x04\x0b\x12\x04X\0a\x01\
    \x1a*/\x20Contains\x20details\x20of\x20the\x20Spec\x20execution.\n\n\n\n\
    \x03\x04\x0b\x01\x12\x03X\x08\x10\n8\n\x04\x04\x0b\x02\0\x12\x03Z\x04\
    \x1d\x1a+/\x20Name\x20of\x20the\x20current\x20Spec\x20being\x20executed.\
    \n\n\x0c\n\x05\x04\x0b\x02\0\x04\x12\x03Z\x04\x0c\n\x0c\n\x05\x04\x0b\
    \x02\0\x05\x12\x03Z\r\x13\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03Z\x14\x18\
    \n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03Z\x1b\x1c\nJ\n\x04\x04\x0b\x02\x01\
    \x12\x03\\\x04!\x1a=/\x20Full\x20File\x20path\x20containing\x20the\x20cu\
    rrent\x20Spec\x20being\x20executed.\n\n\x0c\n\x05\x04\x0b\x02\x01\x04\
    \x12\x03\\\x04\x0c\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03\\\r\x13\n\x0c\
    \n\x05\x04\x0b\x02\x01\x01\x12\x03\\\x14\x1c\n\x0c\n\x05\x04\x0b\x02\x01\
    \x03\x12\x03\\\x1f\x20\nF\n\x04\x04\x0b\x02\x02\x12\x03^\x04\x1f\x1a9/\
    \x20Flag\x20to\x20indicate\x20if\x20the\x20current\x20Spec\x20execution\
    \x20failed.\n\n\x0c\n\x05\x04\x0b\x02\x02\x04\x12\x03^\x04\x0c\n\x0c\n\
    \x05\x04\x0b\x02\x02\x05\x12\x03^\r\x11\n\x0c\n\x05\x04\x0b\x02\x02\x01\
    \x12\x03^\x12\x1a\n\x0c\n\x05\x04\x0b\x02\x02\x03\x12\x03^\x1d\x1e\n<\n\
    \x04\x04\x0b\x02\x03\x12\x03`\x04\x1e\x1a//\x20Tags\x20relevant\x20to\
    \x20the\x20current\x20Spec\x20execution.\n\n\x0c\n\x05\x04\x0b\x02\x03\
    \x04\x12\x03`\x04\x0c\n\x0c\n\x05\x04\x0b\x02\x03\x05\x12\x03`\r\x13\n\
    \x0c\n\x05\x04\x0b\x02\x03\x01\x12\x03`\x15\x19\n\x0c\n\x05\x04\x0b\x02\
    \x03\x03\x12\x03`\x1c\x1d\n:\n\x02\x04\x0c\x12\x04d\0k\x01\x1a./\x20Cont\
    ains\x20details\x20of\x20the\x20Scenario\x20execution.\n\n\n\n\x03\x04\
    \x0c\x01\x12\x03d\x08\x14\n<\n\x04\x04\x0c\x02\0\x12\x03f\x04\x1d\x1a//\
    \x20Name\x20of\x20the\x20current\x20Scenario\x20being\x20executed.\n\n\
    \x0c\n\x05\x04\x0c\x02\0\x04\x12\x03f\x04\x0c\n\x0c\n\x05\x04\x0c\x02\0\
    \x05\x12\x03f\r\x13\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03f\x14\x18\n\x0c\
    \n\x05\x04\x0c\x02\0\x03\x12\x03f\x1b\x1c\nJ\n\x04\x04\x0c\x02\x01\x12\
    \x03h\x04\x1f\x1a=/\x20Flag\x20to\x20indicate\x20if\x20the\x20current\
    \x20Scenario\x20execution\x20failed.\n\n\x0c\n\x05\x04\x0c\x02\x01\x04\
    \x12\x03h\x04\x0c\n\x0c\n\x05\x04\x0c\x02\x01\x05\x12\x03h\r\x11\n\x0c\n\
    \x05\x04\x0c\x02\x01\x01\x12\x03h\x12\x1a\n\x0c\n\x05\x04\x0c\x02\x01\
    \x03\x12\x03h\x1d\x1e\n@\n\x04\x04\x0c\x02\x02\x12\x03j\x04\x1e\x1a3/\
    \x20Tags\x20relevant\x20to\x20the\x20current\x20Scenario\x20execution.\n\
    \n\x0c\n\x05\x04\x0c\x02\x02\x04\x12\x03j\x04\x0c\n\x0c\n\x05\x04\x0c\
    \x02\x02\x05\x12\x03j\r\x13\n\x0c\n\x05\x04\x0c\x02\x02\x01\x12\x03j\x15\
    \x19\n\x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03j\x1c\x1d\n6\n\x02\x04\r\x12\
    \x04n\0s\x01\x1a*/\x20Contains\x20details\x20of\x20the\x20Step\x20execut\
    ion.\n\n\n\n\x03\x04\r\x01\x12\x03n\x08\x10\n3\n\x04\x04\r\x02\0\x12\x03\
    p\x04)\x1a&/\x20The\x20current\x20request\x20to\x20execute\x20Step\n\n\
    \x0c\n\x05\x04\r\x02\0\x04\x12\x03p\x04\x0c\n\x0c\n\x05\x04\r\x02\0\x06\
    \x12\x03p\r\x1f\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03p\x20$\n\x0c\n\x05\
    \x04\r\x02\0\x03\x12\x03p'(\nF\n\x04\x04\r\x02\x01\x12\x03r\x04\x1f\x1a9\
    /\x20Flag\x20to\x20indicate\x20if\x20the\x20current\x20Step\x20execution\
    \x20failed.\n\n\x0c\n\x05\x04\r\x02\x01\x04\x12\x03r\x04\x0c\n\x0c\n\x05\
    \x04\r\x02\x01\x05\x12\x03r\r\x11\n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03r\
    \x12\x1a\n\x0c\n\x05\x04\r\x02\x01\x03\x12\x03r\x1d\x1e\n<\n\x02\x04\x0e\
    \x12\x05v\0\x81\x01\x01\x1a//\x20Request\x20sent\x20ot\x20the\x20runner\
    \x20to\x20Execute\x20a\x20Step\n\n\n\n\x03\x04\x0e\x01\x12\x03v\x08\x1a\
    \n|\n\x04\x04\x0e\x02\0\x12\x03y\x02%\x1ao/\x20Contains\x20the\x20actual\
    \x20text\x20of\x20the\x20Step\x20being\x20executed.\x20\n/\x20This\x20co\
    ntains\x20the\x20parameters\x20as\x20defined\x20in\x20the\x20Spec.\n\n\
    \x0c\n\x05\x04\x0e\x02\0\x04\x12\x03y\x02\n\n\x0c\n\x05\x04\x0e\x02\0\
    \x05\x12\x03y\x0b\x11\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03y\x12\x20\n\
    \x0c\n\x05\x04\x0e\x02\0\x03\x12\x03y#$\nu\n\x04\x04\x0e\x02\x01\x12\x03\
    |\x02%\x1ah/\x20Contains\x20the\x20parsed\x20text\x20of\x20the\x20Step\
    \x20being\x20executed.\x20\n/\x20The\x20paramters\x20are\x20replaced\x20\
    with\x20placeholders.\n\n\x0c\n\x05\x04\x0e\x02\x01\x04\x12\x03|\x02\n\n\
    \x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03|\x0b\x11\n\x0c\n\x05\x04\x0e\x02\
    \x01\x01\x12\x03|\x12\x20\n\x0c\n\x05\x04\x0e\x02\x01\x03\x12\x03|#$\ng\
    \n\x04\x04\x0e\x02\x02\x12\x03~\x02$\x1aZ/\x20Flag\x20to\x20indicate\x20\
    if\x20the\x20execution\x20of\x20the\x20Scenario,\x20containing\x20the\
    \x20current\x20Step,\x20failed.\n\n\x0c\n\x05\x04\x0e\x02\x02\x04\x12\
    \x03~\x02\n\n\x0c\n\x05\x04\x0e\x02\x02\x05\x12\x03~\x0b\x0f\n\x0c\n\x05\
    \x04\x0e\x02\x02\x01\x12\x03~\x10\x1f\n\x0c\n\x05\x04\x0e\x02\x02\x03\
    \x12\x03~\"#\nI\n\x04\x04\x0e\x02\x03\x12\x04\x80\x01\x023\x1a;/\x20Coll\
    ection\x20of\x20parameters\x20applicable\x20to\x20the\x20current\x20Step\
    .\n\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\x80\x01\x02\n\n\r\n\x05\x04\
    \x0e\x02\x03\x06\x12\x04\x80\x01\x0b#\n\r\n\x05\x04\x0e\x02\x03\x01\x12\
    \x04\x80\x01$.\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\x80\x0112\n\xa7\x01\
    \n\x02\x04\x0f\x12\x06\x85\x01\0\x8a\x01\x01\x1a\x98\x01/\x20Request\x20\
    sent\x20ot\x20the\x20runner\x20to\x20check\x20if\x20given\x20Step\x20is\
    \x20valid.\x20\n/\x20The\x20runner\x20should\x20check\x20if\x20there\x20\
    is\x20an\x20implementation\x20defined\x20for\x20the\x20given\x20Step\x20\
    Text.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\x85\x01\x08\x1b\n?\n\x04\x04\x0f\
    \x02\0\x12\x04\x87\x01\x02\x1f\x1a1/\x20The\x20text\x20is\x20used\x20to\
    \x20lookup\x20Step\x20implementation\n\n\r\n\x05\x04\x0f\x02\0\x04\x12\
    \x04\x87\x01\x02\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x87\x01\x0b\x11\n\
    \r\n\x05\x04\x0f\x02\0\x01\x12\x04\x87\x01\x12\x1a\n\r\n\x05\x04\x0f\x02\
    \0\x03\x12\x04\x87\x01\x1d\x1e\n4\n\x04\x04\x0f\x02\x01\x12\x04\x89\x01\
    \x02(\x1a&/\x20The\x20number\x20of\x20paramters\x20in\x20the\x20Step\n\n\
    \r\n\x05\x04\x0f\x02\x01\x04\x12\x04\x89\x01\x02\n\n\r\n\x05\x04\x0f\x02\
    \x01\x05\x12\x04\x89\x01\x0b\x10\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\
    \x89\x01\x11#\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x89\x01&'\n\xd7\x01\
    \n\x02\x04\x10\x12\x06\x90\x01\0\x98\x01\x01\x1a\xc8\x01/\x20Response\
    \x20of\x20StepValidateRequest.\n/\x20The\x20runner\x20tells\x20the\x20ca\
    ller\x20if\x20the\x20Request\x20was\x20valid,\x20\n/\x20i.e.\x20an\x20im\
    plementation\x20exists\x20for\x20given\x20Step\x20text.\n/\x20Returns\
    \x20an\x20error\x20message\x20if\x20it\x20is\x20an\x20error\x20response.\
    \n\n\x0b\n\x03\x04\x10\x01\x12\x04\x90\x01\x08\x1c\n\x0e\n\x04\x04\x10\
    \x04\0\x12\x06\x91\x01\x04\x94\x01\x05\n\r\n\x05\x04\x10\x04\0\x01\x12\
    \x04\x91\x01\t\x12\n\x0e\n\x06\x04\x10\x04\0\x02\0\x12\x04\x92\x01\x08*\
    \n\x0f\n\x07\x04\x10\x04\0\x02\0\x01\x12\x04\x92\x01\x08%\n\x0f\n\x07\
    \x04\x10\x04\0\x02\0\x02\x12\x04\x92\x01()\n\x0e\n\x06\x04\x10\x04\0\x02\
    \x01\x12\x04\x93\x01\x08*\n\x0f\n\x07\x04\x10\x04\0\x02\x01\x01\x12\x04\
    \x93\x01\x08%\n\x0f\n\x07\x04\x10\x04\0\x02\x01\x02\x12\x04\x93\x01()\n\
    \x0c\n\x04\x04\x10\x02\0\x12\x04\x95\x01\x04\x1e\n\r\n\x05\x04\x10\x02\0\
    \x04\x12\x04\x95\x01\x04\x0c\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x95\x01\
    \r\x11\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x95\x01\x12\x19\n\r\n\x05\x04\
    \x10\x02\0\x03\x12\x04\x95\x01\x1c\x1d\n\x0c\n\x04\x04\x10\x02\x01\x12\
    \x04\x96\x01\x04%\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\x96\x01\x04\x0c\
    \n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\x96\x01\r\x13\n\r\n\x05\x04\x10\
    \x02\x01\x01\x12\x04\x96\x01\x14\x20\n\r\n\x05\x04\x10\x02\x01\x03\x12\
    \x04\x96\x01#$\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\x97\x01\x04%\n\r\n\
    \x05\x04\x10\x02\x02\x04\x12\x04\x97\x01\x04\x0c\n\r\n\x05\x04\x10\x02\
    \x02\x06\x12\x04\x97\x01\r\x16\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\x97\
    \x01\x17\x20\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\x97\x01#$\n/\n\x02\
    \x04\x11\x12\x06\x9b\x01\0\x9d\x01\x01\x1a!/\x20Result\x20of\x20the\x20S\
    uite\x20Execution.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\x9b\x01\x08\x1c\n\
    \x0c\n\x04\x04\x11\x02\0\x12\x04\x9c\x01\x04=\n\r\n\x05\x04\x11\x02\0\
    \x04\x12\x04\x9c\x01\x04\x0c\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\x9c\x01\
    \r,\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x9c\x01-8\n\r\n\x05\x04\x11\x02\
    \0\x03\x12\x04\x9c\x01;<\n7\n\x02\x04\x12\x12\x06\xa0\x01\0\xa1\x01\x01\
    \x1a)/\x20Requests\x20Gauge\x20to\x20give\x20all\x20Step\x20Names.\n\n\
    \x0b\n\x03\x04\x12\x01\x12\x04\xa0\x01\x08\x18\n-\n\x02\x04\x13\x12\x06\
    \xa5\x01\0\xa8\x01\x01\x1a\x1f/\x20Response\x20to\x20StepNamesRequest\n\
    \n\x0b\n\x03\x04\x13\x01\x12\x04\xa5\x01\x08\x19\nC\n\x04\x04\x13\x02\0\
    \x12\x04\xa7\x01\x04\x1e\x1a5/\x20Collection\x20of\x20strings\x20corresp\
    onding\x20to\x20Step\x20texts.\n\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xa7\
    \x01\x04\x0c\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xa7\x01\r\x13\n\r\n\x05\
    \x04\x13\x02\0\x01\x12\x04\xa7\x01\x14\x19\n\r\n\x05\x04\x13\x02\0\x03\
    \x12\x04\xa7\x01\x1c\x1d\n~\n\x02\x04\x14\x12\x06\xac\x01\0\xad\x01\x01\
    \x1ap/\x20Request\x20runner\x20to\x20initialize\x20Scenario\x20DataStore\
    \n/\x20Scenario\x20Datastore\x20is\x20reset\x20after\x20every\x20Scenari\
    o\x20execution.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\xac\x01\x08$\nr\n\x02\
    \x04\x15\x12\x06\xb1\x01\0\xb2\x01\x01\x1ad/\x20Request\x20runner\x20to\
    \x20initialize\x20Spec\x20DataStore\n/\x20Spec\x20Datastore\x20is\x20res\
    et\x20after\x20every\x20Spec\x20execution.\n\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\xb1\x01\x08\x20\nu\n\x02\x04\x16\x12\x06\xb6\x01\0\xb7\x01\x01\x1ag\
    /\x20Request\x20runner\x20to\x20initialize\x20Suite\x20DataStore\n/\x20S\
    uite\x20Datastore\x20is\x20reset\x20after\x20every\x20Suite\x20execution\
    .\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xb6\x01\x08!\n`\n\x02\x04\x17\x12\
    \x06\xbb\x01\0\xbe\x01\x01\x1aR/\x20Holds\x20the\x20new\x20and\x20old\
    \x20positions\x20of\x20a\x20parameter.\n/\x20Used\x20when\x20refactoring\
    \x20a\x20Step.\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xbb\x01\x08\x19\n\x0c\n\
    \x04\x04\x17\x02\0\x12\x04\xbc\x01\x02!\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04\xbc\x01\x02\n\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xbc\x01\x0b\x10\n\
    \r\n\x05\x04\x17\x02\0\x01\x12\x04\xbc\x01\x11\x1c\n\r\n\x05\x04\x17\x02\
    \0\x03\x12\x04\xbc\x01\x1f\x20\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xbd\
    \x01\x02!\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xbd\x01\x02\n\n\r\n\x05\
    \x04\x17\x02\x01\x05\x12\x04\xbd\x01\x0b\x10\n\r\n\x05\x04\x17\x02\x01\
    \x01\x12\x04\xbd\x01\x11\x1c\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xbd\
    \x01\x1f\x20\nA\n\x02\x04\x18\x12\x06\xc1\x01\0\xc8\x01\x01\x1a3/\x20Tel\
    ls\x20the\x20runner\x20to\x20refactor\x20the\x20specified\x20Step.\n\n\
    \x0b\n\x03\x04\x18\x01\x12\x04\xc1\x01\x08\x17\n;\n\x04\x04\x18\x02\0\
    \x12\x04\xc3\x01\x02:\x1a-/\x20Old\x20value,\x20used\x20to\x20lookup\x20\
    Step\x20to\x20refactor\n\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xc3\x01\x02\
    \n\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\xc3\x01\x0b(\n\r\n\x05\x04\x18\
    \x02\0\x01\x12\x04\xc3\x01)5\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xc3\x01\
    89\nE\n\x04\x04\x18\x02\x01\x12\x04\xc5\x01\x02:\x1a7/\x20New\x20value,\
    \x20the\x20to-be\x20value\x20of\x20Step\x20being\x20refactored.\n\n\r\n\
    \x05\x04\x18\x02\x01\x04\x12\x04\xc5\x01\x02\n\n\r\n\x05\x04\x18\x02\x01\
    \x06\x12\x04\xc5\x01\x0b(\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xc5\x01)\
    5\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xc5\x0189\ng\n\x04\x04\x18\x02\
    \x02\x12\x04\xc7\x01\x020\x1aY/\x20Holds\x20parameter\x20positions\x20of\
    \x20all\x20parameters.\x20Contains\x20old\x20and\x20new\x20parameter\x20\
    positions.\n\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\xc7\x01\x02\n\n\r\n\
    \x05\x04\x18\x02\x02\x06\x12\x04\xc7\x01\x0b\x1c\n\r\n\x05\x04\x18\x02\
    \x02\x01\x12\x04\xc7\x01\x1d+\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xc7\
    \x01./\n.\n\x02\x04\x19\x12\x06\xcb\x01\0\xd2\x01\x01\x1a\x20/\x20Respon\
    se\x20of\x20a\x20RefactorRequest\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xcb\
    \x01\x08\x18\nC\n\x04\x04\x19\x02\0\x12\x04\xcd\x01\x02\x1c\x1a5/\x20Fla\
    g\x20indicating\x20the\x20success\x20of\x20Refactor\x20operation.\n\n\r\
    \n\x05\x04\x19\x02\0\x04\x12\x04\xcd\x01\x02\n\n\r\n\x05\x04\x19\x02\0\
    \x05\x12\x04\xcd\x01\x0b\x0f\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xcd\x01\
    \x10\x17\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xcd\x01\x1a\x1b\nH\n\x04\
    \x04\x19\x02\x01\x12\x04\xcf\x01\x02\x1c\x1a:/\x20Error\x20message,\x20v\
    alid\x20only\x20if\x20Refactor\x20wasn't\x20successful\n\n\r\n\x05\x04\
    \x19\x02\x01\x04\x12\x04\xcf\x01\x02\n\n\r\n\x05\x04\x19\x02\x01\x05\x12\
    \x04\xcf\x01\x0b\x11\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xcf\x01\x12\
    \x17\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xcf\x01\x1a\x1b\nM\n\x04\x04\
    \x19\x02\x02\x12\x04\xd1\x01\x02#\x1a?/\x20List\x20of\x20files\x20that\
    \x20were\x20affected\x20because\x20of\x20the\x20refactoring.\n\n\r\n\x05\
    \x04\x19\x02\x02\x04\x12\x04\xd1\x01\x02\n\n\r\n\x05\x04\x19\x02\x02\x05\
    \x12\x04\xd1\x01\x0b\x11\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xd1\x01\
    \x12\x1e\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xd1\x01!\"\n6\n\x02\x04\
    \x1a\x12\x06\xd5\x01\0\xd9\x01\x01\x1a(/\x20Request\x20for\x20details\
    \x20on\x20a\x20Single\x20Step.\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\xd5\x01\
    \x08\x17\nw\n\x04\x04\x1a\x02\0\x12\x04\xd8\x01\x02\x20\x1ai/\x20Step\
    \x20text\x20to\x20lookup\x20the\x20Step.\x20\n/\x20This\x20is\x20the\x20\
    parsed\x20step\x20value,\x20i.e.\x20with\x20placeholders\x20for\x20param\
    eters.\n\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xd8\x01\x02\n\n\r\n\x05\x04\
    \x1a\x02\0\x05\x12\x04\xd8\x01\x0b\x11\n\r\n\x05\x04\x1a\x02\0\x01\x12\
    \x04\xd8\x01\x12\x1b\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xd8\x01\x1e\x1f\
    \n-\n\x02\x04\x1b\x12\x06\xdc\x01\0\xe3\x01\x01\x1a\x1f/\x20Response\x20\
    to\x20StepNameRequest.\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xdc\x01\x08\x18\
    \nM\n\x04\x04\x1b\x02\0\x12\x04\xde\x01\x02\"\x1a?/\x20Flag\x20indicatin\
    g\x20if\x20there\x20is\x20a\x20match\x20for\x20the\x20given\x20Step\x20T\
    ext.\n\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xde\x01\x02\n\n\r\n\x05\x04\
    \x1b\x02\0\x05\x12\x04\xde\x01\x0b\x0f\n\r\n\x05\x04\x1b\x02\0\x01\x12\
    \x04\xde\x01\x10\x1d\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xde\x01\x20!\n2\
    \n\x04\x04\x1b\x02\x01\x12\x04\xe0\x01\x02\x1f\x1a$/\x20The\x20Step\x20n\
    ame\x20of\x20the\x20given\x20step.\x20\n\n\r\n\x05\x04\x1b\x02\x01\x04\
    \x12\x04\xe0\x01\x02\n\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\xe0\x01\x0b\
    \x11\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xe0\x01\x12\x1a\n\r\n\x05\x04\
    \x1b\x02\x01\x03\x12\x04\xe0\x01\x1d\x1e\n?\n\x04\x04\x1b\x02\x02\x12\
    \x04\xe2\x01\x02\x1d\x1a1/\x20Flag\x20indicating\x20if\x20the\x20given\
    \x20Step\x20is\x20an\x20alias.\n\n\r\n\x05\x04\x1b\x02\x02\x04\x12\x04\
    \xe2\x01\x02\n\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\xe2\x01\x0b\x0f\n\r\
    \n\x05\x04\x1b\x02\x02\x01\x12\x04\xe2\x01\x10\x18\n\r\n\x05\x04\x1b\x02\
    \x02\x03\x12\x04\xe2\x01\x1b\x1c\nE\n\x02\x04\x1c\x12\x06\xe6\x01\0\xe8\
    \x01\x01\x1a7/\x20Response\x20when\x20a\x20unsupported\x20message\x20req\
    uest\x20is\x20sent.\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\xe6\x01\x08\"\n\
    \x0c\n\x04\x04\x1c\x02\0\x12\x04\xe7\x01\x04\x20\n\r\n\x05\x04\x1c\x02\0\
    \x04\x12\x04\xe7\x01\x04\x0c\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xe7\x01\
    \r\x13\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xe7\x01\x14\x1b\n\r\n\x05\x04\
    \x1c\x02\0\x03\x12\x04\xe7\x01\x1e\x1f\n\xc0\x01\n\x02\x04\x1d\x12\x06\
    \xed\x01\0\xbf\x02\x01\x1a\xb1\x01/\x20This\x20is\x20the\x20message\x20w\
    hich\x20gets\x20transferred\x20all\x20the\x20time\n/\x20with\x20proper\
    \x20message\x20type\x20set\n/\x20One\x20of\x20the\x20Request/Response\
    \x20fields\x20will\x20have\x20value,\x20depending\x20on\x20the\x20Messag\
    eType\x20set.\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xed\x01\x08\x0f\n\x0e\n\
    \x04\x04\x1d\x04\0\x12\x06\xee\x01\x02\x87\x02\x03\n\r\n\x05\x04\x1d\x04\
    \0\x01\x12\x04\xee\x01\x07\x12\n\x0e\n\x06\x04\x1d\x04\0\x02\0\x12\x04\
    \xef\x01\x06\x1c\n\x0f\n\x07\x04\x1d\x04\0\x02\0\x01\x12\x04\xef\x01\x06\
    \x17\n\x0f\n\x07\x04\x1d\x04\0\x02\0\x02\x12\x04\xef\x01\x1a\x1b\n\x0e\n\
    \x06\x04\x1d\x04\0\x02\x01\x12\x04\xf0\x01\x06\x20\n\x0f\n\x07\x04\x1d\
    \x04\0\x02\x01\x01\x12\x04\xf0\x01\x06\x1b\n\x0f\n\x07\x04\x1d\x04\0\x02\
    \x01\x02\x12\x04\xf0\x01\x1e\x1f\n\x0e\n\x06\x04\x1d\x04\0\x02\x02\x12\
    \x04\xf1\x01\x06\x1e\n\x0f\n\x07\x04\x1d\x04\0\x02\x02\x01\x12\x04\xf1\
    \x01\x06\x19\n\x0f\n\x07\x04\x1d\x04\0\x02\x02\x02\x12\x04\xf1\x01\x1c\
    \x1d\n\x0e\n\x06\x04\x1d\x04\0\x02\x03\x12\x04\xf2\x01\x06$\n\x0f\n\x07\
    \x04\x1d\x04\0\x02\x03\x01\x12\x04\xf2\x01\x06\x1f\n\x0f\n\x07\x04\x1d\
    \x04\0\x02\x03\x02\x12\x04\xf2\x01\"#\n\x0e\n\x06\x04\x1d\x04\0\x02\x04\
    \x12\x04\xf3\x01\x06\"\n\x0f\n\x07\x04\x1d\x04\0\x02\x04\x01\x12\x04\xf3\
    \x01\x06\x1d\n\x0f\n\x07\x04\x1d\x04\0\x02\x04\x02\x12\x04\xf3\x01\x20!\
    \n\x0e\n\x06\x04\x1d\x04\0\x02\x05\x12\x04\xf4\x01\x06\x20\n\x0f\n\x07\
    \x04\x1d\x04\0\x02\x05\x01\x12\x04\xf4\x01\x06\x1b\n\x0f\n\x07\x04\x1d\
    \x04\0\x02\x05\x02\x12\x04\xf4\x01\x1e\x1f\n\x0e\n\x06\x04\x1d\x04\0\x02\
    \x06\x12\x04\xf5\x01\x06\x1e\n\x0f\n\x07\x04\x1d\x04\0\x02\x06\x01\x12\
    \x04\xf5\x01\x06\x19\n\x0f\n\x07\x04\x1d\x04\0\x02\x06\x02\x12\x04\xf5\
    \x01\x1c\x1d\n\x0e\n\x06\x04\x1d\x04\0\x02\x07\x12\x04\xf6\x01\x06\x16\n\
    \x0f\n\x07\x04\x1d\x04\0\x02\x07\x01\x12\x04\xf6\x01\x06\x11\n\x0f\n\x07\
    \x04\x1d\x04\0\x02\x07\x02\x12\x04\xf6\x01\x14\x15\n\x0e\n\x06\x04\x1d\
    \x04\0\x02\x08\x12\x04\xf7\x01\x06\x1a\n\x0f\n\x07\x04\x1d\x04\0\x02\x08\
    \x01\x12\x04\xf7\x01\x06\x15\n\x0f\n\x07\x04\x1d\x04\0\x02\x08\x02\x12\
    \x04\xf7\x01\x18\x19\n\x0e\n\x06\x04\x1d\x04\0\x02\t\x12\x04\xf8\x01\x06\
    \x1e\n\x0f\n\x07\x04\x1d\x04\0\x02\t\x01\x12\x04\xf8\x01\x06\x19\n\x0f\n\
    \x07\x04\x1d\x04\0\x02\t\x02\x12\x04\xf8\x01\x1c\x1d\n\x0e\n\x06\x04\x1d\
    \x04\0\x02\n\x12\x04\xf9\x01\x06\x20\n\x0f\n\x07\x04\x1d\x04\0\x02\n\x01\
    \x12\x04\xf9\x01\x06\x1a\n\x0f\n\x07\x04\x1d\x04\0\x02\n\x02\x12\x04\xf9\
    \x01\x1d\x1f\n\x0e\n\x06\x04\x1d\x04\0\x02\x0b\x12\x04\xfa\x01\x06#\n\
    \x0f\n\x07\x04\x1d\x04\0\x02\x0b\x01\x12\x04\xfa\x01\x06\x1d\n\x0f\n\x07\
    \x04\x1d\x04\0\x02\x0b\x02\x12\x04\xfa\x01\x20\"\n\x0e\n\x06\x04\x1d\x04\
    \0\x02\x0c\x12\x04\xfb\x01\x06\x1c\n\x0f\n\x07\x04\x1d\x04\0\x02\x0c\x01\
    \x12\x04\xfb\x01\x06\x16\n\x0f\n\x07\x04\x1d\x04\0\x02\x0c\x02\x12\x04\
    \xfb\x01\x19\x1b\n\x0e\n\x06\x04\x1d\x04\0\x02\r\x12\x04\xfc\x01\x06\x1d\
    \n\x0f\n\x07\x04\x1d\x04\0\x02\r\x01\x12\x04\xfc\x01\x06\x17\n\x0f\n\x07\
    \x04\x1d\x04\0\x02\r\x02\x12\x04\xfc\x01\x1a\x1c\n\x0e\n\x06\x04\x1d\x04\
    \0\x02\x0e\x12\x04\xfd\x01\x06\x1e\n\x0f\n\x07\x04\x1d\x04\0\x02\x0e\x01\
    \x12\x04\xfd\x01\x06\x18\n\x0f\n\x07\x04\x1d\x04\0\x02\x0e\x02\x12\x04\
    \xfd\x01\x1b\x1d\n\x0e\n\x06\x04\x1d\x04\0\x02\x0f\x12\x04\xfe\x01\x06\
    \x20\n\x0f\n\x07\x04\x1d\x04\0\x02\x0f\x01\x12\x04\xfe\x01\x06\x1a\n\x0f\
    \n\x07\x04\x1d\x04\0\x02\x0f\x02\x12\x04\xfe\x01\x1d\x1f\n\x0e\n\x06\x04\
    \x1d\x04\0\x02\x10\x12\x04\xff\x01\x06!\n\x0f\n\x07\x04\x1d\x04\0\x02\
    \x10\x01\x12\x04\xff\x01\x06\x1b\n\x0f\n\x07\x04\x1d\x04\0\x02\x10\x02\
    \x12\x04\xff\x01\x1e\x20\n\x0e\n\x06\x04\x1d\x04\0\x02\x11\x12\x04\x80\
    \x02\x06\x1d\n\x0f\n\x07\x04\x1d\x04\0\x02\x11\x01\x12\x04\x80\x02\x06\
    \x17\n\x0f\n\x07\x04\x1d\x04\0\x02\x11\x02\x12\x04\x80\x02\x1a\x1c\n\x0e\
    \n\x06\x04\x1d\x04\0\x02\x12\x12\x04\x81\x02\x06\x1e\n\x0f\n\x07\x04\x1d\
    \x04\0\x02\x12\x01\x12\x04\x81\x02\x06\x18\n\x0f\n\x07\x04\x1d\x04\0\x02\
    \x12\x02\x12\x04\x81\x02\x1b\x1d\n\x0e\n\x06\x04\x1d\x04\0\x02\x13\x12\
    \x04\x82\x02\x06\x1b\n\x0f\n\x07\x04\x1d\x04\0\x02\x13\x01\x12\x04\x82\
    \x02\x06\x15\n\x0f\n\x07\x04\x1d\x04\0\x02\x13\x02\x12\x04\x82\x02\x18\
    \x1a\n\x0e\n\x06\x04\x1d\x04\0\x02\x14\x12\x04\x83\x02\x06\x1c\n\x0f\n\
    \x07\x04\x1d\x04\0\x02\x14\x01\x12\x04\x83\x02\x06\x16\n\x0f\n\x07\x04\
    \x1d\x04\0\x02\x14\x02\x12\x04\x83\x02\x19\x1b\n\x0e\n\x06\x04\x1d\x04\0\
    \x02\x15\x12\x04\x84\x02\x06\x1b\n\x0f\n\x07\x04\x1d\x04\0\x02\x15\x01\
    \x12\x04\x84\x02\x06\x15\n\x0f\n\x07\x04\x1d\x04\0\x02\x15\x02\x12\x04\
    \x84\x02\x18\x1a\n\x0e\n\x06\x04\x1d\x04\0\x02\x16\x12\x04\x85\x02\x06\
    \x1c\n\x0f\n\x07\x04\x1d\x04\0\x02\x16\x01\x12\x04\x85\x02\x06\x16\n\x0f\
    \n\x07\x04\x1d\x04\0\x02\x16\x02\x12\x04\x85\x02\x19\x1b\n\x0e\n\x06\x04\
    \x1d\x04\0\x02\x17\x12\x04\x86\x02\x06&\n\x0f\n\x07\x04\x1d\x04\0\x02\
    \x17\x01\x12\x04\x86\x02\x06\x20\n\x0f\n\x07\x04\x1d\x04\0\x02\x17\x02\
    \x12\x04\x86\x02#%\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\x89\x02\x02'\n\r\n\
    \x05\x04\x1d\x02\0\x04\x12\x04\x89\x02\x02\n\n\r\n\x05\x04\x1d\x02\0\x06\
    \x12\x04\x89\x02\x0b\x16\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\x89\x02\x17\
    \"\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\x89\x02%&\n\xa2\x01\n\x04\x04\x1d\
    \x02\x01\x12\x04\x8d\x02\x02\x1f\x1a\x93\x01/\x20A\x20unique\x20id\x20to\
    \x20represent\x20this\x20message.\x20A\x20response\x20to\x20the\x20messa\
    ge\x20should\x20copy\x20over\x20this\x20value.\n/\x20This\x20is\x20used\
    \x20to\x20synchronize\x20messages\x20&\x20responses\n\n\r\n\x05\x04\x1d\
    \x02\x01\x04\x12\x04\x8d\x02\x02\n\n\r\n\x05\x04\x1d\x02\x01\x05\x12\x04\
    \x8d\x02\x0b\x10\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\x8d\x02\x11\x1a\n\
    \r\n\x05\x04\x1d\x02\x01\x03\x12\x04\x8d\x02\x1d\x1e\nU\n\x04\x04\x1d\
    \x02\x02\x12\x04\x90\x02\x02A\x1aG/\x20[ExecutionStartingRequest](#gauge\
    .messages.ExecutionStartingRequest)\n\n\r\n\x05\x04\x1d\x02\x02\x04\x12\
    \x04\x90\x02\x02\n\n\r\n\x05\x04\x1d\x02\x02\x06\x12\x04\x90\x02\x0b#\n\
    \r\n\x05\x04\x1d\x02\x02\x01\x12\x04\x90\x02$<\n\r\n\x05\x04\x1d\x02\x02\
    \x03\x12\x04\x90\x02?@\n]\n\x04\x04\x1d\x02\x03\x12\x04\x92\x02\x02I\x1a\
    O/\x20[SpecExecutionStartingRequest](#gauge.messages.SpecExecutionStarti\
    ngRequest)\n\n\r\n\x05\x04\x1d\x02\x03\x04\x12\x04\x92\x02\x02\n\n\r\n\
    \x05\x04\x1d\x02\x03\x06\x12\x04\x92\x02\x0b'\n\r\n\x05\x04\x1d\x02\x03\
    \x01\x12\x04\x92\x02(D\n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\x92\x02GH\n\
    Y\n\x04\x04\x1d\x02\x04\x12\x04\x94\x02\x02E\x1aK/\x20[SpecExecutionEndi\
    ngRequest](#gauge.messages.SpecExecutionEndingRequest)\n\n\r\n\x05\x04\
    \x1d\x02\x04\x04\x12\x04\x94\x02\x02\n\n\r\n\x05\x04\x1d\x02\x04\x06\x12\
    \x04\x94\x02\x0b%\n\r\n\x05\x04\x1d\x02\x04\x01\x12\x04\x94\x02&@\n\r\n\
    \x05\x04\x1d\x02\x04\x03\x12\x04\x94\x02CD\ne\n\x04\x04\x1d\x02\x05\x12\
    \x04\x96\x02\x02Q\x1aW/\x20[ScenarioExecutionStartingRequest](#gauge.mes\
    sages.ScenarioExecutionStartingRequest)\n\n\r\n\x05\x04\x1d\x02\x05\x04\
    \x12\x04\x96\x02\x02\n\n\r\n\x05\x04\x1d\x02\x05\x06\x12\x04\x96\x02\x0b\
    +\n\r\n\x05\x04\x1d\x02\x05\x01\x12\x04\x96\x02,L\n\r\n\x05\x04\x1d\x02\
    \x05\x03\x12\x04\x96\x02OP\na\n\x04\x04\x1d\x02\x06\x12\x04\x98\x02\x02M\
    \x1aS/\x20[ScenarioExecutionEndingRequest](#gauge.messages.ScenarioExecu\
    tionEndingRequest)\n\n\r\n\x05\x04\x1d\x02\x06\x04\x12\x04\x98\x02\x02\n\
    \n\r\n\x05\x04\x1d\x02\x06\x06\x12\x04\x98\x02\x0b)\n\r\n\x05\x04\x1d\
    \x02\x06\x01\x12\x04\x98\x02*H\n\r\n\x05\x04\x1d\x02\x06\x03\x12\x04\x98\
    \x02KL\n]\n\x04\x04\x1d\x02\x07\x12\x04\x9a\x02\x02I\x1aO/\x20[StepExecu\
    tionStartingRequest](#gauge.messages.StepExecutionStartingRequest)\n\n\r\
    \n\x05\x04\x1d\x02\x07\x04\x12\x04\x9a\x02\x02\n\n\r\n\x05\x04\x1d\x02\
    \x07\x06\x12\x04\x9a\x02\x0b'\n\r\n\x05\x04\x1d\x02\x07\x01\x12\x04\x9a\
    \x02(D\n\r\n\x05\x04\x1d\x02\x07\x03\x12\x04\x9a\x02GH\nY\n\x04\x04\x1d\
    \x02\x08\x12\x04\x9c\x02\x02E\x1aK/\x20[StepExecutionEndingRequest](#gau\
    ge.messages.StepExecutionEndingRequest)\n\n\r\n\x05\x04\x1d\x02\x08\x04\
    \x12\x04\x9c\x02\x02\n\n\r\n\x05\x04\x1d\x02\x08\x06\x12\x04\x9c\x02\x0b\
    %\n\r\n\x05\x04\x1d\x02\x08\x01\x12\x04\x9c\x02&@\n\r\n\x05\x04\x1d\x02\
    \x08\x03\x12\x04\x9c\x02CD\nI\n\x04\x04\x1d\x02\t\x12\x04\x9e\x02\x026\
    \x1a;/\x20[ExecuteStepRequest](#gauge.messages.ExecuteStepRequest)\n\n\r\
    \n\x05\x04\x1d\x02\t\x04\x12\x04\x9e\x02\x02\n\n\r\n\x05\x04\x1d\x02\t\
    \x06\x12\x04\x9e\x02\x0b\x1d\n\r\n\x05\x04\x1d\x02\t\x01\x12\x04\x9e\x02\
    \x1e0\n\r\n\x05\x04\x1d\x02\t\x03\x12\x04\x9e\x0235\nQ\n\x04\x04\x1d\x02\
    \n\x12\x04\xa0\x02\x02>\x1aC/\x20[ExecutionEndingRequest](#gauge.message\
    s.ExecutionEndingRequest)\n\n\r\n\x05\x04\x1d\x02\n\x04\x12\x04\xa0\x02\
    \x02\n\n\r\n\x05\x04\x1d\x02\n\x06\x12\x04\xa0\x02\x0b!\n\r\n\x05\x04\
    \x1d\x02\n\x01\x12\x04\xa0\x02\"8\n\r\n\x05\x04\x1d\x02\n\x03\x12\x04\
    \xa0\x02;=\nK\n\x04\x04\x1d\x02\x0b\x12\x04\xa2\x02\x028\x1a=/\x20[StepV\
    alidateRequest](#gauge.messages.StepValidateRequest)\n\n\r\n\x05\x04\x1d\
    \x02\x0b\x04\x12\x04\xa2\x02\x02\n\n\r\n\x05\x04\x1d\x02\x0b\x06\x12\x04\
    \xa2\x02\x0b\x1e\n\r\n\x05\x04\x1d\x02\x0b\x01\x12\x04\xa2\x02\x1f2\n\r\
    \n\x05\x04\x1d\x02\x0b\x03\x12\x04\xa2\x0257\nM\n\x04\x04\x1d\x02\x0c\
    \x12\x04\xa4\x02\x02:\x1a?/\x20[StepValidateResponse](#gauge.messages.St\
    epValidateResponse)\n\n\r\n\x05\x04\x1d\x02\x0c\x04\x12\x04\xa4\x02\x02\
    \n\n\r\n\x05\x04\x1d\x02\x0c\x06\x12\x04\xa4\x02\x0b\x1f\n\r\n\x05\x04\
    \x1d\x02\x0c\x01\x12\x04\xa4\x02\x204\n\r\n\x05\x04\x1d\x02\x0c\x03\x12\
    \x04\xa4\x0279\nS\n\x04\x04\x1d\x02\r\x12\x04\xa6\x02\x02@\x1aE/\x20[Exe\
    cutionStatusResponse](#gauge.messages.ExecutionStatusResponse)\n\n\r\n\
    \x05\x04\x1d\x02\r\x04\x12\x04\xa6\x02\x02\n\n\r\n\x05\x04\x1d\x02\r\x06\
    \x12\x04\xa6\x02\x0b\"\n\r\n\x05\x04\x1d\x02\r\x01\x12\x04\xa6\x02#:\n\r\
    \n\x05\x04\x1d\x02\r\x03\x12\x04\xa6\x02=?\nE\n\x04\x04\x1d\x02\x0e\x12\
    \x04\xa8\x02\x022\x1a7/\x20[StepNamesRequest](#gauge.messages.StepNamesR\
    equest)\n\n\r\n\x05\x04\x1d\x02\x0e\x04\x12\x04\xa8\x02\x02\n\n\r\n\x05\
    \x04\x1d\x02\x0e\x06\x12\x04\xa8\x02\x0b\x1b\n\r\n\x05\x04\x1d\x02\x0e\
    \x01\x12\x04\xa8\x02\x1c,\n\r\n\x05\x04\x1d\x02\x0e\x03\x12\x04\xa8\x02/\
    1\nG\n\x04\x04\x1d\x02\x0f\x12\x04\xaa\x02\x024\x1a9/\x20[StepNamesRespo\
    nse](#gauge.messages.StepNamesResponse)\n\n\r\n\x05\x04\x1d\x02\x0f\x04\
    \x12\x04\xaa\x02\x02\n\n\r\n\x05\x04\x1d\x02\x0f\x06\x12\x04\xaa\x02\x0b\
    \x1c\n\r\n\x05\x04\x1d\x02\x0f\x01\x12\x04\xaa\x02\x1d.\n\r\n\x05\x04\
    \x1d\x02\x0f\x03\x12\x04\xaa\x0213\nO\n\x04\x04\x1d\x02\x10\x12\x04\xac\
    \x02\x02:\x1aA/\x20[SuiteExecutionResult\x20](#gauge.messages.SuiteExecu\
    tionResult\x20)\n\n\r\n\x05\x04\x1d\x02\x10\x04\x12\x04\xac\x02\x02\n\n\
    \r\n\x05\x04\x1d\x02\x10\x06\x12\x04\xac\x02\x0b\x1f\n\r\n\x05\x04\x1d\
    \x02\x10\x01\x12\x04\xac\x02\x204\n\r\n\x05\x04\x1d\x02\x10\x03\x12\x04\
    \xac\x0279\nI\n\x04\x04\x1d\x02\x11\x12\x04\xae\x02\x026\x1a;/\x20[KillP\
    rocessRequest](#gauge.messages.KillProcessRequest)\n\n\r\n\x05\x04\x1d\
    \x02\x11\x04\x12\x04\xae\x02\x02\n\n\r\n\x05\x04\x1d\x02\x11\x06\x12\x04\
    \xae\x02\x0b\x1d\n\r\n\x05\x04\x1d\x02\x11\x01\x12\x04\xae\x02\x1e0\n\r\
    \n\x05\x04\x1d\x02\x11\x03\x12\x04\xae\x0235\n]\n\x04\x04\x1d\x02\x12\
    \x12\x04\xb0\x02\x02J\x1aO/\x20[ScenarioDataStoreInitRequest](#gauge.mes\
    sages.ScenarioDataStoreInitRequest)\n\n\r\n\x05\x04\x1d\x02\x12\x04\x12\
    \x04\xb0\x02\x02\n\n\r\n\x05\x04\x1d\x02\x12\x06\x12\x04\xb0\x02\x0b'\n\
    \r\n\x05\x04\x1d\x02\x12\x01\x12\x04\xb0\x02(D\n\r\n\x05\x04\x1d\x02\x12\
    \x03\x12\x04\xb0\x02GI\nU\n\x04\x04\x1d\x02\x13\x12\x04\xb2\x02\x02B\x1a\
    G/\x20[SpecDataStoreInitRequest](#gauge.messages.SpecDataStoreInitReques\
    t)\n\n\r\n\x05\x04\x1d\x02\x13\x04\x12\x04\xb2\x02\x02\n\n\r\n\x05\x04\
    \x1d\x02\x13\x06\x12\x04\xb2\x02\x0b#\n\r\n\x05\x04\x1d\x02\x13\x01\x12\
    \x04\xb2\x02$<\n\r\n\x05\x04\x1d\x02\x13\x03\x12\x04\xb2\x02?A\nW\n\x04\
    \x04\x1d\x02\x14\x12\x04\xb4\x02\x02D\x1aI/\x20[SuiteDataStoreInitReques\
    t](#gauge.messages.SuiteDataStoreInitRequest)\n\n\r\n\x05\x04\x1d\x02\
    \x14\x04\x12\x04\xb4\x02\x02\n\n\r\n\x05\x04\x1d\x02\x14\x06\x12\x04\xb4\
    \x02\x0b$\n\r\n\x05\x04\x1d\x02\x14\x01\x12\x04\xb4\x02%>\n\r\n\x05\x04\
    \x1d\x02\x14\x03\x12\x04\xb4\x02AC\nC\n\x04\x04\x1d\x02\x15\x12\x04\xb6\
    \x02\x02/\x1a5/\x20[StepNameRequest](#gauge.messages.StepNameRequest)\n\
    \n\r\n\x05\x04\x1d\x02\x15\x04\x12\x04\xb6\x02\x02\n\n\r\n\x05\x04\x1d\
    \x02\x15\x06\x12\x04\xb6\x02\x0b\x1a\n\r\n\x05\x04\x1d\x02\x15\x01\x12\
    \x04\xb6\x02\x1b*\n\r\n\x05\x04\x1d\x02\x15\x03\x12\x04\xb6\x02,.\nE\n\
    \x04\x04\x1d\x02\x16\x12\x04\xb8\x02\x021\x1a7/\x20[StepNameResponse](#g\
    auge.messages.StepNameResponse)\n\n\r\n\x05\x04\x1d\x02\x16\x04\x12\x04\
    \xb8\x02\x02\n\n\r\n\x05\x04\x1d\x02\x16\x06\x12\x04\xb8\x02\x0b\x1b\n\r\
    \n\x05\x04\x1d\x02\x16\x01\x12\x04\xb8\x02\x1c,\n\r\n\x05\x04\x1d\x02\
    \x16\x03\x12\x04\xb8\x02.0\nC\n\x04\x04\x1d\x02\x17\x12\x04\xba\x02\x020\
    \x1a5/\x20[RefactorRequest](#gauge.messages.RefactorRequest)\n\n\r\n\x05\
    \x04\x1d\x02\x17\x04\x12\x04\xba\x02\x02\n\n\r\n\x05\x04\x1d\x02\x17\x06\
    \x12\x04\xba\x02\x0b\x1a\n\r\n\x05\x04\x1d\x02\x17\x01\x12\x04\xba\x02\
    \x1b*\n\r\n\x05\x04\x1d\x02\x17\x03\x12\x04\xba\x02-/\nE\n\x04\x04\x1d\
    \x02\x18\x12\x04\xbc\x02\x022\x1a7/\x20[RefactorResponse](#gauge.message\
    s.RefactorResponse)\n\n\r\n\x05\x04\x1d\x02\x18\x04\x12\x04\xbc\x02\x02\
    \n\n\r\n\x05\x04\x1d\x02\x18\x06\x12\x04\xbc\x02\x0b\x1b\n\r\n\x05\x04\
    \x1d\x02\x18\x01\x12\x04\xbc\x02\x1c,\n\r\n\x05\x04\x1d\x02\x18\x03\x12\
    \x04\xbc\x02/1\nY\n\x04\x04\x1d\x02\x19\x12\x04\xbe\x02\x02F\x1aK/\x20[U\
    nsupportedMessageResponse](#gauge.messages.UnsupportedMessageResponse)\n\
    \n\r\n\x05\x04\x1d\x02\x19\x04\x12\x04\xbe\x02\x02\n\n\r\n\x05\x04\x1d\
    \x02\x19\x06\x12\x04\xbe\x02\x0b%\n\r\n\x05\x04\x1d\x02\x19\x01\x12\x04\
    \xbe\x02&@\n\r\n\x05\x04\x1d\x02\x19\x03\x12\x04\xbe\x02CE\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        deps.push(super::spec::file_descriptor());
        let mut messages = ::std::vec::Vec::new();
        messages.push(KillProcessRequest::generated_message_descriptor_data());
        messages.push(ExecutionStatusResponse::generated_message_descriptor_data());
        messages.push(ExecutionStartingRequest::generated_message_descriptor_data());
        messages.push(ExecutionEndingRequest::generated_message_descriptor_data());
        messages.push(SpecExecutionStartingRequest::generated_message_descriptor_data());
        messages.push(SpecExecutionEndingRequest::generated_message_descriptor_data());
        messages.push(ScenarioExecutionStartingRequest::generated_message_descriptor_data());
        messages.push(ScenarioExecutionEndingRequest::generated_message_descriptor_data());
        messages.push(StepExecutionStartingRequest::generated_message_descriptor_data());
        messages.push(StepExecutionEndingRequest::generated_message_descriptor_data());
        messages.push(ExecutionInfo::generated_message_descriptor_data());
        messages.push(SpecInfo::generated_message_descriptor_data());
        messages.push(ScenarioInfo::generated_message_descriptor_data());
        messages.push(StepInfo::generated_message_descriptor_data());
        messages.push(ExecuteStepRequest::generated_message_descriptor_data());
        messages.push(StepValidateRequest::generated_message_descriptor_data());
        messages.push(StepValidateResponse::generated_message_descriptor_data());
        messages.push(SuiteExecutionResult::generated_message_descriptor_data());
        messages.push(StepNamesRequest::generated_message_descriptor_data());
        messages.push(StepNamesResponse::generated_message_descriptor_data());
        messages.push(ScenarioDataStoreInitRequest::generated_message_descriptor_data());
        messages.push(SpecDataStoreInitRequest::generated_message_descriptor_data());
        messages.push(SuiteDataStoreInitRequest::generated_message_descriptor_data());
        messages.push(ParameterPosition::generated_message_descriptor_data());
        messages.push(RefactorRequest::generated_message_descriptor_data());
        messages.push(RefactorResponse::generated_message_descriptor_data());
        messages.push(StepNameRequest::generated_message_descriptor_data());
        messages.push(StepNameResponse::generated_message_descriptor_data());
        messages.push(UnsupportedMessageResponse::generated_message_descriptor_data());
        messages.push(Message::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        enums.push(step_validate_response::ErrorType::generated_enum_descriptor_data());
        enums.push(message::MessageType::generated_enum_descriptor_data());
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}

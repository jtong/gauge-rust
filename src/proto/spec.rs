// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `spec.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

/// / A proto object representing a Specification
/// / A specification can contain Scenarios or Steps, besides Comments
#[derive(PartialEq,Clone,Default)]
pub struct ProtoSpec {
    // message fields
    /// / Heading describing the Specification
    specHeading: ::std::option::Option<::std::string::String>,
    /// / A collection of items that come under this step
    pub items: ::std::vec::Vec<ProtoItem>,
    /// / Flag indicating if this is a Table Driven Specification. The table is defined in the context, this is different from using a table parameter.
    isTableDriven: ::std::option::Option<bool>,
    /// / Contains a 'before' hook failure message. This happens when the `before_spec` hook has an error.
    pub preHookFailure: ::protobuf::MessageField<ProtoHookFailure>,
    /// / Contains a 'before' hook failure message. This happens when the `after_hook` hook has an error.
    pub postHookFailure: ::protobuf::MessageField<ProtoHookFailure>,
    /// / Contains the filename for that holds this specification.
    fileName: ::std::option::Option<::std::string::String>,
    /// / Contains a list of tags that are defined at the specification level. Scenario tags are not present here.
    pub tags: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoSpec {
    fn default() -> &'a ProtoSpec {
        <ProtoSpec as ::protobuf::Message>::default_instance()
    }
}

impl ProtoSpec {
    pub fn new() -> ProtoSpec {
        ::std::default::Default::default()
    }

    // required string specHeading = 1;

    pub fn get_specHeading(&self) -> &str {
        match self.specHeading.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_specHeading(&mut self) {
        self.specHeading = ::std::option::Option::None;
    }

    pub fn has_specHeading(&self) -> bool {
        self.specHeading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specHeading(&mut self, v: ::std::string::String) {
        self.specHeading = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_specHeading(&mut self) -> &mut ::std::string::String {
        if self.specHeading.is_none() {
            self.specHeading = ::std::option::Option::Some(::std::string::String::new());
        }
        self.specHeading.as_mut().unwrap()
    }

    // Take field
    pub fn take_specHeading(&mut self) -> ::std::string::String {
        self.specHeading.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool isTableDriven = 3;

    pub fn get_isTableDriven(&self) -> bool {
        self.isTableDriven.unwrap_or(false)
    }

    pub fn clear_isTableDriven(&mut self) {
        self.isTableDriven = ::std::option::Option::None;
    }

    pub fn has_isTableDriven(&self) -> bool {
        self.isTableDriven.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isTableDriven(&mut self, v: bool) {
        self.isTableDriven = ::std::option::Option::Some(v);
    }

    // required string fileName = 6;

    pub fn get_fileName(&self) -> &str {
        match self.fileName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fileName(&mut self) {
        self.fileName = ::std::option::Option::None;
    }

    pub fn has_fileName(&self) -> bool {
        self.fileName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileName(&mut self, v: ::std::string::String) {
        self.fileName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileName(&mut self) -> &mut ::std::string::String {
        if self.fileName.is_none() {
            self.fileName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fileName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileName(&mut self) -> ::std::string::String {
        self.fileName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "specHeading",
            |m: &ProtoSpec| { &m.specHeading },
            |m: &mut ProtoSpec| { &mut m.specHeading },
            ProtoSpec::get_specHeading,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &ProtoSpec| { &m.items },
            |m: &mut ProtoSpec| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "isTableDriven",
            |m: &ProtoSpec| { &m.isTableDriven },
            |m: &mut ProtoSpec| { &mut m.isTableDriven },
            ProtoSpec::get_isTableDriven,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoHookFailure>(
            "preHookFailure",
            |m: &ProtoSpec| { &m.preHookFailure },
            |m: &mut ProtoSpec| { &mut m.preHookFailure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoHookFailure>(
            "postHookFailure",
            |m: &ProtoSpec| { &m.postHookFailure },
            |m: &mut ProtoSpec| { &mut m.postHookFailure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "fileName",
            |m: &ProtoSpec| { &m.fileName },
            |m: &mut ProtoSpec| { &mut m.fileName },
            ProtoSpec::get_fileName,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &ProtoSpec| { &m.tags },
            |m: &mut ProtoSpec| { &mut m.tags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoSpec>(
            "ProtoSpec",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoSpec {
    fn is_initialized(&self) -> bool {
        if self.specHeading.is_none() {
            return false;
        }
        if self.isTableDriven.is_none() {
            return false;
        }
        if self.fileName.is_none() {
            return false;
        }
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preHookFailure {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postHookFailure {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.specHeading = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.items)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.isTableDriven = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.preHookFailure)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.postHookFailure)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fileName = ::std::option::Option::Some(is.read_string()?);
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.specHeading.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.isTableDriven {
            my_size += 2;
        }
        if let Some(v) = self.preHookFailure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.postHookFailure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fileName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.specHeading.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.isTableDriven {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.preHookFailure.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.postHookFailure.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.fileName.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.tags {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoSpec {
        ProtoSpec::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static ProtoSpec {
        static instance: ProtoSpec = ProtoSpec {
            specHeading: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            isTableDriven: ::std::option::Option::None,
            preHookFailure: ::protobuf::MessageField::none(),
            postHookFailure: ::protobuf::MessageField::none(),
            fileName: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoSpec {
    fn clear(&mut self) {
        self.specHeading = ::std::option::Option::None;
        self.items.clear();
        self.isTableDriven = ::std::option::Option::None;
        self.preHookFailure.clear();
        self.postHookFailure.clear();
        self.fileName = ::std::option::Option::None;
        self.tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoSpec {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Container for all valid Items under a Specification.
#[derive(PartialEq,Clone,Default)]
pub struct ProtoItem {
    // message fields
    /// / Itemtype of the current ProtoItem
    itemType: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<proto_item::ItemType>>,
    /// / Holds the Step definition. Valid only if ItemType = Step
    pub step: ::protobuf::MessageField<ProtoStep>,
    /// / Holds the Concept definition. Valid only if ItemType = Concept
    pub concept: ::protobuf::MessageField<ProtoConcept>,
    /// / Holds the Scenario definition. Valid only if ItemType = Scenario
    pub scenario: ::protobuf::MessageField<ProtoScenario>,
    /// / Holds the TableDrivenScenario definition. Valid only if ItemType = TableDrivenScenario
    pub tableDrivenScenario: ::protobuf::MessageField<ProtoTableDrivenScenario>,
    /// / Holds the Comment definition. Valid only if ItemType = Comment
    pub comment: ::protobuf::MessageField<ProtoComment>,
    /// / Holds the Table definition. Valid only if ItemType = Table
    pub table: ::protobuf::MessageField<ProtoTable>,
    /// / Holds the Tags definition. Valid only if ItemType = Tags
    pub tags: ::protobuf::MessageField<ProtoTags>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoItem {
    fn default() -> &'a ProtoItem {
        <ProtoItem as ::protobuf::Message>::default_instance()
    }
}

impl ProtoItem {
    pub fn new() -> ProtoItem {
        ::std::default::Default::default()
    }

    // required .gauge.messages.ProtoItem.ItemType itemType = 1;

    pub fn get_itemType(&self) -> proto_item::ItemType {
        match self.itemType {
            Some(e) => e.enum_value_or(proto_item::ItemType::Step),
            None => proto_item::ItemType::Step,
        }
    }

    pub fn clear_itemType(&mut self) {
        self.itemType = ::std::option::Option::None;
    }

    pub fn has_itemType(&self) -> bool {
        self.itemType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemType(&mut self, v: proto_item::ItemType) {
        self.itemType = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, proto_item::ItemType>(
            "itemType",
            |m: &ProtoItem| { &m.itemType },
            |m: &mut ProtoItem| { &mut m.itemType },
            proto_item::ItemType::Step,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoStep>(
            "step",
            |m: &ProtoItem| { &m.step },
            |m: &mut ProtoItem| { &mut m.step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoConcept>(
            "concept",
            |m: &ProtoItem| { &m.concept },
            |m: &mut ProtoItem| { &mut m.concept },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoScenario>(
            "scenario",
            |m: &ProtoItem| { &m.scenario },
            |m: &mut ProtoItem| { &mut m.scenario },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoTableDrivenScenario>(
            "tableDrivenScenario",
            |m: &ProtoItem| { &m.tableDrivenScenario },
            |m: &mut ProtoItem| { &mut m.tableDrivenScenario },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoComment>(
            "comment",
            |m: &ProtoItem| { &m.comment },
            |m: &mut ProtoItem| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoTable>(
            "table",
            |m: &ProtoItem| { &m.table },
            |m: &mut ProtoItem| { &mut m.table },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoTags>(
            "tags",
            |m: &ProtoItem| { &m.tags },
            |m: &mut ProtoItem| { &mut m.tags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoItem>(
            "ProtoItem",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoItem {
    fn is_initialized(&self) -> bool {
        if self.itemType.is_none() {
            return false;
        }
        for v in &self.step {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.concept {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scenario {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tableDrivenScenario {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.comment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.table {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.itemType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.step)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.concept)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.scenario)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.tableDrivenScenario)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.comment)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.table)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.itemType {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.step.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.concept.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.scenario.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tableDrivenScenario.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.comment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.table.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.tags.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.itemType {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.step.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.concept.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.scenario.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.tableDrivenScenario.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.comment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.table.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.tags.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoItem {
        ProtoItem::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static ProtoItem {
        static instance: ProtoItem = ProtoItem {
            itemType: ::std::option::Option::None,
            step: ::protobuf::MessageField::none(),
            concept: ::protobuf::MessageField::none(),
            scenario: ::protobuf::MessageField::none(),
            tableDrivenScenario: ::protobuf::MessageField::none(),
            comment: ::protobuf::MessageField::none(),
            table: ::protobuf::MessageField::none(),
            tags: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoItem {
    fn clear(&mut self) {
        self.itemType = ::std::option::Option::None;
        self.step.clear();
        self.concept.clear();
        self.scenario.clear();
        self.tableDrivenScenario.clear();
        self.comment.clear();
        self.table.clear();
        self.tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoItem {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProtoItem`
pub mod proto_item {
    /// / Enumerates various item types that the proto item can contain. Valid types are: Step, Comment, Concept, Scenario, TableDrivenScenario, Table, Tags
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum ItemType {
        Step = 1,
        Comment = 2,
        Concept = 3,
        Scenario = 4,
        TableDrivenScenario = 5,
        Table = 6,
        Tags = 7,
    }

    impl ::protobuf::ProtobufEnum for ItemType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ItemType> {
            match value {
                1 => ::std::option::Option::Some(ItemType::Step),
                2 => ::std::option::Option::Some(ItemType::Comment),
                3 => ::std::option::Option::Some(ItemType::Concept),
                4 => ::std::option::Option::Some(ItemType::Scenario),
                5 => ::std::option::Option::Some(ItemType::TableDrivenScenario),
                6 => ::std::option::Option::Some(ItemType::Table),
                7 => ::std::option::Option::Some(ItemType::Tags),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [ItemType] = &[
                ItemType::Step,
                ItemType::Comment,
                ItemType::Concept,
                ItemType::Scenario,
                ItemType::TableDrivenScenario,
                ItemType::Table,
                ItemType::Tags,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 0)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ItemType {
        fn default() -> Self {
            ItemType::Step
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemType {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl ItemType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<ItemType>("ProtoItem.ItemType", 0)
        }
    }
}

/// / A proto object representing a Scenario
#[derive(PartialEq,Clone,Default)]
pub struct ProtoScenario {
    // message fields
    /// / Heading of the given Scenario
    scenarioHeading: ::std::option::Option<::std::string::String>,
    /// / Flag to indicate if the Scenario execution failed
    failed: ::std::option::Option<bool>,
    /// / Collection of Context steps. The Context steps are executed before every run.
    pub contexts: ::std::vec::Vec<ProtoItem>,
    /// / Collection of Items under a scenario. These could be Steps, Comments, Tags, TableDrivenScenarios or Tables
    pub scenarioItems: ::std::vec::Vec<ProtoItem>,
    /// / Contains a 'before' hook failure message. This happens when the `before_scenario` hook has an error.
    pub preHookFailure: ::protobuf::MessageField<ProtoHookFailure>,
    /// / Contains a 'after' hook failure message. This happens when the `after_scenario` hook has an error.
    pub postHookFailure: ::protobuf::MessageField<ProtoHookFailure>,
    /// / Contains a list of tags that are defined at the specification level. Scenario tags are not present here.
    pub tags: ::std::vec::Vec<::std::string::String>,
    /// / Holds the time taken for executing this scenario.
    executionTime: ::std::option::Option<i64>,
    skipped: ::std::option::Option<bool>,
    pub skipErrors: ::std::vec::Vec<::std::string::String>,
    /// / Holds the unique Identifier of a scenario.
    ID: ::std::option::Option<::std::string::String>,
    /// / Collection of Teardown steps. The Teardown steps are executed after every run.
    pub tearDownSteps: ::std::vec::Vec<ProtoItem>,
    /// / Span(start, end) of scenario
    pub span: ::protobuf::MessageField<Span>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoScenario {
    fn default() -> &'a ProtoScenario {
        <ProtoScenario as ::protobuf::Message>::default_instance()
    }
}

impl ProtoScenario {
    pub fn new() -> ProtoScenario {
        ::std::default::Default::default()
    }

    // required string scenarioHeading = 1;

    pub fn get_scenarioHeading(&self) -> &str {
        match self.scenarioHeading.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_scenarioHeading(&mut self) {
        self.scenarioHeading = ::std::option::Option::None;
    }

    pub fn has_scenarioHeading(&self) -> bool {
        self.scenarioHeading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scenarioHeading(&mut self, v: ::std::string::String) {
        self.scenarioHeading = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scenarioHeading(&mut self) -> &mut ::std::string::String {
        if self.scenarioHeading.is_none() {
            self.scenarioHeading = ::std::option::Option::Some(::std::string::String::new());
        }
        self.scenarioHeading.as_mut().unwrap()
    }

    // Take field
    pub fn take_scenarioHeading(&mut self) -> ::std::string::String {
        self.scenarioHeading.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool failed = 2;

    pub fn get_failed(&self) -> bool {
        self.failed.unwrap_or(false)
    }

    pub fn clear_failed(&mut self) {
        self.failed = ::std::option::Option::None;
    }

    pub fn has_failed(&self) -> bool {
        self.failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed(&mut self, v: bool) {
        self.failed = ::std::option::Option::Some(v);
    }

    // optional int64 executionTime = 8;

    pub fn get_executionTime(&self) -> i64 {
        self.executionTime.unwrap_or(0)
    }

    pub fn clear_executionTime(&mut self) {
        self.executionTime = ::std::option::Option::None;
    }

    pub fn has_executionTime(&self) -> bool {
        self.executionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionTime(&mut self, v: i64) {
        self.executionTime = ::std::option::Option::Some(v);
    }

    // required bool skipped = 9;

    pub fn get_skipped(&self) -> bool {
        self.skipped.unwrap_or(false)
    }

    pub fn clear_skipped(&mut self) {
        self.skipped = ::std::option::Option::None;
    }

    pub fn has_skipped(&self) -> bool {
        self.skipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skipped(&mut self, v: bool) {
        self.skipped = ::std::option::Option::Some(v);
    }

    // optional string ID = 11;

    pub fn get_ID(&self) -> &str {
        match self.ID.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ID(&mut self) {
        self.ID = ::std::option::Option::None;
    }

    pub fn has_ID(&self) -> bool {
        self.ID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ID(&mut self, v: ::std::string::String) {
        self.ID = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ID(&mut self) -> &mut ::std::string::String {
        if self.ID.is_none() {
            self.ID = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ID.as_mut().unwrap()
    }

    // Take field
    pub fn take_ID(&mut self) -> ::std::string::String {
        self.ID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "scenarioHeading",
            |m: &ProtoScenario| { &m.scenarioHeading },
            |m: &mut ProtoScenario| { &mut m.scenarioHeading },
            ProtoScenario::get_scenarioHeading,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "failed",
            |m: &ProtoScenario| { &m.failed },
            |m: &mut ProtoScenario| { &mut m.failed },
            ProtoScenario::get_failed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contexts",
            |m: &ProtoScenario| { &m.contexts },
            |m: &mut ProtoScenario| { &mut m.contexts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scenarioItems",
            |m: &ProtoScenario| { &m.scenarioItems },
            |m: &mut ProtoScenario| { &mut m.scenarioItems },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoHookFailure>(
            "preHookFailure",
            |m: &ProtoScenario| { &m.preHookFailure },
            |m: &mut ProtoScenario| { &mut m.preHookFailure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoHookFailure>(
            "postHookFailure",
            |m: &ProtoScenario| { &m.postHookFailure },
            |m: &mut ProtoScenario| { &mut m.postHookFailure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &ProtoScenario| { &m.tags },
            |m: &mut ProtoScenario| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "executionTime",
            |m: &ProtoScenario| { &m.executionTime },
            |m: &mut ProtoScenario| { &mut m.executionTime },
            ProtoScenario::get_executionTime,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "skipped",
            |m: &ProtoScenario| { &m.skipped },
            |m: &mut ProtoScenario| { &mut m.skipped },
            ProtoScenario::get_skipped,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "skipErrors",
            |m: &ProtoScenario| { &m.skipErrors },
            |m: &mut ProtoScenario| { &mut m.skipErrors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "ID",
            |m: &ProtoScenario| { &m.ID },
            |m: &mut ProtoScenario| { &mut m.ID },
            ProtoScenario::get_ID,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tearDownSteps",
            |m: &ProtoScenario| { &m.tearDownSteps },
            |m: &mut ProtoScenario| { &mut m.tearDownSteps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Span>(
            "span",
            |m: &ProtoScenario| { &m.span },
            |m: &mut ProtoScenario| { &mut m.span },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoScenario>(
            "ProtoScenario",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoScenario {
    fn is_initialized(&self) -> bool {
        if self.scenarioHeading.is_none() {
            return false;
        }
        if self.failed.is_none() {
            return false;
        }
        if self.skipped.is_none() {
            return false;
        }
        for v in &self.contexts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scenarioItems {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preHookFailure {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postHookFailure {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tearDownSteps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.span {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scenarioHeading = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.failed = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.contexts)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.scenarioItems)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.preHookFailure)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.postHookFailure)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.executionTime = ::std::option::Option::Some(is.read_int64()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.skipped = ::std::option::Option::Some(is.read_bool()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.skipErrors)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ID = ::std::option::Option::Some(is.read_string()?);
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.tearDownSteps)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.span)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.scenarioHeading.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.failed {
            my_size += 2;
        }
        for value in &self.contexts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.scenarioItems {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.preHookFailure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.postHookFailure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.executionTime {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skipped {
            my_size += 2;
        }
        for value in &self.skipErrors {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(v) = self.ID.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.tearDownSteps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.span.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.scenarioHeading.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.failed {
            os.write_bool(2, v)?;
        }
        for v in &self.contexts {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.scenarioItems {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.preHookFailure.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.postHookFailure.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.tags {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.executionTime {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.skipped {
            os.write_bool(9, v)?;
        }
        for v in &self.skipErrors {
            os.write_string(10, &v)?;
        };
        if let Some(v) = self.ID.as_ref() {
            os.write_string(11, v)?;
        }
        for v in &self.tearDownSteps {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.span.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoScenario {
        ProtoScenario::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static ProtoScenario {
        static instance: ProtoScenario = ProtoScenario {
            scenarioHeading: ::std::option::Option::None,
            failed: ::std::option::Option::None,
            contexts: ::std::vec::Vec::new(),
            scenarioItems: ::std::vec::Vec::new(),
            preHookFailure: ::protobuf::MessageField::none(),
            postHookFailure: ::protobuf::MessageField::none(),
            tags: ::std::vec::Vec::new(),
            executionTime: ::std::option::Option::None,
            skipped: ::std::option::Option::None,
            skipErrors: ::std::vec::Vec::new(),
            ID: ::std::option::Option::None,
            tearDownSteps: ::std::vec::Vec::new(),
            span: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoScenario {
    fn clear(&mut self) {
        self.scenarioHeading = ::std::option::Option::None;
        self.failed = ::std::option::Option::None;
        self.contexts.clear();
        self.scenarioItems.clear();
        self.preHookFailure.clear();
        self.postHookFailure.clear();
        self.tags.clear();
        self.executionTime = ::std::option::Option::None;
        self.skipped = ::std::option::Option::None;
        self.skipErrors.clear();
        self.ID = ::std::option::Option::None;
        self.tearDownSteps.clear();
        self.span.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoScenario {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoScenario {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing a Span of content
#[derive(PartialEq,Clone,Default)]
pub struct Span {
    // message fields
    start: ::std::option::Option<i64>,
    end: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span {
    fn default() -> &'a Span {
        <Span as ::protobuf::Message>::default_instance()
    }
}

impl Span {
    pub fn new() -> Span {
        ::std::default::Default::default()
    }

    // required int64 start = 1;

    pub fn get_start(&self) -> i64 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i64) {
        self.start = ::std::option::Option::Some(v);
    }

    // required int64 end = 2;

    pub fn get_end(&self) -> i64 {
        self.end.unwrap_or(0)
    }

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i64) {
        self.end = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "start",
            |m: &Span| { &m.start },
            |m: &mut Span| { &mut m.start },
            Span::get_start,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "end",
            |m: &Span| { &m.end },
            |m: &mut Span| { &mut m.end },
            Span::get_end,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Span>(
            "Span",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for Span {
    fn is_initialized(&self) -> bool {
        if self.start.is_none() {
            return false;
        }
        if self.end.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.start = ::std::option::Option::Some(is.read_int64()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.end = ::std::option::Option::Some(is.read_int64()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.end {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Span {
        Span::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 3)
    }

    fn default_instance() -> &'static Span {
        static instance: Span = Span {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Span {
    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing a TableDrivenScenario
#[derive(PartialEq,Clone,Default)]
pub struct ProtoTableDrivenScenario {
    // message fields
    /// / Holds the Underlying scenario that is executed for every row in the table.
    pub scenarios: ::std::vec::Vec<ProtoScenario>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoTableDrivenScenario {
    fn default() -> &'a ProtoTableDrivenScenario {
        <ProtoTableDrivenScenario as ::protobuf::Message>::default_instance()
    }
}

impl ProtoTableDrivenScenario {
    pub fn new() -> ProtoTableDrivenScenario {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scenarios",
            |m: &ProtoTableDrivenScenario| { &m.scenarios },
            |m: &mut ProtoTableDrivenScenario| { &mut m.scenarios },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoTableDrivenScenario>(
            "ProtoTableDrivenScenario",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoTableDrivenScenario {
    fn is_initialized(&self) -> bool {
        for v in &self.scenarios {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.scenarios)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.scenarios {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.scenarios {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoTableDrivenScenario {
        ProtoTableDrivenScenario::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static ProtoTableDrivenScenario {
        static instance: ProtoTableDrivenScenario = ProtoTableDrivenScenario {
            scenarios: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoTableDrivenScenario {
    fn clear(&mut self) {
        self.scenarios.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoTableDrivenScenario {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoTableDrivenScenario {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing a Step
#[derive(PartialEq,Clone,Default)]
pub struct ProtoStep {
    // message fields
    /// / Holds the raw text of the Step as defined in the spec file. This contains the actual parameter values.
    actualText: ::std::option::Option<::std::string::String>,
    /// / Contains the parsed text of the Step. This will have placeholders for the parameters.
    parsedText: ::std::option::Option<::std::string::String>,
    /// / Collection of a list of fragments for a Step. A fragment could be either text or parameter.
    pub fragments: ::std::vec::Vec<Fragment>,
    /// / Holds the result from the execution.
    pub stepExecutionResult: ::protobuf::MessageField<ProtoStepExecutionResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoStep {
    fn default() -> &'a ProtoStep {
        <ProtoStep as ::protobuf::Message>::default_instance()
    }
}

impl ProtoStep {
    pub fn new() -> ProtoStep {
        ::std::default::Default::default()
    }

    // required string actualText = 1;

    pub fn get_actualText(&self) -> &str {
        match self.actualText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_actualText(&mut self) {
        self.actualText = ::std::option::Option::None;
    }

    pub fn has_actualText(&self) -> bool {
        self.actualText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actualText(&mut self, v: ::std::string::String) {
        self.actualText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actualText(&mut self) -> &mut ::std::string::String {
        if self.actualText.is_none() {
            self.actualText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.actualText.as_mut().unwrap()
    }

    // Take field
    pub fn take_actualText(&mut self) -> ::std::string::String {
        self.actualText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string parsedText = 2;

    pub fn get_parsedText(&self) -> &str {
        match self.parsedText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parsedText(&mut self) {
        self.parsedText = ::std::option::Option::None;
    }

    pub fn has_parsedText(&self) -> bool {
        self.parsedText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parsedText(&mut self, v: ::std::string::String) {
        self.parsedText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parsedText(&mut self) -> &mut ::std::string::String {
        if self.parsedText.is_none() {
            self.parsedText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parsedText.as_mut().unwrap()
    }

    // Take field
    pub fn take_parsedText(&mut self) -> ::std::string::String {
        self.parsedText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "actualText",
            |m: &ProtoStep| { &m.actualText },
            |m: &mut ProtoStep| { &mut m.actualText },
            ProtoStep::get_actualText,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "parsedText",
            |m: &ProtoStep| { &m.parsedText },
            |m: &mut ProtoStep| { &mut m.parsedText },
            ProtoStep::get_parsedText,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fragments",
            |m: &ProtoStep| { &m.fragments },
            |m: &mut ProtoStep| { &mut m.fragments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoStepExecutionResult>(
            "stepExecutionResult",
            |m: &ProtoStep| { &m.stepExecutionResult },
            |m: &mut ProtoStep| { &mut m.stepExecutionResult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoStep>(
            "ProtoStep",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoStep {
    fn is_initialized(&self) -> bool {
        if self.actualText.is_none() {
            return false;
        }
        if self.parsedText.is_none() {
            return false;
        }
        for v in &self.fragments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stepExecutionResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.actualText = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parsedText = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.fragments)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepExecutionResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.actualText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.parsedText.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.fragments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.stepExecutionResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.actualText.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.parsedText.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.fragments {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.stepExecutionResult.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoStep {
        ProtoStep::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static ProtoStep {
        static instance: ProtoStep = ProtoStep {
            actualText: ::std::option::Option::None,
            parsedText: ::std::option::Option::None,
            fragments: ::std::vec::Vec::new(),
            stepExecutionResult: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoStep {
    fn clear(&mut self) {
        self.actualText = ::std::option::Option::None;
        self.parsedText = ::std::option::Option::None;
        self.fragments.clear();
        self.stepExecutionResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoStep {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Concept is a type of step, that can have multiple Steps.
/// / But from a caller's perspective, it is still used as any other Step
/// / A proto object representing a Concept
#[derive(PartialEq,Clone,Default)]
pub struct ProtoConcept {
    // message fields
    /// / Represents the Step value of a Concept.
    pub conceptStep: ::protobuf::MessageField<ProtoStep>,
    /// / Collection of Steps in the given concepts.
    pub steps: ::std::vec::Vec<ProtoItem>,
    /// / Holds the execution result.
    pub conceptExecutionResult: ::protobuf::MessageField<ProtoStepExecutionResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoConcept {
    fn default() -> &'a ProtoConcept {
        <ProtoConcept as ::protobuf::Message>::default_instance()
    }
}

impl ProtoConcept {
    pub fn new() -> ProtoConcept {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoStep>(
            "conceptStep",
            |m: &ProtoConcept| { &m.conceptStep },
            |m: &mut ProtoConcept| { &mut m.conceptStep },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &ProtoConcept| { &m.steps },
            |m: &mut ProtoConcept| { &mut m.steps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoStepExecutionResult>(
            "conceptExecutionResult",
            |m: &ProtoConcept| { &m.conceptExecutionResult },
            |m: &mut ProtoConcept| { &mut m.conceptExecutionResult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoConcept>(
            "ProtoConcept",
            6,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoConcept {
    fn is_initialized(&self) -> bool {
        if self.conceptStep.is_none() {
            return false;
        }
        for v in &self.conceptStep {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.steps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conceptExecutionResult {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.conceptStep)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.steps)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.conceptExecutionResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.conceptStep.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.conceptExecutionResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.conceptStep.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.steps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.conceptExecutionResult.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoConcept {
        ProtoConcept::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 6)
    }

    fn default_instance() -> &'static ProtoConcept {
        static instance: ProtoConcept = ProtoConcept {
            conceptStep: ::protobuf::MessageField::none(),
            steps: ::std::vec::Vec::new(),
            conceptExecutionResult: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoConcept {
    fn clear(&mut self) {
        self.conceptStep.clear();
        self.steps.clear();
        self.conceptExecutionResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoConcept {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoConcept {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing Tags
#[derive(PartialEq,Clone,Default)]
pub struct ProtoTags {
    // message fields
    /// / A collection of Tags
    pub tags: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoTags {
    fn default() -> &'a ProtoTags {
        <ProtoTags as ::protobuf::Message>::default_instance()
    }
}

impl ProtoTags {
    pub fn new() -> ProtoTags {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &ProtoTags| { &m.tags },
            |m: &mut ProtoTags| { &mut m.tags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoTags>(
            "ProtoTags",
            7,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoTags {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tags {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoTags {
        ProtoTags::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 7)
    }

    fn default_instance() -> &'static ProtoTags {
        static instance: ProtoTags = ProtoTags {
            tags: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoTags {
    fn clear(&mut self) {
        self.tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoTags {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoTags {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing Fragment.
/// / Fragments, put together make up A Step
#[derive(PartialEq,Clone,Default)]
pub struct Fragment {
    // message fields
    /// / Type of Fragment, valid values are Text, Parameter
    fragmentType: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<fragment::FragmentType>>,
    /// / Text part of the Fragment, valid only if FragmentType=Text
    text: ::std::option::Option<::std::string::String>,
    /// / Parameter part of the Fragment, valid only if FragmentType=Parameter
    pub parameter: ::protobuf::MessageField<Parameter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Fragment {
    fn default() -> &'a Fragment {
        <Fragment as ::protobuf::Message>::default_instance()
    }
}

impl Fragment {
    pub fn new() -> Fragment {
        ::std::default::Default::default()
    }

    // required .gauge.messages.Fragment.FragmentType fragmentType = 1;

    pub fn get_fragmentType(&self) -> fragment::FragmentType {
        match self.fragmentType {
            Some(e) => e.enum_value_or(fragment::FragmentType::Text),
            None => fragment::FragmentType::Text,
        }
    }

    pub fn clear_fragmentType(&mut self) {
        self.fragmentType = ::std::option::Option::None;
    }

    pub fn has_fragmentType(&self) -> bool {
        self.fragmentType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fragmentType(&mut self, v: fragment::FragmentType) {
        self.fragmentType = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional string text = 2;

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, fragment::FragmentType>(
            "fragmentType",
            |m: &Fragment| { &m.fragmentType },
            |m: &mut Fragment| { &mut m.fragmentType },
            fragment::FragmentType::Text,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "text",
            |m: &Fragment| { &m.text },
            |m: &mut Fragment| { &mut m.text },
            Fragment::get_text,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Parameter>(
            "parameter",
            |m: &Fragment| { &m.parameter },
            |m: &mut Fragment| { &mut m.parameter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Fragment>(
            "Fragment",
            8,
            fields,
        )
    }
}

impl ::protobuf::Message for Fragment {
    fn is_initialized(&self) -> bool {
        if self.fragmentType.is_none() {
            return false;
        }
        for v in &self.parameter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fragmentType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.parameter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fragmentType {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.parameter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fragmentType {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.parameter.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Fragment {
        Fragment::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 8)
    }

    fn default_instance() -> &'static Fragment {
        static instance: Fragment = Fragment {
            fragmentType: ::std::option::Option::None,
            text: ::std::option::Option::None,
            parameter: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Fragment {
    fn clear(&mut self) {
        self.fragmentType = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.parameter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Fragment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Fragment {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Fragment`
pub mod fragment {
    /// / Enum representing the types of Fragment
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum FragmentType {
        Text = 1,
        Parameter = 2,
    }

    impl ::protobuf::ProtobufEnum for FragmentType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<FragmentType> {
            match value {
                1 => ::std::option::Option::Some(FragmentType::Text),
                2 => ::std::option::Option::Some(FragmentType::Parameter),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [FragmentType] = &[
                FragmentType::Text,
                FragmentType::Parameter,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 1)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for FragmentType {
        fn default() -> Self {
            FragmentType::Text
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FragmentType {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl FragmentType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<FragmentType>("Fragment.FragmentType", 1)
        }
    }
}

/// / A proto object representing Fragment.
#[derive(PartialEq,Clone,Default)]
pub struct Parameter {
    // message fields
    /// / Type of the Parameter. Valid values: Static, Dynamic, Special_String, Special_Table, Table
    parameterType: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<parameter::ParameterType>>,
    /// / Holds the value of the parameter
    value: ::std::option::Option<::std::string::String>,
    /// / Holds the name of the parameter, used as Key to lookup the value.
    name: ::std::option::Option<::std::string::String>,
    /// / Holds the table value, if parameterType=Table or Special_Table
    pub table: ::protobuf::MessageField<ProtoTable>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Parameter {
    fn default() -> &'a Parameter {
        <Parameter as ::protobuf::Message>::default_instance()
    }
}

impl Parameter {
    pub fn new() -> Parameter {
        ::std::default::Default::default()
    }

    // required .gauge.messages.Parameter.ParameterType parameterType = 1;

    pub fn get_parameterType(&self) -> parameter::ParameterType {
        match self.parameterType {
            Some(e) => e.enum_value_or(parameter::ParameterType::Static),
            None => parameter::ParameterType::Static,
        }
    }

    pub fn clear_parameterType(&mut self) {
        self.parameterType = ::std::option::Option::None;
    }

    pub fn has_parameterType(&self) -> bool {
        self.parameterType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameterType(&mut self, v: parameter::ParameterType) {
        self.parameterType = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // optional string value = 2;

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, parameter::ParameterType>(
            "parameterType",
            |m: &Parameter| { &m.parameterType },
            |m: &mut Parameter| { &mut m.parameterType },
            parameter::ParameterType::Static,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "value",
            |m: &Parameter| { &m.value },
            |m: &mut Parameter| { &mut m.value },
            Parameter::get_value,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "name",
            |m: &Parameter| { &m.name },
            |m: &mut Parameter| { &mut m.name },
            Parameter::get_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoTable>(
            "table",
            |m: &Parameter| { &m.table },
            |m: &mut Parameter| { &mut m.table },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Parameter>(
            "Parameter",
            9,
            fields,
        )
    }
}

impl ::protobuf::Message for Parameter {
    fn is_initialized(&self) -> bool {
        if self.parameterType.is_none() {
            return false;
        }
        for v in &self.table {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameterType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.table)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.parameterType {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.table.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.parameterType {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.table.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Parameter {
        Parameter::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 9)
    }

    fn default_instance() -> &'static Parameter {
        static instance: Parameter = Parameter {
            parameterType: ::std::option::Option::None,
            value: ::std::option::Option::None,
            name: ::std::option::Option::None,
            table: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Parameter {
    fn clear(&mut self) {
        self.parameterType = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.table.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Parameter {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Parameter`
pub mod parameter {
    /// / Enum representing types of Parameter.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum ParameterType {
        Static = 1,
        Dynamic = 2,
        Special_String = 3,
        Special_Table = 4,
        Table = 5,
    }

    impl ::protobuf::ProtobufEnum for ParameterType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ParameterType> {
            match value {
                1 => ::std::option::Option::Some(ParameterType::Static),
                2 => ::std::option::Option::Some(ParameterType::Dynamic),
                3 => ::std::option::Option::Some(ParameterType::Special_String),
                4 => ::std::option::Option::Some(ParameterType::Special_Table),
                5 => ::std::option::Option::Some(ParameterType::Table),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [ParameterType] = &[
                ParameterType::Static,
                ParameterType::Dynamic,
                ParameterType::Special_String,
                ParameterType::Special_Table,
                ParameterType::Table,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 2)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ParameterType {
        fn default() -> Self {
            ParameterType::Static
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ParameterType {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl ParameterType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<ParameterType>("Parameter.ParameterType", 2)
        }
    }
}

/// / A proto object representing Comment.
#[derive(PartialEq,Clone,Default)]
pub struct ProtoComment {
    // message fields
    /// / Text representing the Comment.
    text: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoComment {
    fn default() -> &'a ProtoComment {
        <ProtoComment as ::protobuf::Message>::default_instance()
    }
}

impl ProtoComment {
    pub fn new() -> ProtoComment {
        ::std::default::Default::default()
    }

    // required string text = 1;

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "text",
            |m: &ProtoComment| { &m.text },
            |m: &mut ProtoComment| { &mut m.text },
            ProtoComment::get_text,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoComment>(
            "ProtoComment",
            10,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoComment {
    fn is_initialized(&self) -> bool {
        if self.text.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoComment {
        ProtoComment::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 10)
    }

    fn default_instance() -> &'static ProtoComment {
        static instance: ProtoComment = ProtoComment {
            text: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoComment {
    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoComment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoComment {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing Table.
#[derive(PartialEq,Clone,Default)]
pub struct ProtoTable {
    // message fields
    /// / Contains the Headers for the table
    pub headers: ::protobuf::MessageField<ProtoTableRow>,
    /// / Contains the Rows for the table
    pub rows: ::std::vec::Vec<ProtoTableRow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoTable {
    fn default() -> &'a ProtoTable {
        <ProtoTable as ::protobuf::Message>::default_instance()
    }
}

impl ProtoTable {
    pub fn new() -> ProtoTable {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoTableRow>(
            "headers",
            |m: &ProtoTable| { &m.headers },
            |m: &mut ProtoTable| { &mut m.headers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rows",
            |m: &ProtoTable| { &m.rows },
            |m: &mut ProtoTable| { &mut m.rows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoTable>(
            "ProtoTable",
            11,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoTable {
    fn is_initialized(&self) -> bool {
        if self.headers.is_none() {
            return false;
        }
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.headers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.rows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.headers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.headers.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.rows {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoTable {
        ProtoTable::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 11)
    }

    fn default_instance() -> &'static ProtoTable {
        static instance: ProtoTable = ProtoTable {
            headers: ::protobuf::MessageField::none(),
            rows: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoTable {
    fn clear(&mut self) {
        self.headers.clear();
        self.rows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoTable {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing Table.
#[derive(PartialEq,Clone,Default)]
pub struct ProtoTableRow {
    // message fields
    /// / Represents the cells of a given table
    pub cells: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoTableRow {
    fn default() -> &'a ProtoTableRow {
        <ProtoTableRow as ::protobuf::Message>::default_instance()
    }
}

impl ProtoTableRow {
    pub fn new() -> ProtoTableRow {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cells",
            |m: &ProtoTableRow| { &m.cells },
            |m: &mut ProtoTableRow| { &mut m.cells },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoTableRow>(
            "ProtoTableRow",
            12,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoTableRow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.cells)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.cells {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.cells {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoTableRow {
        ProtoTableRow::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 12)
    }

    fn default_instance() -> &'static ProtoTableRow {
        static instance: ProtoTableRow = ProtoTableRow {
            cells: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoTableRow {
    fn clear(&mut self) {
        self.cells.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoTableRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoTableRow {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing Step Execution result
#[derive(PartialEq,Clone,Default)]
pub struct ProtoStepExecutionResult {
    // message fields
    /// / The actual result of the execution
    pub executionResult: ::protobuf::MessageField<ProtoExecutionResult>,
    /// / Contains a 'before' hook failure message. This happens when the `before_step` hook has an error.
    pub preHookFailure: ::protobuf::MessageField<ProtoHookFailure>,
    /// / Contains a 'after' hook failure message. This happens when the `after_step` hook has an error.
    pub postHookFailure: ::protobuf::MessageField<ProtoHookFailure>,
    skipped: ::std::option::Option<bool>,
    skippedReason: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoStepExecutionResult {
    fn default() -> &'a ProtoStepExecutionResult {
        <ProtoStepExecutionResult as ::protobuf::Message>::default_instance()
    }
}

impl ProtoStepExecutionResult {
    pub fn new() -> ProtoStepExecutionResult {
        ::std::default::Default::default()
    }

    // required bool skipped = 4;

    pub fn get_skipped(&self) -> bool {
        self.skipped.unwrap_or(false)
    }

    pub fn clear_skipped(&mut self) {
        self.skipped = ::std::option::Option::None;
    }

    pub fn has_skipped(&self) -> bool {
        self.skipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skipped(&mut self, v: bool) {
        self.skipped = ::std::option::Option::Some(v);
    }

    // optional string skippedReason = 5;

    pub fn get_skippedReason(&self) -> &str {
        match self.skippedReason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_skippedReason(&mut self) {
        self.skippedReason = ::std::option::Option::None;
    }

    pub fn has_skippedReason(&self) -> bool {
        self.skippedReason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skippedReason(&mut self, v: ::std::string::String) {
        self.skippedReason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_skippedReason(&mut self) -> &mut ::std::string::String {
        if self.skippedReason.is_none() {
            self.skippedReason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.skippedReason.as_mut().unwrap()
    }

    // Take field
    pub fn take_skippedReason(&mut self) -> ::std::string::String {
        self.skippedReason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoExecutionResult>(
            "executionResult",
            |m: &ProtoStepExecutionResult| { &m.executionResult },
            |m: &mut ProtoStepExecutionResult| { &mut m.executionResult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoHookFailure>(
            "preHookFailure",
            |m: &ProtoStepExecutionResult| { &m.preHookFailure },
            |m: &mut ProtoStepExecutionResult| { &mut m.preHookFailure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoHookFailure>(
            "postHookFailure",
            |m: &ProtoStepExecutionResult| { &m.postHookFailure },
            |m: &mut ProtoStepExecutionResult| { &mut m.postHookFailure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "skipped",
            |m: &ProtoStepExecutionResult| { &m.skipped },
            |m: &mut ProtoStepExecutionResult| { &mut m.skipped },
            ProtoStepExecutionResult::get_skipped,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "skippedReason",
            |m: &ProtoStepExecutionResult| { &m.skippedReason },
            |m: &mut ProtoStepExecutionResult| { &mut m.skippedReason },
            ProtoStepExecutionResult::get_skippedReason,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoStepExecutionResult>(
            "ProtoStepExecutionResult",
            13,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoStepExecutionResult {
    fn is_initialized(&self) -> bool {
        if self.skipped.is_none() {
            return false;
        }
        for v in &self.executionResult {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preHookFailure {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postHookFailure {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.executionResult)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.preHookFailure)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.postHookFailure)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.skipped = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.skippedReason = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.executionResult.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.preHookFailure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.postHookFailure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.skipped {
            my_size += 2;
        }
        if let Some(v) = self.skippedReason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.executionResult.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.preHookFailure.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.postHookFailure.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.skipped {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.skippedReason.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoStepExecutionResult {
        ProtoStepExecutionResult::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 13)
    }

    fn default_instance() -> &'static ProtoStepExecutionResult {
        static instance: ProtoStepExecutionResult = ProtoStepExecutionResult {
            executionResult: ::protobuf::MessageField::none(),
            preHookFailure: ::protobuf::MessageField::none(),
            postHookFailure: ::protobuf::MessageField::none(),
            skipped: ::std::option::Option::None,
            skippedReason: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoStepExecutionResult {
    fn clear(&mut self) {
        self.executionResult.clear();
        self.preHookFailure.clear();
        self.postHookFailure.clear();
        self.skipped = ::std::option::Option::None;
        self.skippedReason = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoStepExecutionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoStepExecutionResult {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing the result of an execution
#[derive(PartialEq,Clone,Default)]
pub struct ProtoExecutionResult {
    // message fields
    /// / Flag to indicate failure
    failed: ::std::option::Option<bool>,
    /// / Flag to indicate if the error is recoverable from.
    recoverableError: ::std::option::Option<bool>,
    /// / The actual error message.
    errorMessage: ::std::option::Option<::std::string::String>,
    /// / Stacktrace of the error
    stackTrace: ::std::option::Option<::std::string::String>,
    /// / Byte array containing screenshot taken at the time of failure.
    screenShot: ::std::option::Option<::std::vec::Vec<u8>>,
    /// / Holds the time taken for executing this scenario.
    executionTime: ::std::option::Option<i64>,
    /// / Additional information at exec time to be available on reports
    pub message: ::std::vec::Vec<::std::string::String>,
    /// / Type of the Error. Valid values: ASSERTION, VERIFICATION. Default: ASSERTION
    errorType: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<proto_execution_result::ErrorType>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoExecutionResult {
    fn default() -> &'a ProtoExecutionResult {
        <ProtoExecutionResult as ::protobuf::Message>::default_instance()
    }
}

impl ProtoExecutionResult {
    pub fn new() -> ProtoExecutionResult {
        ::std::default::Default::default()
    }

    // required bool failed = 1;

    pub fn get_failed(&self) -> bool {
        self.failed.unwrap_or(false)
    }

    pub fn clear_failed(&mut self) {
        self.failed = ::std::option::Option::None;
    }

    pub fn has_failed(&self) -> bool {
        self.failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed(&mut self, v: bool) {
        self.failed = ::std::option::Option::Some(v);
    }

    // optional bool recoverableError = 2;

    pub fn get_recoverableError(&self) -> bool {
        self.recoverableError.unwrap_or(false)
    }

    pub fn clear_recoverableError(&mut self) {
        self.recoverableError = ::std::option::Option::None;
    }

    pub fn has_recoverableError(&self) -> bool {
        self.recoverableError.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recoverableError(&mut self, v: bool) {
        self.recoverableError = ::std::option::Option::Some(v);
    }

    // optional string errorMessage = 3;

    pub fn get_errorMessage(&self) -> &str {
        match self.errorMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_errorMessage(&mut self) {
        self.errorMessage = ::std::option::Option::None;
    }

    pub fn has_errorMessage(&self) -> bool {
        self.errorMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorMessage(&mut self, v: ::std::string::String) {
        self.errorMessage = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorMessage(&mut self) -> &mut ::std::string::String {
        if self.errorMessage.is_none() {
            self.errorMessage = ::std::option::Option::Some(::std::string::String::new());
        }
        self.errorMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_errorMessage(&mut self) -> ::std::string::String {
        self.errorMessage.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string stackTrace = 4;

    pub fn get_stackTrace(&self) -> &str {
        match self.stackTrace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stackTrace(&mut self) {
        self.stackTrace = ::std::option::Option::None;
    }

    pub fn has_stackTrace(&self) -> bool {
        self.stackTrace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stackTrace(&mut self, v: ::std::string::String) {
        self.stackTrace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stackTrace(&mut self) -> &mut ::std::string::String {
        if self.stackTrace.is_none() {
            self.stackTrace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stackTrace.as_mut().unwrap()
    }

    // Take field
    pub fn take_stackTrace(&mut self) -> ::std::string::String {
        self.stackTrace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes screenShot = 5;

    pub fn get_screenShot(&self) -> &[u8] {
        match self.screenShot.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_screenShot(&mut self) {
        self.screenShot = ::std::option::Option::None;
    }

    pub fn has_screenShot(&self) -> bool {
        self.screenShot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenShot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenShot = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenShot(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.screenShot.is_none() {
            self.screenShot = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.screenShot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenShot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenShot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required int64 executionTime = 6;

    pub fn get_executionTime(&self) -> i64 {
        self.executionTime.unwrap_or(0)
    }

    pub fn clear_executionTime(&mut self) {
        self.executionTime = ::std::option::Option::None;
    }

    pub fn has_executionTime(&self) -> bool {
        self.executionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionTime(&mut self, v: i64) {
        self.executionTime = ::std::option::Option::Some(v);
    }

    // optional .gauge.messages.ProtoExecutionResult.ErrorType errorType = 8;

    pub fn get_errorType(&self) -> proto_execution_result::ErrorType {
        match self.errorType {
            Some(e) => e.enum_value_or(proto_execution_result::ErrorType::ASSERTION),
            None => proto_execution_result::ErrorType::ASSERTION,
        }
    }

    pub fn clear_errorType(&mut self) {
        self.errorType = ::std::option::Option::None;
    }

    pub fn has_errorType(&self) -> bool {
        self.errorType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorType(&mut self, v: proto_execution_result::ErrorType) {
        self.errorType = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "failed",
            |m: &ProtoExecutionResult| { &m.failed },
            |m: &mut ProtoExecutionResult| { &mut m.failed },
            ProtoExecutionResult::get_failed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "recoverableError",
            |m: &ProtoExecutionResult| { &m.recoverableError },
            |m: &mut ProtoExecutionResult| { &mut m.recoverableError },
            ProtoExecutionResult::get_recoverableError,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "errorMessage",
            |m: &ProtoExecutionResult| { &m.errorMessage },
            |m: &mut ProtoExecutionResult| { &mut m.errorMessage },
            ProtoExecutionResult::get_errorMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "stackTrace",
            |m: &ProtoExecutionResult| { &m.stackTrace },
            |m: &mut ProtoExecutionResult| { &mut m.stackTrace },
            ProtoExecutionResult::get_stackTrace,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "screenShot",
            |m: &ProtoExecutionResult| { &m.screenShot },
            |m: &mut ProtoExecutionResult| { &mut m.screenShot },
            ProtoExecutionResult::get_screenShot,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "executionTime",
            |m: &ProtoExecutionResult| { &m.executionTime },
            |m: &mut ProtoExecutionResult| { &mut m.executionTime },
            ProtoExecutionResult::get_executionTime,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "message",
            |m: &ProtoExecutionResult| { &m.message },
            |m: &mut ProtoExecutionResult| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, proto_execution_result::ErrorType>(
            "errorType",
            |m: &ProtoExecutionResult| { &m.errorType },
            |m: &mut ProtoExecutionResult| { &mut m.errorType },
            proto_execution_result::ErrorType::ASSERTION,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoExecutionResult>(
            "ProtoExecutionResult",
            14,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoExecutionResult {
    fn is_initialized(&self) -> bool {
        if self.failed.is_none() {
            return false;
        }
        if self.executionTime.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.failed = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.recoverableError = ::std::option::Option::Some(is.read_bool()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.errorMessage = ::std::option::Option::Some(is.read_string()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stackTrace = ::std::option::Option::Some(is.read_string()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.screenShot = ::std::option::Option::Some(is.read_bytes()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.executionTime = ::std::option::Option::Some(is.read_int64()?);
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.message)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.errorType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.failed {
            my_size += 2;
        }
        if let Some(v) = self.recoverableError {
            my_size += 2;
        }
        if let Some(v) = self.errorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.stackTrace.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.screenShot.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.executionTime {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.message {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.errorType {
            my_size += ::protobuf::rt::enum_or_unknown_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.failed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.recoverableError {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.errorMessage.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.stackTrace.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.screenShot.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.executionTime {
            os.write_int64(6, v)?;
        }
        for v in &self.message {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.errorType {
            os.write_enum(8, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoExecutionResult {
        ProtoExecutionResult::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 14)
    }

    fn default_instance() -> &'static ProtoExecutionResult {
        static instance: ProtoExecutionResult = ProtoExecutionResult {
            failed: ::std::option::Option::None,
            recoverableError: ::std::option::Option::None,
            errorMessage: ::std::option::Option::None,
            stackTrace: ::std::option::Option::None,
            screenShot: ::std::option::Option::None,
            executionTime: ::std::option::Option::None,
            message: ::std::vec::Vec::new(),
            errorType: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoExecutionResult {
    fn clear(&mut self) {
        self.failed = ::std::option::Option::None;
        self.recoverableError = ::std::option::Option::None;
        self.errorMessage = ::std::option::Option::None;
        self.stackTrace = ::std::option::Option::None;
        self.screenShot = ::std::option::Option::None;
        self.executionTime = ::std::option::Option::None;
        self.message.clear();
        self.errorType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoExecutionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoExecutionResult {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProtoExecutionResult`
pub mod proto_execution_result {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum ErrorType {
        ASSERTION = 1,
        VERIFICATION = 2,
    }

    impl ::protobuf::ProtobufEnum for ErrorType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ErrorType> {
            match value {
                1 => ::std::option::Option::Some(ErrorType::ASSERTION),
                2 => ::std::option::Option::Some(ErrorType::VERIFICATION),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [ErrorType] = &[
                ErrorType::ASSERTION,
                ErrorType::VERIFICATION,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 3)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for ErrorType {
        fn default() -> Self {
            ErrorType::ASSERTION
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ErrorType {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl ErrorType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<ErrorType>("ProtoExecutionResult.ErrorType", 3)
        }
    }
}

/// / A proto object representing a pre-hook failure.
/// / Used to hold failure information for before_suite, before_spec, before_scenario and before_spec hooks.
#[derive(PartialEq,Clone,Default)]
pub struct ProtoHookFailure {
    // message fields
    /// / Stacktrace from the failure
    stackTrace: ::std::option::Option<::std::string::String>,
    /// / Error message from the failure
    errorMessage: ::std::option::Option<::std::string::String>,
    /// / Byte array holding the screenshot taken at the time of failure.
    screenShot: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoHookFailure {
    fn default() -> &'a ProtoHookFailure {
        <ProtoHookFailure as ::protobuf::Message>::default_instance()
    }
}

impl ProtoHookFailure {
    pub fn new() -> ProtoHookFailure {
        ::std::default::Default::default()
    }

    // required string stackTrace = 1;

    pub fn get_stackTrace(&self) -> &str {
        match self.stackTrace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stackTrace(&mut self) {
        self.stackTrace = ::std::option::Option::None;
    }

    pub fn has_stackTrace(&self) -> bool {
        self.stackTrace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stackTrace(&mut self, v: ::std::string::String) {
        self.stackTrace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stackTrace(&mut self) -> &mut ::std::string::String {
        if self.stackTrace.is_none() {
            self.stackTrace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stackTrace.as_mut().unwrap()
    }

    // Take field
    pub fn take_stackTrace(&mut self) -> ::std::string::String {
        self.stackTrace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string errorMessage = 2;

    pub fn get_errorMessage(&self) -> &str {
        match self.errorMessage.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_errorMessage(&mut self) {
        self.errorMessage = ::std::option::Option::None;
    }

    pub fn has_errorMessage(&self) -> bool {
        self.errorMessage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorMessage(&mut self, v: ::std::string::String) {
        self.errorMessage = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorMessage(&mut self) -> &mut ::std::string::String {
        if self.errorMessage.is_none() {
            self.errorMessage = ::std::option::Option::Some(::std::string::String::new());
        }
        self.errorMessage.as_mut().unwrap()
    }

    // Take field
    pub fn take_errorMessage(&mut self) -> ::std::string::String {
        self.errorMessage.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes screenShot = 3;

    pub fn get_screenShot(&self) -> &[u8] {
        match self.screenShot.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_screenShot(&mut self) {
        self.screenShot = ::std::option::Option::None;
    }

    pub fn has_screenShot(&self) -> bool {
        self.screenShot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenShot(&mut self, v: ::std::vec::Vec<u8>) {
        self.screenShot = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenShot(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.screenShot.is_none() {
            self.screenShot = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.screenShot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenShot(&mut self) -> ::std::vec::Vec<u8> {
        self.screenShot.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "stackTrace",
            |m: &ProtoHookFailure| { &m.stackTrace },
            |m: &mut ProtoHookFailure| { &mut m.stackTrace },
            ProtoHookFailure::get_stackTrace,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "errorMessage",
            |m: &ProtoHookFailure| { &m.errorMessage },
            |m: &mut ProtoHookFailure| { &mut m.errorMessage },
            ProtoHookFailure::get_errorMessage,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "screenShot",
            |m: &ProtoHookFailure| { &m.screenShot },
            |m: &mut ProtoHookFailure| { &mut m.screenShot },
            ProtoHookFailure::get_screenShot,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoHookFailure>(
            "ProtoHookFailure",
            15,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoHookFailure {
    fn is_initialized(&self) -> bool {
        if self.stackTrace.is_none() {
            return false;
        }
        if self.errorMessage.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stackTrace = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.errorMessage = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.screenShot = ::std::option::Option::Some(is.read_bytes()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stackTrace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.errorMessage.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.screenShot.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stackTrace.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.errorMessage.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.screenShot.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoHookFailure {
        ProtoHookFailure::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 15)
    }

    fn default_instance() -> &'static ProtoHookFailure {
        static instance: ProtoHookFailure = ProtoHookFailure {
            stackTrace: ::std::option::Option::None,
            errorMessage: ::std::option::Option::None,
            screenShot: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoHookFailure {
    fn clear(&mut self) {
        self.stackTrace = ::std::option::Option::None;
        self.errorMessage = ::std::option::Option::None;
        self.screenShot = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoHookFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoHookFailure {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing the result of entire Suite execution.
#[derive(PartialEq,Clone,Default)]
pub struct ProtoSuiteResult {
    // message fields
    /// / Contains the result from the execution
    pub specResults: ::std::vec::Vec<ProtoSpecResult>,
    /// / Contains a 'before' hook failure message. This happens when the `before_suite` hook has an error
    pub preHookFailure: ::protobuf::MessageField<ProtoHookFailure>,
    /// / Contains a 'after' hook failure message. This happens when the `after_suite` hook has an error
    pub postHookFailure: ::protobuf::MessageField<ProtoHookFailure>,
    /// / Flag to indicate failure
    failed: ::std::option::Option<bool>,
    /// / Holds the count of number of Specifications that failed.
    specsFailedCount: ::std::option::Option<i32>,
    /// / Holds the time taken for executing the whole suite.
    executionTime: ::std::option::Option<i64>,
    /// / Holds a metric indicating the success rate of the execution.
    successRate: ::std::option::Option<f32>,
    /// / The environment against which execution was done
    environment: ::std::option::Option<::std::string::String>,
    /// / Tag expression used for filtering specification
    tags: ::std::option::Option<::std::string::String>,
    /// / Project name
    projectName: ::std::option::Option<::std::string::String>,
    /// / Timestamp of when execution started
    timestamp: ::std::option::Option<::std::string::String>,
    specsSkippedCount: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoSuiteResult {
    fn default() -> &'a ProtoSuiteResult {
        <ProtoSuiteResult as ::protobuf::Message>::default_instance()
    }
}

impl ProtoSuiteResult {
    pub fn new() -> ProtoSuiteResult {
        ::std::default::Default::default()
    }

    // required bool failed = 4;

    pub fn get_failed(&self) -> bool {
        self.failed.unwrap_or(false)
    }

    pub fn clear_failed(&mut self) {
        self.failed = ::std::option::Option::None;
    }

    pub fn has_failed(&self) -> bool {
        self.failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed(&mut self, v: bool) {
        self.failed = ::std::option::Option::Some(v);
    }

    // required int32 specsFailedCount = 5;

    pub fn get_specsFailedCount(&self) -> i32 {
        self.specsFailedCount.unwrap_or(0)
    }

    pub fn clear_specsFailedCount(&mut self) {
        self.specsFailedCount = ::std::option::Option::None;
    }

    pub fn has_specsFailedCount(&self) -> bool {
        self.specsFailedCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specsFailedCount(&mut self, v: i32) {
        self.specsFailedCount = ::std::option::Option::Some(v);
    }

    // optional int64 executionTime = 6;

    pub fn get_executionTime(&self) -> i64 {
        self.executionTime.unwrap_or(0)
    }

    pub fn clear_executionTime(&mut self) {
        self.executionTime = ::std::option::Option::None;
    }

    pub fn has_executionTime(&self) -> bool {
        self.executionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionTime(&mut self, v: i64) {
        self.executionTime = ::std::option::Option::Some(v);
    }

    // required float successRate = 7;

    pub fn get_successRate(&self) -> f32 {
        self.successRate.unwrap_or(0.)
    }

    pub fn clear_successRate(&mut self) {
        self.successRate = ::std::option::Option::None;
    }

    pub fn has_successRate(&self) -> bool {
        self.successRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_successRate(&mut self, v: f32) {
        self.successRate = ::std::option::Option::Some(v);
    }

    // optional string environment = 8;

    pub fn get_environment(&self) -> &str {
        match self.environment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_environment(&mut self) {
        self.environment = ::std::option::Option::None;
    }

    pub fn has_environment(&self) -> bool {
        self.environment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_environment(&mut self, v: ::std::string::String) {
        self.environment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_environment(&mut self) -> &mut ::std::string::String {
        if self.environment.is_none() {
            self.environment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.environment.as_mut().unwrap()
    }

    // Take field
    pub fn take_environment(&mut self) -> ::std::string::String {
        self.environment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tags = 9;

    pub fn get_tags(&self) -> &str {
        match self.tags.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tags(&mut self) {
        self.tags = ::std::option::Option::None;
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags(&mut self) -> &mut ::std::string::String {
        if self.tags.is_none() {
            self.tags = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        self.tags.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string projectName = 10;

    pub fn get_projectName(&self) -> &str {
        match self.projectName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_projectName(&mut self) {
        self.projectName = ::std::option::Option::None;
    }

    pub fn has_projectName(&self) -> bool {
        self.projectName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_projectName(&mut self, v: ::std::string::String) {
        self.projectName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_projectName(&mut self) -> &mut ::std::string::String {
        if self.projectName.is_none() {
            self.projectName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.projectName.as_mut().unwrap()
    }

    // Take field
    pub fn take_projectName(&mut self) -> ::std::string::String {
        self.projectName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string timestamp = 11;

    pub fn get_timestamp(&self) -> &str {
        match self.timestamp.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::string::String) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp(&mut self) -> &mut ::std::string::String {
        if self.timestamp.is_none() {
            self.timestamp = ::std::option::Option::Some(::std::string::String::new());
        }
        self.timestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::std::string::String {
        self.timestamp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 specsSkippedCount = 12;

    pub fn get_specsSkippedCount(&self) -> i32 {
        self.specsSkippedCount.unwrap_or(0)
    }

    pub fn clear_specsSkippedCount(&mut self) {
        self.specsSkippedCount = ::std::option::Option::None;
    }

    pub fn has_specsSkippedCount(&self) -> bool {
        self.specsSkippedCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specsSkippedCount(&mut self, v: i32) {
        self.specsSkippedCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "specResults",
            |m: &ProtoSuiteResult| { &m.specResults },
            |m: &mut ProtoSuiteResult| { &mut m.specResults },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoHookFailure>(
            "preHookFailure",
            |m: &ProtoSuiteResult| { &m.preHookFailure },
            |m: &mut ProtoSuiteResult| { &mut m.preHookFailure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoHookFailure>(
            "postHookFailure",
            |m: &ProtoSuiteResult| { &m.postHookFailure },
            |m: &mut ProtoSuiteResult| { &mut m.postHookFailure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "failed",
            |m: &ProtoSuiteResult| { &m.failed },
            |m: &mut ProtoSuiteResult| { &mut m.failed },
            ProtoSuiteResult::get_failed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "specsFailedCount",
            |m: &ProtoSuiteResult| { &m.specsFailedCount },
            |m: &mut ProtoSuiteResult| { &mut m.specsFailedCount },
            ProtoSuiteResult::get_specsFailedCount,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "executionTime",
            |m: &ProtoSuiteResult| { &m.executionTime },
            |m: &mut ProtoSuiteResult| { &mut m.executionTime },
            ProtoSuiteResult::get_executionTime,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "successRate",
            |m: &ProtoSuiteResult| { &m.successRate },
            |m: &mut ProtoSuiteResult| { &mut m.successRate },
            ProtoSuiteResult::get_successRate,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "environment",
            |m: &ProtoSuiteResult| { &m.environment },
            |m: &mut ProtoSuiteResult| { &mut m.environment },
            ProtoSuiteResult::get_environment,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "tags",
            |m: &ProtoSuiteResult| { &m.tags },
            |m: &mut ProtoSuiteResult| { &mut m.tags },
            ProtoSuiteResult::get_tags,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "projectName",
            |m: &ProtoSuiteResult| { &m.projectName },
            |m: &mut ProtoSuiteResult| { &mut m.projectName },
            ProtoSuiteResult::get_projectName,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "timestamp",
            |m: &ProtoSuiteResult| { &m.timestamp },
            |m: &mut ProtoSuiteResult| { &mut m.timestamp },
            ProtoSuiteResult::get_timestamp,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "specsSkippedCount",
            |m: &ProtoSuiteResult| { &m.specsSkippedCount },
            |m: &mut ProtoSuiteResult| { &mut m.specsSkippedCount },
            ProtoSuiteResult::get_specsSkippedCount,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoSuiteResult>(
            "ProtoSuiteResult",
            16,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoSuiteResult {
    fn is_initialized(&self) -> bool {
        if self.failed.is_none() {
            return false;
        }
        if self.specsFailedCount.is_none() {
            return false;
        }
        if self.successRate.is_none() {
            return false;
        }
        if self.projectName.is_none() {
            return false;
        }
        if self.timestamp.is_none() {
            return false;
        }
        if self.specsSkippedCount.is_none() {
            return false;
        }
        for v in &self.specResults {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preHookFailure {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postHookFailure {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.specResults)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.preHookFailure)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.postHookFailure)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.failed = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.specsFailedCount = ::std::option::Option::Some(is.read_int32()?);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.executionTime = ::std::option::Option::Some(is.read_int64()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.successRate = ::std::option::Option::Some(is.read_float()?);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.environment = ::std::option::Option::Some(is.read_string()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.tags = ::std::option::Option::Some(is.read_string()?);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.projectName = ::std::option::Option::Some(is.read_string()?);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.timestamp = ::std::option::Option::Some(is.read_string()?);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.specsSkippedCount = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.specResults {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.preHookFailure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.postHookFailure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.failed {
            my_size += 2;
        }
        if let Some(v) = self.specsFailedCount {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.executionTime {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.successRate {
            my_size += 5;
        }
        if let Some(v) = self.environment.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.tags.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.projectName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.timestamp.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.specsSkippedCount {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.specResults {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.preHookFailure.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.postHookFailure.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.failed {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.specsFailedCount {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.executionTime {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.successRate {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.environment.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.tags.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.projectName.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.specsSkippedCount {
            os.write_int32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoSuiteResult {
        ProtoSuiteResult::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 16)
    }

    fn default_instance() -> &'static ProtoSuiteResult {
        static instance: ProtoSuiteResult = ProtoSuiteResult {
            specResults: ::std::vec::Vec::new(),
            preHookFailure: ::protobuf::MessageField::none(),
            postHookFailure: ::protobuf::MessageField::none(),
            failed: ::std::option::Option::None,
            specsFailedCount: ::std::option::Option::None,
            executionTime: ::std::option::Option::None,
            successRate: ::std::option::Option::None,
            environment: ::std::option::Option::None,
            tags: ::std::option::Option::None,
            projectName: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            specsSkippedCount: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoSuiteResult {
    fn clear(&mut self) {
        self.specResults.clear();
        self.preHookFailure.clear();
        self.postHookFailure.clear();
        self.failed = ::std::option::Option::None;
        self.specsFailedCount = ::std::option::Option::None;
        self.executionTime = ::std::option::Option::None;
        self.successRate = ::std::option::Option::None;
        self.environment = ::std::option::Option::None;
        self.tags = ::std::option::Option::None;
        self.projectName = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.specsSkippedCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoSuiteResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoSuiteResult {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing the result of Spec execution.
#[derive(PartialEq,Clone,Default)]
pub struct ProtoSpecResult {
    // message fields
    /// / Represents the corresponding Specification
    pub protoSpec: ::protobuf::MessageField<ProtoSpec>,
    /// / Holds the number of Scenarios executed
    scenarioCount: ::std::option::Option<i32>,
    /// / Holds the number of Scenarios failed
    scenarioFailedCount: ::std::option::Option<i32>,
    /// / Flag to indicate failure
    failed: ::std::option::Option<bool>,
    /// / Holds the row numbers, which caused the execution to fail.
    pub failedDataTableRows: ::std::vec::Vec<i32>,
    /// / Holds the time taken for executing the spec.
    executionTime: ::std::option::Option<i64>,
    skipped: ::std::option::Option<bool>,
    scenarioSkippedCount: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoSpecResult {
    fn default() -> &'a ProtoSpecResult {
        <ProtoSpecResult as ::protobuf::Message>::default_instance()
    }
}

impl ProtoSpecResult {
    pub fn new() -> ProtoSpecResult {
        ::std::default::Default::default()
    }

    // required int32 scenarioCount = 2;

    pub fn get_scenarioCount(&self) -> i32 {
        self.scenarioCount.unwrap_or(0)
    }

    pub fn clear_scenarioCount(&mut self) {
        self.scenarioCount = ::std::option::Option::None;
    }

    pub fn has_scenarioCount(&self) -> bool {
        self.scenarioCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scenarioCount(&mut self, v: i32) {
        self.scenarioCount = ::std::option::Option::Some(v);
    }

    // required int32 scenarioFailedCount = 3;

    pub fn get_scenarioFailedCount(&self) -> i32 {
        self.scenarioFailedCount.unwrap_or(0)
    }

    pub fn clear_scenarioFailedCount(&mut self) {
        self.scenarioFailedCount = ::std::option::Option::None;
    }

    pub fn has_scenarioFailedCount(&self) -> bool {
        self.scenarioFailedCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scenarioFailedCount(&mut self, v: i32) {
        self.scenarioFailedCount = ::std::option::Option::Some(v);
    }

    // required bool failed = 4;

    pub fn get_failed(&self) -> bool {
        self.failed.unwrap_or(false)
    }

    pub fn clear_failed(&mut self) {
        self.failed = ::std::option::Option::None;
    }

    pub fn has_failed(&self) -> bool {
        self.failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed(&mut self, v: bool) {
        self.failed = ::std::option::Option::Some(v);
    }

    // optional int64 executionTime = 6;

    pub fn get_executionTime(&self) -> i64 {
        self.executionTime.unwrap_or(0)
    }

    pub fn clear_executionTime(&mut self) {
        self.executionTime = ::std::option::Option::None;
    }

    pub fn has_executionTime(&self) -> bool {
        self.executionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionTime(&mut self, v: i64) {
        self.executionTime = ::std::option::Option::Some(v);
    }

    // required bool skipped = 7;

    pub fn get_skipped(&self) -> bool {
        self.skipped.unwrap_or(false)
    }

    pub fn clear_skipped(&mut self) {
        self.skipped = ::std::option::Option::None;
    }

    pub fn has_skipped(&self) -> bool {
        self.skipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skipped(&mut self, v: bool) {
        self.skipped = ::std::option::Option::Some(v);
    }

    // required int32 scenarioSkippedCount = 9;

    pub fn get_scenarioSkippedCount(&self) -> i32 {
        self.scenarioSkippedCount.unwrap_or(0)
    }

    pub fn clear_scenarioSkippedCount(&mut self) {
        self.scenarioSkippedCount = ::std::option::Option::None;
    }

    pub fn has_scenarioSkippedCount(&self) -> bool {
        self.scenarioSkippedCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scenarioSkippedCount(&mut self, v: i32) {
        self.scenarioSkippedCount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoSpec>(
            "protoSpec",
            |m: &ProtoSpecResult| { &m.protoSpec },
            |m: &mut ProtoSpecResult| { &mut m.protoSpec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "scenarioCount",
            |m: &ProtoSpecResult| { &m.scenarioCount },
            |m: &mut ProtoSpecResult| { &mut m.scenarioCount },
            ProtoSpecResult::get_scenarioCount,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "scenarioFailedCount",
            |m: &ProtoSpecResult| { &m.scenarioFailedCount },
            |m: &mut ProtoSpecResult| { &mut m.scenarioFailedCount },
            ProtoSpecResult::get_scenarioFailedCount,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "failed",
            |m: &ProtoSpecResult| { &m.failed },
            |m: &mut ProtoSpecResult| { &mut m.failed },
            ProtoSpecResult::get_failed,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failedDataTableRows",
            |m: &ProtoSpecResult| { &m.failedDataTableRows },
            |m: &mut ProtoSpecResult| { &mut m.failedDataTableRows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "executionTime",
            |m: &ProtoSpecResult| { &m.executionTime },
            |m: &mut ProtoSpecResult| { &mut m.executionTime },
            ProtoSpecResult::get_executionTime,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "skipped",
            |m: &ProtoSpecResult| { &m.skipped },
            |m: &mut ProtoSpecResult| { &mut m.skipped },
            ProtoSpecResult::get_skipped,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "scenarioSkippedCount",
            |m: &ProtoSpecResult| { &m.scenarioSkippedCount },
            |m: &mut ProtoSpecResult| { &mut m.scenarioSkippedCount },
            ProtoSpecResult::get_scenarioSkippedCount,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoSpecResult>(
            "ProtoSpecResult",
            17,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoSpecResult {
    fn is_initialized(&self) -> bool {
        if self.protoSpec.is_none() {
            return false;
        }
        if self.scenarioCount.is_none() {
            return false;
        }
        if self.scenarioFailedCount.is_none() {
            return false;
        }
        if self.failed.is_none() {
            return false;
        }
        if self.skipped.is_none() {
            return false;
        }
        if self.scenarioSkippedCount.is_none() {
            return false;
        }
        for v in &self.protoSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.protoSpec)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scenarioCount = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scenarioFailedCount = ::std::option::Option::Some(is.read_int32()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.failed = ::std::option::Option::Some(is.read_bool()?);
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.failedDataTableRows)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.executionTime = ::std::option::Option::Some(is.read_int64()?);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.skipped = ::std::option::Option::Some(is.read_bool()?);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scenarioSkippedCount = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.protoSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.scenarioCount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scenarioFailedCount {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.failed {
            my_size += 2;
        }
        for value in &self.failedDataTableRows {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.executionTime {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.skipped {
            my_size += 2;
        }
        if let Some(v) = self.scenarioSkippedCount {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protoSpec.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.scenarioCount {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.scenarioFailedCount {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.failed {
            os.write_bool(4, v)?;
        }
        for v in &self.failedDataTableRows {
            os.write_int32(5, *v)?;
        };
        if let Some(v) = self.executionTime {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.skipped {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.scenarioSkippedCount {
            os.write_int32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoSpecResult {
        ProtoSpecResult::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 17)
    }

    fn default_instance() -> &'static ProtoSpecResult {
        static instance: ProtoSpecResult = ProtoSpecResult {
            protoSpec: ::protobuf::MessageField::none(),
            scenarioCount: ::std::option::Option::None,
            scenarioFailedCount: ::std::option::Option::None,
            failed: ::std::option::Option::None,
            failedDataTableRows: ::std::vec::Vec::new(),
            executionTime: ::std::option::Option::None,
            skipped: ::std::option::Option::None,
            scenarioSkippedCount: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoSpecResult {
    fn clear(&mut self) {
        self.protoSpec.clear();
        self.scenarioCount = ::std::option::Option::None;
        self.scenarioFailedCount = ::std::option::Option::None;
        self.failed = ::std::option::Option::None;
        self.failedDataTableRows.clear();
        self.executionTime = ::std::option::Option::None;
        self.skipped = ::std::option::Option::None;
        self.scenarioSkippedCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoSpecResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoSpecResult {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A proto object representing a Step value.
#[derive(PartialEq,Clone,Default)]
pub struct ProtoStepValue {
    // message fields
    /// / The actual string value describing he Step
    stepValue: ::std::option::Option<::std::string::String>,
    /// / The parameterized string value describing he Step. The parameters are replaced with placeholders.
    parameterizedStepValue: ::std::option::Option<::std::string::String>,
    /// / A collection of strings representing the parameters.
    pub parameters: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProtoStepValue {
    fn default() -> &'a ProtoStepValue {
        <ProtoStepValue as ::protobuf::Message>::default_instance()
    }
}

impl ProtoStepValue {
    pub fn new() -> ProtoStepValue {
        ::std::default::Default::default()
    }

    // required string stepValue = 1;

    pub fn get_stepValue(&self) -> &str {
        match self.stepValue.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stepValue(&mut self) {
        self.stepValue = ::std::option::Option::None;
    }

    pub fn has_stepValue(&self) -> bool {
        self.stepValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stepValue(&mut self, v: ::std::string::String) {
        self.stepValue = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stepValue(&mut self) -> &mut ::std::string::String {
        if self.stepValue.is_none() {
            self.stepValue = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stepValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_stepValue(&mut self) -> ::std::string::String {
        self.stepValue.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string parameterizedStepValue = 2;

    pub fn get_parameterizedStepValue(&self) -> &str {
        match self.parameterizedStepValue.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parameterizedStepValue(&mut self) {
        self.parameterizedStepValue = ::std::option::Option::None;
    }

    pub fn has_parameterizedStepValue(&self) -> bool {
        self.parameterizedStepValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameterizedStepValue(&mut self, v: ::std::string::String) {
        self.parameterizedStepValue = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameterizedStepValue(&mut self) -> &mut ::std::string::String {
        if self.parameterizedStepValue.is_none() {
            self.parameterizedStepValue = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parameterizedStepValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameterizedStepValue(&mut self) -> ::std::string::String {
        self.parameterizedStepValue.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "stepValue",
            |m: &ProtoStepValue| { &m.stepValue },
            |m: &mut ProtoStepValue| { &mut m.stepValue },
            ProtoStepValue::get_stepValue,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "parameterizedStepValue",
            |m: &ProtoStepValue| { &m.parameterizedStepValue },
            |m: &mut ProtoStepValue| { &mut m.parameterizedStepValue },
            ProtoStepValue::get_parameterizedStepValue,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "parameters",
            |m: &ProtoStepValue| { &m.parameters },
            |m: &mut ProtoStepValue| { &mut m.parameters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoStepValue>(
            "ProtoStepValue",
            18,
            fields,
        )
    }
}

impl ::protobuf::Message for ProtoStepValue {
    fn is_initialized(&self) -> bool {
        if self.stepValue.is_none() {
            return false;
        }
        if self.parameterizedStepValue.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stepValue = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameterizedStepValue = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.parameters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stepValue.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.parameterizedStepValue.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.parameters {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stepValue.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.parameterizedStepValue.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.parameters {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ProtoStepValue {
        ProtoStepValue::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 18)
    }

    fn default_instance() -> &'static ProtoStepValue {
        static instance: ProtoStepValue = ProtoStepValue {
            stepValue: ::std::option::Option::None,
            parameterizedStepValue: ::std::option::Option::None,
            parameters: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ProtoStepValue {
    fn clear(&mut self) {
        self.stepValue = ::std::option::Option::None;
        self.parameterizedStepValue = ::std::option::Option::None;
        self.parameters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProtoStepValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoStepValue {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nspec.proto\x12\x0egauge.messages\"\xca\x02\n\tProtoSpec\x12\x20\n\
    \x0bspecHeading\x18\x01\x20\x02(\tR\x0bspecHeading\x12/\n\x05items\x18\
    \x02\x20\x03(\x0b2\x19.gauge.messages.ProtoItemR\x05items\x12$\n\risTabl\
    eDriven\x18\x03\x20\x02(\x08R\risTableDriven\x12H\n\x0epreHookFailure\
    \x18\x04\x20\x01(\x0b2\x20.gauge.messages.ProtoHookFailureR\x0epreHookFa\
    ilure\x12J\n\x0fpostHookFailure\x18\x05\x20\x01(\x0b2\x20.gauge.messages\
    .ProtoHookFailureR\x0fpostHookFailure\x12\x1a\n\x08fileName\x18\x06\x20\
    \x02(\tR\x08fileName\x12\x12\n\x04tags\x18\x07\x20\x03(\tR\x04tags\"\xce\
    \x04\n\tProtoItem\x12>\n\x08itemType\x18\x01\x20\x02(\x0e2\".gauge.messa\
    ges.ProtoItem.ItemTypeR\x08itemType\x12-\n\x04step\x18\x02\x20\x01(\x0b2\
    \x19.gauge.messages.ProtoStepR\x04step\x126\n\x07concept\x18\x03\x20\x01\
    (\x0b2\x1c.gauge.messages.ProtoConceptR\x07concept\x129\n\x08scenario\
    \x18\x04\x20\x01(\x0b2\x1d.gauge.messages.ProtoScenarioR\x08scenario\x12\
    Z\n\x13tableDrivenScenario\x18\x05\x20\x01(\x0b2(.gauge.messages.ProtoTa\
    bleDrivenScenarioR\x13tableDrivenScenario\x126\n\x07comment\x18\x06\x20\
    \x01(\x0b2\x1c.gauge.messages.ProtoCommentR\x07comment\x120\n\x05table\
    \x18\x07\x20\x01(\x0b2\x1a.gauge.messages.ProtoTableR\x05table\x12-\n\
    \x04tags\x18\x08\x20\x01(\x0b2\x19.gauge.messages.ProtoTagsR\x04tags\"j\
    \n\x08ItemType\x12\x08\n\x04Step\x10\x01\x12\x0b\n\x07Comment\x10\x02\
    \x12\x0b\n\x07Concept\x10\x03\x12\x0c\n\x08Scenario\x10\x04\x12\x17\n\
    \x13TableDrivenScenario\x10\x05\x12\t\n\x05Table\x10\x06\x12\x08\n\x04Ta\
    gs\x10\x07\"\xce\x04\n\rProtoScenario\x12(\n\x0fscenarioHeading\x18\x01\
    \x20\x02(\tR\x0fscenarioHeading\x12\x16\n\x06failed\x18\x02\x20\x02(\x08\
    R\x06failed\x125\n\x08contexts\x18\x03\x20\x03(\x0b2\x19.gauge.messages.\
    ProtoItemR\x08contexts\x12?\n\rscenarioItems\x18\x04\x20\x03(\x0b2\x19.g\
    auge.messages.ProtoItemR\rscenarioItems\x12H\n\x0epreHookFailure\x18\x05\
    \x20\x01(\x0b2\x20.gauge.messages.ProtoHookFailureR\x0epreHookFailure\
    \x12J\n\x0fpostHookFailure\x18\x06\x20\x01(\x0b2\x20.gauge.messages.Prot\
    oHookFailureR\x0fpostHookFailure\x12\x12\n\x04tags\x18\x07\x20\x03(\tR\
    \x04tags\x12$\n\rexecutionTime\x18\x08\x20\x01(\x03R\rexecutionTime\x12\
    \x18\n\x07skipped\x18\t\x20\x02(\x08R\x07skipped\x12\x1e\n\nskipErrors\
    \x18\n\x20\x03(\tR\nskipErrors\x12\x0e\n\x02ID\x18\x0b\x20\x01(\tR\x02ID\
    \x12?\n\rtearDownSteps\x18\x0c\x20\x03(\x0b2\x19.gauge.messages.ProtoIte\
    mR\rtearDownSteps\x12(\n\x04span\x18\r\x20\x01(\x0b2\x14.gauge.messages.\
    SpanR\x04span\".\n\x04Span\x12\x14\n\x05start\x18\x01\x20\x02(\x03R\x05s\
    tart\x12\x10\n\x03end\x18\x02\x20\x02(\x03R\x03end\"W\n\x18ProtoTableDri\
    venScenario\x12;\n\tscenarios\x18\x01\x20\x03(\x0b2\x1d.gauge.messages.P\
    rotoScenarioR\tscenarios\"\xdf\x01\n\tProtoStep\x12\x1e\n\nactualText\
    \x18\x01\x20\x02(\tR\nactualText\x12\x1e\n\nparsedText\x18\x02\x20\x02(\
    \tR\nparsedText\x126\n\tfragments\x18\x03\x20\x03(\x0b2\x18.gauge.messag\
    es.FragmentR\tfragments\x12Z\n\x13stepExecutionResult\x18\x04\x20\x01(\
    \x0b2(.gauge.messages.ProtoStepExecutionResultR\x13stepExecutionResult\"\
    \xde\x01\n\x0cProtoConcept\x12;\n\x0bconceptStep\x18\x01\x20\x02(\x0b2\
    \x19.gauge.messages.ProtoStepR\x0bconceptStep\x12/\n\x05steps\x18\x02\
    \x20\x03(\x0b2\x19.gauge.messages.ProtoItemR\x05steps\x12`\n\x16conceptE\
    xecutionResult\x18\x03\x20\x01(\x0b2(.gauge.messages.ProtoStepExecutionR\
    esultR\x16conceptExecutionResult\"\x1f\n\tProtoTags\x12\x12\n\x04tags\
    \x18\x01\x20\x03(\tR\x04tags\"\xcb\x01\n\x08Fragment\x12I\n\x0cfragmentT\
    ype\x18\x01\x20\x02(\x0e2%.gauge.messages.Fragment.FragmentTypeR\x0cfrag\
    mentType\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\x127\n\tparameter\
    \x18\x03\x20\x01(\x0b2\x19.gauge.messages.ParameterR\tparameter\"'\n\x0c\
    FragmentType\x12\x08\n\x04Text\x10\x01\x12\r\n\tParameter\x10\x02\"\x92\
    \x02\n\tParameter\x12M\n\rparameterType\x18\x01\x20\x02(\x0e2'.gauge.mes\
    sages.Parameter.ParameterTypeR\rparameterType\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x120\
    \n\x05table\x18\x04\x20\x01(\x0b2\x1a.gauge.messages.ProtoTableR\x05tabl\
    e\"Z\n\rParameterType\x12\n\n\x06Static\x10\x01\x12\x0b\n\x07Dynamic\x10\
    \x02\x12\x12\n\x0eSpecial_String\x10\x03\x12\x11\n\rSpecial_Table\x10\
    \x04\x12\t\n\x05Table\x10\x05\"\"\n\x0cProtoComment\x12\x12\n\x04text\
    \x18\x01\x20\x02(\tR\x04text\"x\n\nProtoTable\x127\n\x07headers\x18\x01\
    \x20\x02(\x0b2\x1d.gauge.messages.ProtoTableRowR\x07headers\x121\n\x04ro\
    ws\x18\x02\x20\x03(\x0b2\x1d.gauge.messages.ProtoTableRowR\x04rows\"%\n\
    \rProtoTableRow\x12\x14\n\x05cells\x18\x01\x20\x03(\tR\x05cells\"\xc0\
    \x02\n\x18ProtoStepExecutionResult\x12N\n\x0fexecutionResult\x18\x01\x20\
    \x01(\x0b2$.gauge.messages.ProtoExecutionResultR\x0fexecutionResult\x12H\
    \n\x0epreHookFailure\x18\x02\x20\x01(\x0b2\x20.gauge.messages.ProtoHookF\
    ailureR\x0epreHookFailure\x12J\n\x0fpostHookFailure\x18\x03\x20\x01(\x0b\
    2\x20.gauge.messages.ProtoHookFailureR\x0fpostHookFailure\x12\x18\n\x07s\
    kipped\x18\x04\x20\x02(\x08R\x07skipped\x12$\n\rskippedReason\x18\x05\
    \x20\x01(\tR\rskippedReason\"\x85\x03\n\x14ProtoExecutionResult\x12\x16\
    \n\x06failed\x18\x01\x20\x02(\x08R\x06failed\x12*\n\x10recoverableError\
    \x18\x02\x20\x01(\x08R\x10recoverableError\x12\"\n\x0cerrorMessage\x18\
    \x03\x20\x01(\tR\x0cerrorMessage\x12\x1e\n\nstackTrace\x18\x04\x20\x01(\
    \tR\nstackTrace\x12\x1e\n\nscreenShot\x18\x05\x20\x01(\x0cR\nscreenShot\
    \x12$\n\rexecutionTime\x18\x06\x20\x02(\x03R\rexecutionTime\x12\x18\n\
    \x07message\x18\x07\x20\x03(\tR\x07message\x12W\n\terrorType\x18\x08\x20\
    \x01(\x0e2..gauge.messages.ProtoExecutionResult.ErrorType:\tASSERTIONR\t\
    errorType\",\n\tErrorType\x12\r\n\tASSERTION\x10\x01\x12\x10\n\x0cVERIFI\
    CATION\x10\x02\"v\n\x10ProtoHookFailure\x12\x1e\n\nstackTrace\x18\x01\
    \x20\x02(\tR\nstackTrace\x12\"\n\x0cerrorMessage\x18\x02\x20\x02(\tR\x0c\
    errorMessage\x12\x1e\n\nscreenShot\x18\x03\x20\x01(\x0cR\nscreenShot\"\
    \x9b\x04\n\x10ProtoSuiteResult\x12A\n\x0bspecResults\x18\x01\x20\x03(\
    \x0b2\x1f.gauge.messages.ProtoSpecResultR\x0bspecResults\x12H\n\x0epreHo\
    okFailure\x18\x02\x20\x01(\x0b2\x20.gauge.messages.ProtoHookFailureR\x0e\
    preHookFailure\x12J\n\x0fpostHookFailure\x18\x03\x20\x01(\x0b2\x20.gauge\
    .messages.ProtoHookFailureR\x0fpostHookFailure\x12\x16\n\x06failed\x18\
    \x04\x20\x02(\x08R\x06failed\x12*\n\x10specsFailedCount\x18\x05\x20\x02(\
    \x05R\x10specsFailedCount\x12$\n\rexecutionTime\x18\x06\x20\x01(\x03R\re\
    xecutionTime\x12\x20\n\x0bsuccessRate\x18\x07\x20\x02(\x02R\x0bsuccessRa\
    te\x12\x20\n\x0benvironment\x18\x08\x20\x01(\tR\x0benvironment\x12\x12\n\
    \x04tags\x18\t\x20\x01(\tR\x04tags\x12\x20\n\x0bprojectName\x18\n\x20\
    \x02(\tR\x0bprojectName\x12\x1c\n\ttimestamp\x18\x0b\x20\x02(\tR\ttimest\
    amp\x12,\n\x11specsSkippedCount\x18\x0c\x20\x02(\x05R\x11specsSkippedCou\
    nt\"\xe0\x02\n\x0fProtoSpecResult\x127\n\tprotoSpec\x18\x01\x20\x02(\x0b\
    2\x19.gauge.messages.ProtoSpecR\tprotoSpec\x12$\n\rscenarioCount\x18\x02\
    \x20\x02(\x05R\rscenarioCount\x120\n\x13scenarioFailedCount\x18\x03\x20\
    \x02(\x05R\x13scenarioFailedCount\x12\x16\n\x06failed\x18\x04\x20\x02(\
    \x08R\x06failed\x120\n\x13failedDataTableRows\x18\x05\x20\x03(\x05R\x13f\
    ailedDataTableRows\x12$\n\rexecutionTime\x18\x06\x20\x01(\x03R\rexecutio\
    nTime\x12\x18\n\x07skipped\x18\x07\x20\x02(\x08R\x07skipped\x122\n\x14sc\
    enarioSkippedCount\x18\t\x20\x02(\x05R\x14scenarioSkippedCount\"\x86\x01\
    \n\x0eProtoStepValue\x12\x1c\n\tstepValue\x18\x01\x20\x02(\tR\tstepValue\
    \x126\n\x16parameterizedStepValue\x18\x02\x20\x02(\tR\x16parameterizedSt\
    epValue\x12\x1e\n\nparameters\x18\x03\x20\x03(\tR\nparametersJ\x89|\n\
    \x07\x12\x05\x10\0\xad\x02\x01\n\xc4\x05\n\x01\x0c\x12\x03\x10\0\x12\x1a\
    \x89\x01\x20You\x20should\x20have\x20received\x20a\x20copy\x20of\x20the\
    \x20GNU\x20General\x20Public\x20License\n\x20along\x20with\x20gauge-prot\
    o.\x20\x20If\x20not,\x20see\x20<http://www.gnu.org/licenses/>.\n2#\x20Co\
    pyright\x202015\x20ThoughtWorks,\x20Inc.\n2#\x20This\x20file\x20is\x20pa\
    rt\x20of\x20gauge-proto.\n2\xf3\x01\x20gauge-proto\x20is\x20free\x20soft\
    ware:\x20you\x20can\x20redistribute\x20it\x20and/or\x20modify\n\x20it\
    \x20under\x20the\x20terms\x20of\x20the\x20GNU\x20General\x20Public\x20Li\
    cense\x20as\x20published\x20by\n\x20the\x20Free\x20Software\x20Foundatio\
    n,\x20either\x20version\x203\x20of\x20the\x20License,\x20or\n\x20(at\x20\
    your\x20option)\x20any\x20later\x20version.\n2\xed\x01\x20gauge-proto\
    \x20is\x20distributed\x20in\x20the\x20hope\x20that\x20it\x20will\x20be\
    \x20useful,\n\x20but\x20WITHOUT\x20ANY\x20WARRANTY;\x20without\x20even\
    \x20the\x20implied\x20warranty\x20of\n\x20MERCHANTABILITY\x20or\x20FITNE\
    SS\x20FOR\x20A\x20PARTICULAR\x20PURPOSE.\x20\x20See\x20the\n\x20GNU\x20G\
    eneral\x20Public\x20License\x20for\x20more\x20details.\n\n\x08\n\x01\x02\
    \x12\x03\x11\0\x17\n\xde\x01\n\x02\x04\0\x12\x04\x18\0'\x01\x1aq/\x20A\
    \x20proto\x20object\x20representing\x20a\x20Specification\n/\x20A\x20spe\
    cification\x20can\x20contain\x20Scenarios\x20or\x20Steps,\x20besides\x20\
    Comments\n2_\x20The\x20comments\x20are\x20exported\x20to\x20Markdown,\
    \x20hence\x20they\x20may\x20contain\x20markdown\x20syntax\x20and\x20cros\
    s-refs.\n\n\n\n\x03\x04\0\x01\x12\x03\x18\x08\x11\n4\n\x04\x04\0\x02\0\
    \x12\x03\x1a\x04$\x1a'/\x20Heading\x20describing\x20the\x20Specification\
    \n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x1a\x04\x0c\n\x0c\n\x05\x04\0\x02\
    \0\x05\x12\x03\x1a\r\x13\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1a\x14\x1f\
    \n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x1a\"#\n?\n\x04\x04\0\x02\x01\x12\
    \x03\x1c\x04!\x1a2/\x20A\x20collection\x20of\x20items\x20that\x20come\
    \x20under\x20this\x20step\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x1c\
    \x04\x0c\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03\x1c\r\x16\n\x0c\n\x05\x04\
    \0\x02\x01\x01\x12\x03\x1c\x17\x1c\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\
    \x1c\x1f\x20\n\x9e\x01\n\x04\x04\0\x02\x02\x12\x03\x1e\x04$\x1a\x90\x01/\
    \x20Flag\x20indicating\x20if\x20this\x20is\x20a\x20Table\x20Driven\x20Sp\
    ecification.\x20The\x20table\x20is\x20defined\x20in\x20the\x20context,\
    \x20this\x20is\x20different\x20from\x20using\x20a\x20table\x20parameter.\
    \n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x1e\x04\x0c\n\x0c\n\x05\x04\0\
    \x02\x02\x05\x12\x03\x1e\r\x11\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x1e\
    \x12\x1f\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x1e\"#\np\n\x04\x04\0\x02\
    \x03\x12\x03\x20\x041\x1ac/\x20Contains\x20a\x20'before'\x20hook\x20fail\
    ure\x20message.\x20This\x20happens\x20when\x20the\x20`before_spec`\x20ho\
    ok\x20has\x20an\x20error.\n\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x20\
    \x04\x0c\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x03\x20\r\x1d\n\x0c\n\x05\x04\
    \0\x02\x03\x01\x12\x03\x20\x1e,\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\
    \x20/0\no\n\x04\x04\0\x02\x04\x12\x03\"\x042\x1ab/\x20Contains\x20a\x20'\
    before'\x20hook\x20failure\x20message.\x20This\x20happens\x20when\x20the\
    \x20`after_hook`\x20hook\x20has\x20an\x20error.\n\n\x0c\n\x05\x04\0\x02\
    \x04\x04\x12\x03\"\x04\x0c\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03\"\r\x1d\
    \n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\"\x1e-\n\x0c\n\x05\x04\0\x02\x04\
    \x03\x12\x03\"01\nH\n\x04\x04\0\x02\x05\x12\x03$\x04!\x1a;/\x20Contains\
    \x20the\x20filename\x20for\x20that\x20holds\x20this\x20specification.\n\
    \n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03$\x04\x0c\n\x0c\n\x05\x04\0\x02\
    \x05\x05\x12\x03$\r\x13\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03$\x14\x1c\n\
    \x0c\n\x05\x04\0\x02\x05\x03\x12\x03$\x1f\x20\nx\n\x04\x04\0\x02\x06\x12\
    \x03&\x04\x1d\x1ak/\x20Contains\x20a\x20list\x20of\x20tags\x20that\x20ar\
    e\x20defined\x20at\x20the\x20specification\x20level.\x20Scenario\x20tags\
    \x20are\x20not\x20present\x20here.\n\n\x0c\n\x05\x04\0\x02\x06\x04\x12\
    \x03&\x04\x0c\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03&\r\x13\n\x0c\n\x05\
    \x04\0\x02\x06\x01\x12\x03&\x14\x18\n\x0c\n\x05\x04\0\x02\x06\x03\x12\
    \x03&\x1b\x1c\nC\n\x02\x04\x01\x12\x04+\0F\x01\x1a7/\x20Container\x20for\
    \x20all\x20valid\x20Items\x20under\x20a\x20Specification.\n\n\n\n\x03\
    \x04\x01\x01\x12\x03+\x08\x11\n\xa4\x01\n\x04\x04\x01\x04\0\x12\x04-\x04\
    5\x05\x1a\x95\x01/\x20Enumerates\x20various\x20item\x20types\x20that\x20\
    the\x20proto\x20item\x20can\x20contain.\x20Valid\x20types\x20are:\x20Ste\
    p,\x20Comment,\x20Concept,\x20Scenario,\x20TableDrivenScenario,\x20Table\
    ,\x20Tags\n\n\x0c\n\x05\x04\x01\x04\0\x01\x12\x03-\t\x11\n\x1f\n\x06\x04\
    \x01\x04\0\x02\0\x12\x03.\x08\x11\"\x10\x20Item\x20is\x20a\x20Step\n\n\
    \x0e\n\x07\x04\x01\x04\0\x02\0\x01\x12\x03.\x08\x0c\n\x0e\n\x07\x04\x01\
    \x04\0\x02\0\x02\x12\x03.\x0f\x10\n\"\n\x06\x04\x01\x04\0\x02\x01\x12\
    \x03/\x08\x14\"\x13\x20Item\x20is\x20a\x20Comment\n\n\x0e\n\x07\x04\x01\
    \x04\0\x02\x01\x01\x12\x03/\x08\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\x01\
    \x02\x12\x03/\x12\x13\n\"\n\x06\x04\x01\x04\0\x02\x02\x12\x030\x08\x14\"\
    \x13\x20Item\x20is\x20a\x20Concept\n\n\x0e\n\x07\x04\x01\x04\0\x02\x02\
    \x01\x12\x030\x08\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\x02\x02\x12\x030\x12\
    \x13\n#\n\x06\x04\x01\x04\0\x02\x03\x12\x031\x08\x15\"\x14\x20Item\x20is\
    \x20a\x20Scenario\n\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x01\x12\x031\x08\
    \x10\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x02\x12\x031\x13\x14\n{\n\x06\x04\
    \x01\x04\0\x02\x04\x12\x032\x08\x20\"l\x20Item\x20is\x20a\x20TableDriven\
    Scenario,\x20a\x20special\x20case\x20of\x20Scenario,\x20where\x20there\
    \x20is\x20a\x20Context\x20Step\x20defining\x20a\x20table.\n\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x04\x01\x12\x032\x08\x1b\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x04\x02\x12\x032\x1e\x1f\n\x20\n\x06\x04\x01\x04\0\x02\x05\x12\x033\
    \x08\x12\"\x11\x20Item\x20is\x20a\x20Table\n\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x05\x01\x12\x033\x08\r\n\x0e\n\x07\x04\x01\x04\0\x02\x05\x02\x12\
    \x033\x10\x11\n\x1e\n\x06\x04\x01\x04\0\x02\x06\x12\x034\x08\x11\"\x0f\
    \x20Item\x20is\x20a\x20Tag\n\n\x0e\n\x07\x04\x01\x04\0\x02\x06\x01\x12\
    \x034\x08\x0c\n\x0e\n\x07\x04\x01\x04\0\x02\x06\x02\x12\x034\x0f\x10\n1\
    \n\x04\x04\x01\x02\0\x12\x037\x04#\x1a$/\x20Itemtype\x20of\x20the\x20cur\
    rent\x20ProtoItem\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x037\x04\x0c\n\x0c\
    \n\x05\x04\x01\x02\0\x06\x12\x037\r\x15\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x037\x16\x1e\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x037!\"\nH\n\x04\x04\
    \x01\x02\x01\x12\x039\x04\x20\x1a;/\x20Holds\x20the\x20Step\x20definitio\
    n.\x20Valid\x20only\x20if\x20ItemType\x20=\x20Step\n\n\x0c\n\x05\x04\x01\
    \x02\x01\x04\x12\x039\x04\x0c\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x039\r\
    \x16\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x039\x17\x1b\n\x0c\n\x05\x04\
    \x01\x02\x01\x03\x12\x039\x1e\x1f\nN\n\x04\x04\x01\x02\x02\x12\x03;\x04&\
    \x1aA/\x20Holds\x20the\x20Concept\x20definition.\x20Valid\x20only\x20if\
    \x20ItemType\x20=\x20Concept\n\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03;\
    \x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03;\r\x19\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03;\x1a!\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03;$\
    %\nP\n\x04\x04\x01\x02\x03\x12\x03=\x04(\x1aC/\x20Holds\x20the\x20Scenar\
    io\x20definition.\x20Valid\x20only\x20if\x20ItemType\x20=\x20Scenario\n\
    \n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03=\x04\x0c\n\x0c\n\x05\x04\x01\
    \x02\x03\x06\x12\x03=\r\x1a\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03=\x1b\
    #\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03=&'\nf\n\x04\x04\x01\x02\x04\
    \x12\x03?\x04>\x1aY/\x20Holds\x20the\x20TableDrivenScenario\x20definitio\
    n.\x20Valid\x20only\x20if\x20ItemType\x20=\x20TableDrivenScenario\n\n\
    \x0c\n\x05\x04\x01\x02\x04\x04\x12\x03?\x04\x0c\n\x0c\n\x05\x04\x01\x02\
    \x04\x06\x12\x03?\r%\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03?&9\n\x0c\n\
    \x05\x04\x01\x02\x04\x03\x12\x03?<=\nN\n\x04\x04\x01\x02\x05\x12\x03A\
    \x04&\x1aA/\x20Holds\x20the\x20Comment\x20definition.\x20Valid\x20only\
    \x20if\x20ItemType\x20=\x20Comment\n\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\
    \x03A\x04\x0c\n\x0c\n\x05\x04\x01\x02\x05\x06\x12\x03A\r\x19\n\x0c\n\x05\
    \x04\x01\x02\x05\x01\x12\x03A\x1a!\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\
    \x03A$%\nJ\n\x04\x04\x01\x02\x06\x12\x03C\x04\"\x1a=/\x20Holds\x20the\
    \x20Table\x20definition.\x20Valid\x20only\x20if\x20ItemType\x20=\x20Tabl\
    e\n\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\x03C\x04\x0c\n\x0c\n\x05\x04\x01\
    \x02\x06\x06\x12\x03C\r\x17\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03C\x18\
    \x1d\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03C\x20!\nH\n\x04\x04\x01\x02\
    \x07\x12\x03E\x04\x20\x1a;/\x20Holds\x20the\x20Tags\x20definition.\x20Va\
    lid\x20only\x20if\x20ItemType\x20=\x20Tags\n\n\x0c\n\x05\x04\x01\x02\x07\
    \x04\x12\x03E\x04\x0c\n\x0c\n\x05\x04\x01\x02\x07\x06\x12\x03E\r\x16\n\
    \x0c\n\x05\x04\x01\x02\x07\x01\x12\x03E\x17\x1b\n\x0c\n\x05\x04\x01\x02\
    \x07\x03\x12\x03E\x1e\x1f\n5\n\x02\x04\x02\x12\x04I\0b\x01\x1a)/\x20A\
    \x20proto\x20object\x20representing\x20a\x20Scenario\n\n\n\n\x03\x04\x02\
    \x01\x12\x03I\x08\x15\n-\n\x04\x04\x02\x02\0\x12\x03K\x04(\x1a\x20/\x20H\
    eading\x20of\x20the\x20given\x20Scenario\n\n\x0c\n\x05\x04\x02\x02\0\x04\
    \x12\x03K\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03K\r\x13\n\x0c\n\
    \x05\x04\x02\x02\0\x01\x12\x03K\x14#\n\x0c\n\x05\x04\x02\x02\0\x03\x12\
    \x03K&'\nA\n\x04\x04\x02\x02\x01\x12\x03M\x04\x1d\x1a4/\x20Flag\x20to\
    \x20indicate\x20if\x20the\x20Scenario\x20execution\x20failed\n\n\x0c\n\
    \x05\x04\x02\x02\x01\x04\x12\x03M\x04\x0c\n\x0c\n\x05\x04\x02\x02\x01\
    \x05\x12\x03M\r\x11\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03M\x12\x18\n\
    \x0c\n\x05\x04\x02\x02\x01\x03\x12\x03M\x1b\x1c\n]\n\x04\x04\x02\x02\x02\
    \x12\x03O\x04$\x1aP/\x20Collection\x20of\x20Context\x20steps.\x20The\x20\
    Context\x20steps\x20are\x20executed\x20before\x20every\x20run.\n\n\x0c\n\
    \x05\x04\x02\x02\x02\x04\x12\x03O\x04\x0c\n\x0c\n\x05\x04\x02\x02\x02\
    \x06\x12\x03O\r\x16\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03O\x17\x1f\n\
    \x0c\n\x05\x04\x02\x02\x02\x03\x12\x03O\"#\nz\n\x04\x04\x02\x02\x03\x12\
    \x03Q\x04)\x1am/\x20Collection\x20of\x20Items\x20under\x20a\x20scenario.\
    \x20These\x20could\x20be\x20Steps,\x20Comments,\x20Tags,\x20TableDrivenS\
    cenarios\x20or\x20Tables\n\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03Q\x04\
    \x0c\n\x0c\n\x05\x04\x02\x02\x03\x06\x12\x03Q\r\x16\n\x0c\n\x05\x04\x02\
    \x02\x03\x01\x12\x03Q\x17$\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03Q'(\nt\
    \n\x04\x04\x02\x02\x04\x12\x03S\x041\x1ag/\x20Contains\x20a\x20'before'\
    \x20hook\x20failure\x20message.\x20This\x20happens\x20when\x20the\x20`be\
    fore_scenario`\x20hook\x20has\x20an\x20error.\n\n\x0c\n\x05\x04\x02\x02\
    \x04\x04\x12\x03S\x04\x0c\n\x0c\n\x05\x04\x02\x02\x04\x06\x12\x03S\r\x1d\
    \n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03S\x1e,\n\x0c\n\x05\x04\x02\x02\
    \x04\x03\x12\x03S/0\nr\n\x04\x04\x02\x02\x05\x12\x03U\x042\x1ae/\x20Cont\
    ains\x20a\x20'after'\x20hook\x20failure\x20message.\x20This\x20happens\
    \x20when\x20the\x20`after_scenario`\x20hook\x20has\x20an\x20error.\n\n\
    \x0c\n\x05\x04\x02\x02\x05\x04\x12\x03U\x04\x0c\n\x0c\n\x05\x04\x02\x02\
    \x05\x06\x12\x03U\r\x1d\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03U\x1e-\n\
    \x0c\n\x05\x04\x02\x02\x05\x03\x12\x03U01\nx\n\x04\x04\x02\x02\x06\x12\
    \x03W\x04\x1d\x1ak/\x20Contains\x20a\x20list\x20of\x20tags\x20that\x20ar\
    e\x20defined\x20at\x20the\x20specification\x20level.\x20Scenario\x20tags\
    \x20are\x20not\x20present\x20here.\n\n\x0c\n\x05\x04\x02\x02\x06\x04\x12\
    \x03W\x04\x0c\n\x0c\n\x05\x04\x02\x02\x06\x05\x12\x03W\r\x13\n\x0c\n\x05\
    \x04\x02\x02\x06\x01\x12\x03W\x14\x18\n\x0c\n\x05\x04\x02\x02\x06\x03\
    \x12\x03W\x1b\x1c\nA\n\x04\x04\x02\x02\x07\x12\x03Y\x04%\x1a4/\x20Holds\
    \x20the\x20time\x20taken\x20for\x20executing\x20this\x20scenario.\n\n\
    \x0c\n\x05\x04\x02\x02\x07\x04\x12\x03Y\x04\x0c\n\x0c\n\x05\x04\x02\x02\
    \x07\x05\x12\x03Y\r\x12\n\x0c\n\x05\x04\x02\x02\x07\x01\x12\x03Y\x13\x20\
    \n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03Y#$\n\x0b\n\x04\x04\x02\x02\x08\
    \x12\x03Z\x04\x1e\n\x0c\n\x05\x04\x02\x02\x08\x04\x12\x03Z\x04\x0c\n\x0c\
    \n\x05\x04\x02\x02\x08\x05\x12\x03Z\r\x11\n\x0c\n\x05\x04\x02\x02\x08\
    \x01\x12\x03Z\x12\x19\n\x0c\n\x05\x04\x02\x02\x08\x03\x12\x03Z\x1c\x1d\n\
    \x0b\n\x04\x04\x02\x02\t\x12\x03[\x04$\n\x0c\n\x05\x04\x02\x02\t\x04\x12\
    \x03[\x04\x0c\n\x0c\n\x05\x04\x02\x02\t\x05\x12\x03[\r\x13\n\x0c\n\x05\
    \x04\x02\x02\t\x01\x12\x03[\x14\x1e\n\x0c\n\x05\x04\x02\x02\t\x03\x12\
    \x03[!#\n:\n\x04\x04\x02\x02\n\x12\x03]\x04\x1c\x1a-/\x20Holds\x20the\
    \x20unique\x20Identifier\x20of\x20a\x20scenario.\n\n\x0c\n\x05\x04\x02\
    \x02\n\x04\x12\x03]\x04\x0c\n\x0c\n\x05\x04\x02\x02\n\x05\x12\x03]\r\x13\
    \n\x0c\n\x05\x04\x02\x02\n\x01\x12\x03]\x14\x16\n\x0c\n\x05\x04\x02\x02\
    \n\x03\x12\x03]\x19\x1b\n^\n\x04\x04\x02\x02\x0b\x12\x03_\x04*\x1aQ/\x20\
    Collection\x20of\x20Teardown\x20steps.\x20The\x20Teardown\x20steps\x20ar\
    e\x20executed\x20after\x20every\x20run.\n\n\x0c\n\x05\x04\x02\x02\x0b\
    \x04\x12\x03_\x04\x0c\n\x0c\n\x05\x04\x02\x02\x0b\x06\x12\x03_\r\x16\n\
    \x0c\n\x05\x04\x02\x02\x0b\x01\x12\x03_\x17$\n\x0c\n\x05\x04\x02\x02\x0b\
    \x03\x12\x03_')\n,\n\x04\x04\x02\x02\x0c\x12\x03a\x04\x1c\x1a\x1f/\x20Sp\
    an(start,\x20end)\x20of\x20scenario\n\n\x0c\n\x05\x04\x02\x02\x0c\x04\
    \x12\x03a\x04\x0c\n\x0c\n\x05\x04\x02\x02\x0c\x06\x12\x03a\r\x11\n\x0c\n\
    \x05\x04\x02\x02\x0c\x01\x12\x03a\x12\x16\n\x0c\n\x05\x04\x02\x02\x0c\
    \x03\x12\x03a\x19\x1b\n<\n\x02\x04\x03\x12\x04e\0h\x01\x1a0/\x20A\x20pro\
    to\x20object\x20representing\x20a\x20Span\x20of\x20content\n\n\n\n\x03\
    \x04\x03\x01\x12\x03e\x08\x0c\n\x0b\n\x04\x04\x03\x02\0\x12\x03f\x04\x1d\
    \n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03f\x04\x0c\n\x0c\n\x05\x04\x03\x02\
    \0\x05\x12\x03f\r\x12\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03f\x13\x18\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x03f\x1b\x1c\n\x0b\n\x04\x04\x03\x02\
    \x01\x12\x03g\x04\x1b\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03g\x04\x0c\n\
    \x0c\n\x05\x04\x03\x02\x01\x05\x12\x03g\r\x12\n\x0c\n\x05\x04\x03\x02\
    \x01\x01\x12\x03g\x13\x16\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03g\x19\
    \x1a\n@\n\x02\x04\x04\x12\x04k\0n\x01\x1a4/\x20A\x20proto\x20object\x20r\
    epresenting\x20a\x20TableDrivenScenario\n\n\n\n\x03\x04\x04\x01\x12\x03k\
    \x08\x20\nZ\n\x04\x04\x04\x02\0\x12\x03m\x04)\x1aM/\x20Holds\x20the\x20U\
    nderlying\x20scenario\x20that\x20is\x20executed\x20for\x20every\x20row\
    \x20in\x20the\x20table.\n\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03m\x04\x0c\
    \n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03m\r\x1a\n\x0c\n\x05\x04\x04\x02\0\
    \x01\x12\x03m\x1b$\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03m'(\n1\n\x02\x04\
    \x05\x12\x04q\0z\x01\x1a%/\x20A\x20proto\x20object\x20representing\x20a\
    \x20Step\n\n\n\n\x03\x04\x05\x01\x12\x03q\x08\x11\nv\n\x04\x04\x05\x02\0\
    \x12\x03s\x04#\x1ai/\x20Holds\x20the\x20raw\x20text\x20of\x20the\x20Step\
    \x20as\x20defined\x20in\x20the\x20spec\x20file.\x20This\x20contains\x20t\
    he\x20actual\x20parameter\x20values.\n\n\x0c\n\x05\x04\x05\x02\0\x04\x12\
    \x03s\x04\x0c\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03s\r\x13\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03s\x14\x1e\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03s!\"\ne\n\x04\x04\x05\x02\x01\x12\x03u\x04#\x1aX/\x20Contains\x20the\
    \x20parsed\x20text\x20of\x20the\x20Step.\x20This\x20will\x20have\x20plac\
    eholders\x20for\x20the\x20parameters.\n\n\x0c\n\x05\x04\x05\x02\x01\x04\
    \x12\x03u\x04\x0c\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03u\r\x13\n\x0c\n\
    \x05\x04\x05\x02\x01\x01\x12\x03u\x14\x1e\n\x0c\n\x05\x04\x05\x02\x01\
    \x03\x12\x03u!\"\nk\n\x04\x04\x05\x02\x02\x12\x03w\x04$\x1a^/\x20Collect\
    ion\x20of\x20a\x20list\x20of\x20fragments\x20for\x20a\x20Step.\x20A\x20f\
    ragment\x20could\x20be\x20either\x20text\x20or\x20parameter.\n\n\x0c\n\
    \x05\x04\x05\x02\x02\x04\x12\x03w\x04\x0c\n\x0c\n\x05\x04\x05\x02\x02\
    \x06\x12\x03w\r\x15\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x03w\x16\x1f\n\
    \x0c\n\x05\x04\x05\x02\x02\x03\x12\x03w\"#\n4\n\x04\x04\x05\x02\x03\x12\
    \x03y\x04>\x1a'/\x20Holds\x20the\x20result\x20from\x20the\x20execution.\
    \n\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\x03y\x04\x0c\n\x0c\n\x05\x04\x05\
    \x02\x03\x06\x12\x03y\r%\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03y&9\n\
    \x0c\n\x05\x04\x05\x02\x03\x03\x12\x03y<=\n\xb7\x01\n\x02\x04\x06\x12\
    \x05\x7f\0\x86\x01\x01\x1a\xa9\x01/\x20Concept\x20is\x20a\x20type\x20of\
    \x20step,\x20that\x20can\x20have\x20multiple\x20Steps.\n/\x20But\x20from\
    \x20a\x20caller's\x20perspective,\x20it\x20is\x20still\x20used\x20as\x20\
    any\x20other\x20Step\n/\x20A\x20proto\x20object\x20representing\x20a\x20\
    Concept\n\n\n\n\x03\x04\x06\x01\x12\x03\x7f\x08\x14\n8\n\x04\x04\x06\x02\
    \0\x12\x04\x81\x01\x04'\x1a*/\x20Represents\x20the\x20Step\x20value\x20o\
    f\x20a\x20Concept.\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\x81\x01\x04\x0c\
    \n\r\n\x05\x04\x06\x02\0\x06\x12\x04\x81\x01\r\x16\n\r\n\x05\x04\x06\x02\
    \0\x01\x12\x04\x81\x01\x17\"\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x81\x01\
    %&\n;\n\x04\x04\x06\x02\x01\x12\x04\x83\x01\x04!\x1a-/\x20Collection\x20\
    of\x20Steps\x20in\x20the\x20given\x20concepts.\n\n\r\n\x05\x04\x06\x02\
    \x01\x04\x12\x04\x83\x01\x04\x0c\n\r\n\x05\x04\x06\x02\x01\x06\x12\x04\
    \x83\x01\r\x16\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\x83\x01\x17\x1c\n\r\
    \n\x05\x04\x06\x02\x01\x03\x12\x04\x83\x01\x1f\x20\n,\n\x04\x04\x06\x02\
    \x02\x12\x04\x85\x01\x04A\x1a\x1e/\x20Holds\x20the\x20execution\x20resul\
    t.\n\n\r\n\x05\x04\x06\x02\x02\x04\x12\x04\x85\x01\x04\x0c\n\r\n\x05\x04\
    \x06\x02\x02\x06\x12\x04\x85\x01\r%\n\r\n\x05\x04\x06\x02\x02\x01\x12\
    \x04\x85\x01&<\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\x85\x01?@\n1\n\x02\
    \x04\x07\x12\x06\x89\x01\0\x8c\x01\x01\x1a#/\x20A\x20proto\x20object\x20\
    representing\x20Tags\n\n\x0b\n\x03\x04\x07\x01\x12\x04\x89\x01\x08\x11\n\
    %\n\x04\x04\x07\x02\0\x12\x04\x8b\x01\x04\x1d\x1a\x17/\x20A\x20collectio\
    n\x20of\x20Tags\n\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\x8b\x01\x04\x0c\n\
    \r\n\x05\x04\x07\x02\0\x05\x12\x04\x8b\x01\r\x13\n\r\n\x05\x04\x07\x02\0\
    \x01\x12\x04\x8b\x01\x14\x18\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x8b\x01\
    \x1b\x1c\n_\n\x02\x04\x08\x12\x06\x90\x01\0\x9c\x01\x01\x1aQ/\x20A\x20pr\
    oto\x20object\x20representing\x20Fragment.\n/\x20Fragments,\x20put\x20to\
    gether\x20make\x20up\x20A\x20Step\n\n\x0b\n\x03\x04\x08\x01\x12\x04\x90\
    \x01\x08\x10\n:\n\x04\x04\x08\x04\0\x12\x06\x92\x01\x04\x95\x01\x05\x1a*\
    /\x20Enum\x20representing\x20the\x20types\x20of\x20Fragment\n\n\r\n\x05\
    \x04\x08\x04\0\x01\x12\x04\x92\x01\t\x15\n*\n\x06\x04\x08\x04\0\x02\0\
    \x12\x04\x93\x01\x08\x11\"\x1a/\x20Fragment\x20is\x20a\x20Text\x20part\n\
    \n\x0f\n\x07\x04\x08\x04\0\x02\0\x01\x12\x04\x93\x01\x08\x0c\n\x0f\n\x07\
    \x04\x08\x04\0\x02\0\x02\x12\x04\x93\x01\x0f\x10\n/\n\x06\x04\x08\x04\0\
    \x02\x01\x12\x04\x94\x01\x08\x16\"\x1f/\x20Fragment\x20is\x20a\x20Parame\
    ter\x20part\n\n\x0f\n\x07\x04\x08\x04\0\x02\x01\x01\x12\x04\x94\x01\x08\
    \x11\n\x0f\n\x07\x04\x08\x04\0\x02\x01\x02\x12\x04\x94\x01\x14\x15\nC\n\
    \x04\x04\x08\x02\0\x12\x04\x97\x01\x04+\x1a5/\x20Type\x20of\x20Fragment,\
    \x20valid\x20values\x20are\x20Text,\x20Parameter\n\n\r\n\x05\x04\x08\x02\
    \0\x04\x12\x04\x97\x01\x04\x0c\n\r\n\x05\x04\x08\x02\0\x06\x12\x04\x97\
    \x01\r\x19\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x97\x01\x1a&\n\r\n\x05\
    \x04\x08\x02\0\x03\x12\x04\x97\x01)*\nK\n\x04\x04\x08\x02\x01\x12\x04\
    \x99\x01\x04\x1d\x1a=/\x20Text\x20part\x20of\x20the\x20Fragment,\x20vali\
    d\x20only\x20if\x20FragmentType=Text\n\n\r\n\x05\x04\x08\x02\x01\x04\x12\
    \x04\x99\x01\x04\x0c\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\x99\x01\r\x13\
    \n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\x99\x01\x14\x18\n\r\n\x05\x04\x08\
    \x02\x01\x03\x12\x04\x99\x01\x1b\x1c\nU\n\x04\x04\x08\x02\x02\x12\x04\
    \x9b\x01\x04%\x1aG/\x20Parameter\x20part\x20of\x20the\x20Fragment,\x20va\
    lid\x20only\x20if\x20FragmentType=Parameter\n\n\r\n\x05\x04\x08\x02\x02\
    \x04\x12\x04\x9b\x01\x04\x0c\n\r\n\x05\x04\x08\x02\x02\x06\x12\x04\x9b\
    \x01\r\x16\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\x9b\x01\x17\x20\n\r\n\
    \x05\x04\x08\x02\x02\x03\x12\x04\x9b\x01#$\n6\n\x02\x04\t\x12\x06\x9f\
    \x01\0\xb0\x01\x01\x1a(/\x20A\x20proto\x20object\x20representing\x20Frag\
    ment.\n\n\x0b\n\x03\x04\t\x01\x12\x04\x9f\x01\x08\x11\n8\n\x04\x04\t\x04\
    \0\x12\x06\xa1\x01\x04\xa7\x01\x05\x1a(/\x20Enum\x20representing\x20type\
    s\x20of\x20Parameter.\n\n\r\n\x05\x04\t\x04\0\x01\x12\x04\xa1\x01\t\x16\
    \nV\n\x06\x04\t\x04\0\x02\0\x12\x04\xa2\x01\x08\x13\"F\x20Static\x20para\
    meter.\x20The\x20value\x20of\x20the\x20parameter\x20is\x20defined\x20at\
    \x20the\x20Step.\n\n\x0f\n\x07\x04\t\x04\0\x02\0\x01\x12\x04\xa2\x01\x08\
    \x0e\n\x0f\n\x07\x04\t\x04\0\x02\0\x02\x12\x04\xa2\x01\x11\x12\n\x99\x01\
    \n\x06\x04\t\x04\0\x02\x01\x12\x04\xa3\x01\x08\x14\"\x88\x01\x20Dynamic\
    \x20parameter.\x20This\x20is\x20a\x20parameter\x20placeholder,\x20and\
    \x20the\x20actual\x20value\x20is\x20injected\x20at\x20runtime,\x20depend\
    ing\x20on\x20the\x20context\x20of\x20the\x20call.\n\n\x0f\n\x07\x04\t\
    \x04\0\x02\x01\x01\x12\x04\xa3\x01\x08\x0f\n\x0f\n\x07\x04\t\x04\0\x02\
    \x01\x02\x12\x04\xa3\x01\x12\x13\nb\n\x06\x04\t\x04\0\x02\x02\x12\x04\
    \xa4\x01\x08\x1b\"R\x20Special\x20paramter,\x20taking\x20a\x20string\x20\
    value.\x20Special\x20paramters\x20are\x20read\x20from\x20a\x20file.\n\n\
    \x0f\n\x07\x04\t\x04\0\x02\x02\x01\x12\x04\xa4\x01\x08\x16\n\x0f\n\x07\
    \x04\t\x04\0\x02\x02\x02\x12\x04\xa4\x01\x19\x1a\na\n\x06\x04\t\x04\0\
    \x02\x03\x12\x04\xa5\x01\x08\x1a\"Q\x20Special\x20paramter,\x20taking\
    \x20a\x20Table\x20value.\x20This\x20parameter\x20is\x20read\x20from\x20a\
    \x20csv\x20file.\n\n\x0f\n\x07\x04\t\x04\0\x02\x03\x01\x12\x04\xa5\x01\
    \x08\x15\n\x0f\n\x07\x04\t\x04\0\x02\x03\x02\x12\x04\xa5\x01\x18\x19\nD\
    \n\x06\x04\t\x04\0\x02\x04\x12\x04\xa6\x01\x08\x12\"4\x20A\x20table\x20p\
    arameter,\x20used\x20for\x20data\x20driven\x20execution.\n\n\x0f\n\x07\
    \x04\t\x04\0\x02\x04\x01\x12\x04\xa6\x01\x08\r\n\x0f\n\x07\x04\t\x04\0\
    \x02\x04\x02\x12\x04\xa6\x01\x10\x11\nk\n\x04\x04\t\x02\0\x12\x04\xa9\
    \x01\x04-\x1a]/\x20Type\x20of\x20the\x20Parameter.\x20Valid\x20values:\
    \x20Static,\x20Dynamic,\x20Special_String,\x20Special_Table,\x20Table\n\
    \n\r\n\x05\x04\t\x02\0\x04\x12\x04\xa9\x01\x04\x0c\n\r\n\x05\x04\t\x02\0\
    \x06\x12\x04\xa9\x01\r\x1a\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xa9\x01\x1b\
    (\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xa9\x01+,\n1\n\x04\x04\t\x02\x01\x12\
    \x04\xab\x01\x04\x1e\x1a#/\x20Holds\x20the\x20value\x20of\x20the\x20para\
    meter\n\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xab\x01\x04\x0c\n\r\n\x05\
    \x04\t\x02\x01\x05\x12\x04\xab\x01\r\x13\n\r\n\x05\x04\t\x02\x01\x01\x12\
    \x04\xab\x01\x14\x19\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xab\x01\x1c\x1d\
    \nR\n\x04\x04\t\x02\x02\x12\x04\xad\x01\x04\x1d\x1aD/\x20Holds\x20the\
    \x20name\x20of\x20the\x20parameter,\x20used\x20as\x20Key\x20to\x20lookup\
    \x20the\x20value.\n\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xad\x01\x04\x0c\
    \n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xad\x01\r\x13\n\r\n\x05\x04\t\x02\
    \x02\x01\x12\x04\xad\x01\x14\x18\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xad\
    \x01\x1b\x1c\nO\n\x04\x04\t\x02\x03\x12\x04\xaf\x01\x04\"\x1aA/\x20Holds\
    \x20the\x20table\x20value,\x20if\x20parameterType=Table\x20or\x20Special\
    _Table\n\n\r\n\x05\x04\t\x02\x03\x04\x12\x04\xaf\x01\x04\x0c\n\r\n\x05\
    \x04\t\x02\x03\x06\x12\x04\xaf\x01\r\x17\n\r\n\x05\x04\t\x02\x03\x01\x12\
    \x04\xaf\x01\x18\x1d\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xaf\x01\x20!\n5\
    \n\x02\x04\n\x12\x06\xb3\x01\0\xb6\x01\x01\x1a'/\x20A\x20proto\x20object\
    \x20representing\x20Comment.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xb3\x01\x08\
    \x14\n/\n\x04\x04\n\x02\0\x12\x04\xb5\x01\x04\x1d\x1a!/\x20Text\x20repre\
    senting\x20the\x20Comment.\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xb5\x01\
    \x04\x0c\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xb5\x01\r\x13\n\r\n\x05\x04\n\
    \x02\0\x01\x12\x04\xb5\x01\x14\x18\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xb5\
    \x01\x1b\x1c\n3\n\x02\x04\x0b\x12\x06\xb9\x01\0\xbe\x01\x01\x1a%/\x20A\
    \x20proto\x20object\x20representing\x20Table.\n\n\x0b\n\x03\x04\x0b\x01\
    \x12\x04\xb9\x01\x08\x12\n3\n\x04\x04\x0b\x02\0\x12\x04\xbb\x01\x04'\x1a\
    %/\x20Contains\x20the\x20Headers\x20for\x20the\x20table\n\n\r\n\x05\x04\
    \x0b\x02\0\x04\x12\x04\xbb\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\0\x06\x12\
    \x04\xbb\x01\r\x1a\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xbb\x01\x1b\"\n\r\
    \n\x05\x04\x0b\x02\0\x03\x12\x04\xbb\x01%&\n0\n\x04\x04\x0b\x02\x01\x12\
    \x04\xbd\x01\x04$\x1a\"/\x20Contains\x20the\x20Rows\x20for\x20the\x20tab\
    le\n\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xbd\x01\x04\x0c\n\r\n\x05\x04\
    \x0b\x02\x01\x06\x12\x04\xbd\x01\r\x1a\n\r\n\x05\x04\x0b\x02\x01\x01\x12\
    \x04\xbd\x01\x1b\x1f\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xbd\x01\"#\n3\
    \n\x02\x04\x0c\x12\x06\xc1\x01\0\xc4\x01\x01\x1a%/\x20A\x20proto\x20obje\
    ct\x20representing\x20Table.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xc1\x01\
    \x08\x15\n6\n\x04\x04\x0c\x02\0\x12\x04\xc3\x01\x04\x1e\x1a(/\x20Represe\
    nts\x20the\x20cells\x20of\x20a\x20given\x20table\n\n\r\n\x05\x04\x0c\x02\
    \0\x04\x12\x04\xc3\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xc3\
    \x01\r\x13\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xc3\x01\x14\x19\n\r\n\x05\
    \x04\x0c\x02\0\x03\x12\x04\xc3\x01\x1c\x1d\nB\n\x02\x04\r\x12\x06\xc7\
    \x01\0\xd1\x01\x01\x1a4/\x20A\x20proto\x20object\x20representing\x20Step\
    \x20Execution\x20result\n\n\x0b\n\x03\x04\r\x01\x12\x04\xc7\x01\x08\x20\
    \n3\n\x04\x04\r\x02\0\x12\x04\xc9\x01\x046\x1a%/\x20The\x20actual\x20res\
    ult\x20of\x20the\x20execution\n\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xc9\
    \x01\x04\x0c\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xc9\x01\r!\n\r\n\x05\x04\
    \r\x02\0\x01\x12\x04\xc9\x01\"1\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xc9\
    \x0145\nq\n\x04\x04\r\x02\x01\x12\x04\xcb\x01\x041\x1ac/\x20Contains\x20\
    a\x20'before'\x20hook\x20failure\x20message.\x20This\x20happens\x20when\
    \x20the\x20`before_step`\x20hook\x20has\x20an\x20error.\n\n\r\n\x05\x04\
    \r\x02\x01\x04\x12\x04\xcb\x01\x04\x0c\n\r\n\x05\x04\r\x02\x01\x06\x12\
    \x04\xcb\x01\r\x1d\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xcb\x01\x1e,\n\r\
    \n\x05\x04\r\x02\x01\x03\x12\x04\xcb\x01/0\no\n\x04\x04\r\x02\x02\x12\
    \x04\xcd\x01\x042\x1aa/\x20Contains\x20a\x20'after'\x20hook\x20failure\
    \x20message.\x20This\x20happens\x20when\x20the\x20`after_step`\x20hook\
    \x20has\x20an\x20error.\n\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xcd\x01\
    \x04\x0c\n\r\n\x05\x04\r\x02\x02\x06\x12\x04\xcd\x01\r\x1d\n\r\n\x05\x04\
    \r\x02\x02\x01\x12\x04\xcd\x01\x1e-\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\
    \xcd\x0101\n\x0c\n\x04\x04\r\x02\x03\x12\x04\xcf\x01\x04\x1e\n\r\n\x05\
    \x04\r\x02\x03\x04\x12\x04\xcf\x01\x04\x0c\n\r\n\x05\x04\r\x02\x03\x05\
    \x12\x04\xcf\x01\r\x11\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xcf\x01\x12\
    \x19\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xcf\x01\x1c\x1d\n\x0c\n\x04\x04\
    \r\x02\x04\x12\x04\xd0\x01\x04&\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\xd0\
    \x01\x04\x0c\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xd0\x01\r\x13\n\r\n\x05\
    \x04\r\x02\x04\x01\x12\x04\xd0\x01\x14!\n\r\n\x05\x04\r\x02\x04\x03\x12\
    \x04\xd0\x01$%\nG\n\x02\x04\x0e\x12\x06\xd4\x01\0\xea\x01\x01\x1a9/\x20A\
    \x20proto\x20object\x20representing\x20the\x20result\x20of\x20an\x20exec\
    ution\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xd4\x01\x08\x1c\n)\n\x04\x04\x0e\
    \x02\0\x12\x04\xd6\x01\x04\x1d\x1a\x1b/\x20Flag\x20to\x20indicate\x20fai\
    lure\n\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xd6\x01\x04\x0c\n\r\n\x05\x04\
    \x0e\x02\0\x05\x12\x04\xd6\x01\r\x11\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \xd6\x01\x12\x18\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xd6\x01\x1b\x1c\nC\
    \n\x04\x04\x0e\x02\x01\x12\x04\xd8\x01\x04'\x1a5/\x20Flag\x20to\x20indic\
    ate\x20if\x20the\x20error\x20is\x20recoverable\x20from.\n\n\r\n\x05\x04\
    \x0e\x02\x01\x04\x12\x04\xd8\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x01\x05\
    \x12\x04\xd8\x01\r\x11\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xd8\x01\x12\
    \"\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xd8\x01%&\n*\n\x04\x04\x0e\x02\
    \x02\x12\x04\xda\x01\x04%\x1a\x1c/\x20The\x20actual\x20error\x20message.\
    \n\n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\xda\x01\x04\x0c\n\r\n\x05\x04\
    \x0e\x02\x02\x05\x12\x04\xda\x01\r\x13\n\r\n\x05\x04\x0e\x02\x02\x01\x12\
    \x04\xda\x01\x14\x20\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xda\x01#$\n(\
    \n\x04\x04\x0e\x02\x03\x12\x04\xdc\x01\x04#\x1a\x1a/\x20Stacktrace\x20of\
    \x20the\x20error\n\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xdc\x01\x04\x0c\
    \n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xdc\x01\r\x13\n\r\n\x05\x04\x0e\
    \x02\x03\x01\x12\x04\xdc\x01\x14\x1e\n\r\n\x05\x04\x0e\x02\x03\x03\x12\
    \x04\xdc\x01!\"\nO\n\x04\x04\x0e\x02\x04\x12\x04\xde\x01\x04\"\x1aA/\x20\
    Byte\x20array\x20containing\x20screenshot\x20taken\x20at\x20the\x20time\
    \x20of\x20failure.\n\n\r\n\x05\x04\x0e\x02\x04\x04\x12\x04\xde\x01\x04\
    \x0c\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\xde\x01\r\x12\n\r\n\x05\x04\
    \x0e\x02\x04\x01\x12\x04\xde\x01\x13\x1d\n\r\n\x05\x04\x0e\x02\x04\x03\
    \x12\x04\xde\x01\x20!\nB\n\x04\x04\x0e\x02\x05\x12\x04\xe0\x01\x04%\x1a4\
    /\x20Holds\x20the\x20time\x20taken\x20for\x20executing\x20this\x20scenar\
    io.\n\n\r\n\x05\x04\x0e\x02\x05\x04\x12\x04\xe0\x01\x04\x0c\n\r\n\x05\
    \x04\x0e\x02\x05\x05\x12\x04\xe0\x01\r\x12\n\r\n\x05\x04\x0e\x02\x05\x01\
    \x12\x04\xe0\x01\x13\x20\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\xe0\x01#$\
    \nO\n\x04\x04\x0e\x02\x06\x12\x04\xe2\x01\x04\x20\x1aA/\x20Additional\
    \x20information\x20at\x20exec\x20time\x20to\x20be\x20available\x20on\x20\
    reports\n\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\xe2\x01\x04\x0c\n\r\n\
    \x05\x04\x0e\x02\x06\x05\x12\x04\xe2\x01\r\x13\n\r\n\x05\x04\x0e\x02\x06\
    \x01\x12\x04\xe2\x01\x14\x1b\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\xe2\
    \x01\x1e\x1f\n\x0e\n\x04\x04\x0e\x04\0\x12\x06\xe4\x01\x04\xe7\x01\x05\n\
    \r\n\x05\x04\x0e\x04\0\x01\x12\x04\xe4\x01\t\x12\n\x0e\n\x06\x04\x0e\x04\
    \0\x02\0\x12\x04\xe5\x01\x08\x16\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x01\x12\
    \x04\xe5\x01\x08\x11\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x02\x12\x04\xe5\x01\
    \x14\x15\n\x0e\n\x06\x04\x0e\x04\0\x02\x01\x12\x04\xe6\x01\x08\x19\n\x0f\
    \n\x07\x04\x0e\x04\0\x02\x01\x01\x12\x04\xe6\x01\x08\x14\n\x0f\n\x07\x04\
    \x0e\x04\0\x02\x01\x02\x12\x04\xe6\x01\x17\x18\n]\n\x04\x04\x0e\x02\x07\
    \x12\x04\xe9\x01\x04;\x1aO/\x20Type\x20of\x20the\x20Error.\x20Valid\x20v\
    alues:\x20ASSERTION,\x20VERIFICATION.\x20Default:\x20ASSERTION\n\n\r\n\
    \x05\x04\x0e\x02\x07\x04\x12\x04\xe9\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\
    \x07\x06\x12\x04\xe9\x01\r\x16\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xe9\
    \x01\x17\x20\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\xe9\x01#$\n\r\n\x05\
    \x04\x0e\x02\x07\x08\x12\x04\xe9\x01%:\n\r\n\x05\x04\x0e\x02\x07\x07\x12\
    \x04\xe9\x0109\n\xaa\x01\n\x02\x04\x0f\x12\x06\xee\x01\0\xf5\x01\x01\x1a\
    \x9b\x01/\x20A\x20proto\x20object\x20representing\x20a\x20pre-hook\x20fa\
    ilure.\n/\x20Used\x20to\x20hold\x20failure\x20information\x20for\x20befo\
    re_suite,\x20before_spec,\x20before_scenario\x20and\x20before_spec\x20ho\
    oks.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xee\x01\x08\x18\n,\n\x04\x04\x0f\
    \x02\0\x12\x04\xf0\x01\x04#\x1a\x1e/\x20Stacktrace\x20from\x20the\x20fai\
    lure\n\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xf0\x01\x04\x0c\n\r\n\x05\x04\
    \x0f\x02\0\x05\x12\x04\xf0\x01\r\x13\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\
    \xf0\x01\x14\x1e\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xf0\x01!\"\n/\n\x04\
    \x04\x0f\x02\x01\x12\x04\xf2\x01\x04%\x1a!/\x20Error\x20message\x20from\
    \x20the\x20failure\n\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xf2\x01\x04\
    \x0c\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xf2\x01\r\x13\n\r\n\x05\x04\
    \x0f\x02\x01\x01\x12\x04\xf2\x01\x14\x20\n\r\n\x05\x04\x0f\x02\x01\x03\
    \x12\x04\xf2\x01#$\nP\n\x04\x04\x0f\x02\x02\x12\x04\xf4\x01\x04\"\x1aB/\
    \x20Byte\x20array\x20holding\x20the\x20screenshot\x20taken\x20at\x20the\
    \x20time\x20of\x20failure.\n\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xf4\
    \x01\x04\x0c\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\xf4\x01\r\x12\n\r\n\
    \x05\x04\x0f\x02\x02\x01\x12\x04\xf4\x01\x13\x1d\n\r\n\x05\x04\x0f\x02\
    \x02\x03\x12\x04\xf4\x01\x20!\nR\n\x02\x04\x10\x12\x06\xf8\x01\0\x91\x02\
    \x01\x1aD/\x20A\x20proto\x20object\x20representing\x20the\x20result\x20o\
    f\x20entire\x20Suite\x20execution.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xf8\
    \x01\x08\x18\n7\n\x04\x04\x10\x02\0\x12\x04\xfa\x01\x04-\x1a)/\x20Contai\
    ns\x20the\x20result\x20from\x20the\x20execution\n\n\r\n\x05\x04\x10\x02\
    \0\x04\x12\x04\xfa\x01\x04\x0c\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xfa\
    \x01\r\x1c\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xfa\x01\x1d(\n\r\n\x05\
    \x04\x10\x02\0\x03\x12\x04\xfa\x01+,\nq\n\x04\x04\x10\x02\x01\x12\x04\
    \xfc\x01\x041\x1ac/\x20Contains\x20a\x20'before'\x20hook\x20failure\x20m\
    essage.\x20This\x20happens\x20when\x20the\x20`before_suite`\x20hook\x20h\
    as\x20an\x20error\n\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xfc\x01\x04\
    \x0c\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\xfc\x01\r\x1d\n\r\n\x05\x04\
    \x10\x02\x01\x01\x12\x04\xfc\x01\x1e,\n\r\n\x05\x04\x10\x02\x01\x03\x12\
    \x04\xfc\x01/0\no\n\x04\x04\x10\x02\x02\x12\x04\xfe\x01\x042\x1aa/\x20Co\
    ntains\x20a\x20'after'\x20hook\x20failure\x20message.\x20This\x20happens\
    \x20when\x20the\x20`after_suite`\x20hook\x20has\x20an\x20error\n\n\r\n\
    \x05\x04\x10\x02\x02\x04\x12\x04\xfe\x01\x04\x0c\n\r\n\x05\x04\x10\x02\
    \x02\x06\x12\x04\xfe\x01\r\x1d\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xfe\
    \x01\x1e-\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xfe\x0101\n)\n\x04\x04\
    \x10\x02\x03\x12\x04\x80\x02\x04\x1d\x1a\x1b/\x20Flag\x20to\x20indicate\
    \x20failure\n\n\r\n\x05\x04\x10\x02\x03\x04\x12\x04\x80\x02\x04\x0c\n\r\
    \n\x05\x04\x10\x02\x03\x05\x12\x04\x80\x02\r\x11\n\r\n\x05\x04\x10\x02\
    \x03\x01\x12\x04\x80\x02\x12\x18\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\
    \x80\x02\x1b\x1c\nI\n\x04\x04\x10\x02\x04\x12\x04\x82\x02\x04(\x1a;/\x20\
    Holds\x20the\x20count\x20of\x20number\x20of\x20Specifications\x20that\
    \x20failed.\n\n\r\n\x05\x04\x10\x02\x04\x04\x12\x04\x82\x02\x04\x0c\n\r\
    \n\x05\x04\x10\x02\x04\x05\x12\x04\x82\x02\r\x12\n\r\n\x05\x04\x10\x02\
    \x04\x01\x12\x04\x82\x02\x13#\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\x82\
    \x02&'\nD\n\x04\x04\x10\x02\x05\x12\x04\x84\x02\x04%\x1a6/\x20Holds\x20t\
    he\x20time\x20taken\x20for\x20executing\x20the\x20whole\x20suite.\n\n\r\
    \n\x05\x04\x10\x02\x05\x04\x12\x04\x84\x02\x04\x0c\n\r\n\x05\x04\x10\x02\
    \x05\x05\x12\x04\x84\x02\r\x12\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\x84\
    \x02\x13\x20\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\x84\x02#$\nM\n\x04\
    \x04\x10\x02\x06\x12\x04\x86\x02\x04#\x1a?/\x20Holds\x20a\x20metric\x20i\
    ndicating\x20the\x20success\x20rate\x20of\x20the\x20execution.\n\n\r\n\
    \x05\x04\x10\x02\x06\x04\x12\x04\x86\x02\x04\x0c\n\r\n\x05\x04\x10\x02\
    \x06\x05\x12\x04\x86\x02\r\x12\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\x86\
    \x02\x13\x1e\n\r\n\x05\x04\x10\x02\x06\x03\x12\x04\x86\x02!\"\nA\n\x04\
    \x04\x10\x02\x07\x12\x04\x88\x02\x04$\x1a3/\x20The\x20environment\x20aga\
    inst\x20which\x20execution\x20was\x20done\n\n\r\n\x05\x04\x10\x02\x07\
    \x04\x12\x04\x88\x02\x04\x0c\n\r\n\x05\x04\x10\x02\x07\x05\x12\x04\x88\
    \x02\r\x13\n\r\n\x05\x04\x10\x02\x07\x01\x12\x04\x88\x02\x14\x1f\n\r\n\
    \x05\x04\x10\x02\x07\x03\x12\x04\x88\x02\"#\n@\n\x04\x04\x10\x02\x08\x12\
    \x04\x8a\x02\x04\x1d\x1a2/\x20Tag\x20expression\x20used\x20for\x20filter\
    ing\x20specification\n\n\r\n\x05\x04\x10\x02\x08\x04\x12\x04\x8a\x02\x04\
    \x0c\n\r\n\x05\x04\x10\x02\x08\x05\x12\x04\x8a\x02\r\x13\n\r\n\x05\x04\
    \x10\x02\x08\x01\x12\x04\x8a\x02\x14\x18\n\r\n\x05\x04\x10\x02\x08\x03\
    \x12\x04\x8a\x02\x1b\x1c\n\x1d\n\x04\x04\x10\x02\t\x12\x04\x8c\x02\x04%\
    \x1a\x0f/\x20Project\x20name\n\n\r\n\x05\x04\x10\x02\t\x04\x12\x04\x8c\
    \x02\x04\x0c\n\r\n\x05\x04\x10\x02\t\x05\x12\x04\x8c\x02\r\x13\n\r\n\x05\
    \x04\x10\x02\t\x01\x12\x04\x8c\x02\x14\x1f\n\r\n\x05\x04\x10\x02\t\x03\
    \x12\x04\x8c\x02\"$\n4\n\x04\x04\x10\x02\n\x12\x04\x8e\x02\x04#\x1a&/\
    \x20Timestamp\x20of\x20when\x20execution\x20started\n\n\r\n\x05\x04\x10\
    \x02\n\x04\x12\x04\x8e\x02\x04\x0c\n\r\n\x05\x04\x10\x02\n\x05\x12\x04\
    \x8e\x02\r\x13\n\r\n\x05\x04\x10\x02\n\x01\x12\x04\x8e\x02\x14\x1d\n\r\n\
    \x05\x04\x10\x02\n\x03\x12\x04\x8e\x02\x20\"\n\x0c\n\x04\x04\x10\x02\x0b\
    \x12\x04\x8f\x02\x04*\n\r\n\x05\x04\x10\x02\x0b\x04\x12\x04\x8f\x02\x04\
    \x0c\n\r\n\x05\x04\x10\x02\x0b\x05\x12\x04\x8f\x02\r\x12\n\r\n\x05\x04\
    \x10\x02\x0b\x01\x12\x04\x8f\x02\x13$\n\r\n\x05\x04\x10\x02\x0b\x03\x12\
    \x04\x8f\x02')\nJ\n\x02\x04\x11\x12\x06\x94\x02\0\xa3\x02\x01\x1a</\x20A\
    \x20proto\x20object\x20representing\x20the\x20result\x20of\x20Spec\x20ex\
    ecution.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\x94\x02\x08\x17\n;\n\x04\x04\
    \x11\x02\0\x12\x04\x96\x02\x04%\x1a-/\x20Represents\x20the\x20correspond\
    ing\x20Specification\n\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\x96\x02\x04\
    \x0c\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\x96\x02\r\x16\n\r\n\x05\x04\x11\
    \x02\0\x01\x12\x04\x96\x02\x17\x20\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\
    \x96\x02#$\n7\n\x04\x04\x11\x02\x01\x12\x04\x98\x02\x04%\x1a)/\x20Holds\
    \x20the\x20number\x20of\x20Scenarios\x20executed\n\n\r\n\x05\x04\x11\x02\
    \x01\x04\x12\x04\x98\x02\x04\x0c\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\
    \x98\x02\r\x12\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\x98\x02\x13\x20\n\r\
    \n\x05\x04\x11\x02\x01\x03\x12\x04\x98\x02#$\n5\n\x04\x04\x11\x02\x02\
    \x12\x04\x9a\x02\x04+\x1a'/\x20Holds\x20the\x20number\x20of\x20Scenarios\
    \x20failed\n\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\x9a\x02\x04\x0c\n\r\n\
    \x05\x04\x11\x02\x02\x05\x12\x04\x9a\x02\r\x12\n\r\n\x05\x04\x11\x02\x02\
    \x01\x12\x04\x9a\x02\x13&\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\x9a\x02)\
    *\n)\n\x04\x04\x11\x02\x03\x12\x04\x9c\x02\x04\x1d\x1a\x1b/\x20Flag\x20t\
    o\x20indicate\x20failure\n\n\r\n\x05\x04\x11\x02\x03\x04\x12\x04\x9c\x02\
    \x04\x0c\n\r\n\x05\x04\x11\x02\x03\x05\x12\x04\x9c\x02\r\x11\n\r\n\x05\
    \x04\x11\x02\x03\x01\x12\x04\x9c\x02\x12\x18\n\r\n\x05\x04\x11\x02\x03\
    \x03\x12\x04\x9c\x02\x1b\x1c\nK\n\x04\x04\x11\x02\x04\x12\x04\x9e\x02\
    \x04+\x1a=/\x20Holds\x20the\x20row\x20numbers,\x20which\x20caused\x20the\
    \x20execution\x20to\x20fail.\n\n\r\n\x05\x04\x11\x02\x04\x04\x12\x04\x9e\
    \x02\x04\x0c\n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\x9e\x02\r\x12\n\r\n\
    \x05\x04\x11\x02\x04\x01\x12\x04\x9e\x02\x13&\n\r\n\x05\x04\x11\x02\x04\
    \x03\x12\x04\x9e\x02)*\n=\n\x04\x04\x11\x02\x05\x12\x04\xa0\x02\x04%\x1a\
    //\x20Holds\x20the\x20time\x20taken\x20for\x20executing\x20the\x20spec.\
    \n\n\r\n\x05\x04\x11\x02\x05\x04\x12\x04\xa0\x02\x04\x0c\n\r\n\x05\x04\
    \x11\x02\x05\x05\x12\x04\xa0\x02\r\x12\n\r\n\x05\x04\x11\x02\x05\x01\x12\
    \x04\xa0\x02\x13\x20\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\xa0\x02#$\n\
    \x0c\n\x04\x04\x11\x02\x06\x12\x04\xa1\x02\x04\x1e\n\r\n\x05\x04\x11\x02\
    \x06\x04\x12\x04\xa1\x02\x04\x0c\n\r\n\x05\x04\x11\x02\x06\x05\x12\x04\
    \xa1\x02\r\x11\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xa1\x02\x12\x19\n\r\
    \n\x05\x04\x11\x02\x06\x03\x12\x04\xa1\x02\x1c\x1d\n\x0c\n\x04\x04\x11\
    \x02\x07\x12\x04\xa2\x02\x04,\n\r\n\x05\x04\x11\x02\x07\x04\x12\x04\xa2\
    \x02\x04\x0c\n\r\n\x05\x04\x11\x02\x07\x05\x12\x04\xa2\x02\r\x12\n\r\n\
    \x05\x04\x11\x02\x07\x01\x12\x04\xa2\x02\x13'\n\r\n\x05\x04\x11\x02\x07\
    \x03\x12\x04\xa2\x02*+\n:\n\x02\x04\x12\x12\x06\xa6\x02\0\xad\x02\x01\
    \x1a,/\x20A\x20proto\x20object\x20representing\x20a\x20Step\x20value.\n\
    \n\x0b\n\x03\x04\x12\x01\x12\x04\xa6\x02\x08\x16\n;\n\x04\x04\x12\x02\0\
    \x12\x04\xa8\x02\x04\"\x1a-/\x20The\x20actual\x20string\x20value\x20desc\
    ribing\x20he\x20Step\n\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xa8\x02\x04\
    \x0c\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xa8\x02\r\x13\n\r\n\x05\x04\x12\
    \x02\0\x01\x12\x04\xa8\x02\x14\x1d\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\
    \xa8\x02\x20!\nr\n\x04\x04\x12\x02\x01\x12\x04\xaa\x02\x04/\x1ad/\x20The\
    \x20parameterized\x20string\x20value\x20describing\x20he\x20Step.\x20The\
    \x20parameters\x20are\x20replaced\x20with\x20placeholders.\n\n\r\n\x05\
    \x04\x12\x02\x01\x04\x12\x04\xaa\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x01\
    \x05\x12\x04\xaa\x02\r\x13\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xaa\x02\
    \x14*\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xaa\x02-.\nE\n\x04\x04\x12\
    \x02\x02\x12\x04\xac\x02\x04#\x1a7/\x20A\x20collection\x20of\x20strings\
    \x20representing\x20the\x20parameters.\n\n\r\n\x05\x04\x12\x02\x02\x04\
    \x12\x04\xac\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xac\x02\r\
    \x13\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xac\x02\x14\x1e\n\r\n\x05\x04\
    \x12\x02\x02\x03\x12\x04\xac\x02!\"\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        let mut messages = ::std::vec::Vec::new();
        messages.push(ProtoSpec::generated_message_descriptor_data());
        messages.push(ProtoItem::generated_message_descriptor_data());
        messages.push(ProtoScenario::generated_message_descriptor_data());
        messages.push(Span::generated_message_descriptor_data());
        messages.push(ProtoTableDrivenScenario::generated_message_descriptor_data());
        messages.push(ProtoStep::generated_message_descriptor_data());
        messages.push(ProtoConcept::generated_message_descriptor_data());
        messages.push(ProtoTags::generated_message_descriptor_data());
        messages.push(Fragment::generated_message_descriptor_data());
        messages.push(Parameter::generated_message_descriptor_data());
        messages.push(ProtoComment::generated_message_descriptor_data());
        messages.push(ProtoTable::generated_message_descriptor_data());
        messages.push(ProtoTableRow::generated_message_descriptor_data());
        messages.push(ProtoStepExecutionResult::generated_message_descriptor_data());
        messages.push(ProtoExecutionResult::generated_message_descriptor_data());
        messages.push(ProtoHookFailure::generated_message_descriptor_data());
        messages.push(ProtoSuiteResult::generated_message_descriptor_data());
        messages.push(ProtoSpecResult::generated_message_descriptor_data());
        messages.push(ProtoStepValue::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        enums.push(proto_item::ItemType::generated_enum_descriptor_data());
        enums.push(fragment::FragmentType::generated_enum_descriptor_data());
        enums.push(parameter::ParameterType::generated_enum_descriptor_data());
        enums.push(proto_execution_result::ErrorType::generated_enum_descriptor_data());
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}

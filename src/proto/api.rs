// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

/// / Request to get the Root Directory of the project
#[derive(PartialEq,Clone,Default)]
pub struct GetProjectRootRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetProjectRootRequest {
    fn default() -> &'a GetProjectRootRequest {
        <GetProjectRootRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetProjectRootRequest {
    pub fn new() -> GetProjectRootRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetProjectRootRequest>(
            "GetProjectRootRequest",
            0,
            fields,
        )
    }
}

impl ::protobuf::Message for GetProjectRootRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetProjectRootRequest {
        GetProjectRootRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 0)
    }

    fn default_instance() -> &'static GetProjectRootRequest {
        static instance: GetProjectRootRequest = GetProjectRootRequest {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetProjectRootRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetProjectRootRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProjectRootRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response of GetProjectRootRequest.
#[derive(PartialEq,Clone,Default)]
pub struct GetProjectRootResponse {
    // message fields
    /// / Holds the absolute path of the Project Root directory.
    projectRoot: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetProjectRootResponse {
    fn default() -> &'a GetProjectRootResponse {
        <GetProjectRootResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetProjectRootResponse {
    pub fn new() -> GetProjectRootResponse {
        ::std::default::Default::default()
    }

    // required string projectRoot = 1;

    pub fn get_projectRoot(&self) -> &str {
        match self.projectRoot.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_projectRoot(&mut self) {
        self.projectRoot = ::std::option::Option::None;
    }

    pub fn has_projectRoot(&self) -> bool {
        self.projectRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_projectRoot(&mut self, v: ::std::string::String) {
        self.projectRoot = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_projectRoot(&mut self) -> &mut ::std::string::String {
        if self.projectRoot.is_none() {
            self.projectRoot = ::std::option::Option::Some(::std::string::String::new());
        }
        self.projectRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_projectRoot(&mut self) -> ::std::string::String {
        self.projectRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "projectRoot",
            |m: &GetProjectRootResponse| { &m.projectRoot },
            |m: &mut GetProjectRootResponse| { &mut m.projectRoot },
            GetProjectRootResponse::get_projectRoot,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetProjectRootResponse>(
            "GetProjectRootResponse",
            1,
            fields,
        )
    }
}

impl ::protobuf::Message for GetProjectRootResponse {
    fn is_initialized(&self) -> bool {
        if self.projectRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.projectRoot = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.projectRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.projectRoot.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetProjectRootResponse {
        GetProjectRootResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 1)
    }

    fn default_instance() -> &'static GetProjectRootResponse {
        static instance: GetProjectRootResponse = GetProjectRootResponse {
            projectRoot: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetProjectRootResponse {
    fn clear(&mut self) {
        self.projectRoot = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetProjectRootResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetProjectRootResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request to get the Root Directory of the Gauge installation
#[derive(PartialEq,Clone,Default)]
pub struct GetInstallationRootRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInstallationRootRequest {
    fn default() -> &'a GetInstallationRootRequest {
        <GetInstallationRootRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInstallationRootRequest {
    pub fn new() -> GetInstallationRootRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInstallationRootRequest>(
            "GetInstallationRootRequest",
            2,
            fields,
        )
    }
}

impl ::protobuf::Message for GetInstallationRootRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetInstallationRootRequest {
        GetInstallationRootRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 2)
    }

    fn default_instance() -> &'static GetInstallationRootRequest {
        static instance: GetInstallationRootRequest = GetInstallationRootRequest {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetInstallationRootRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInstallationRootRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInstallationRootRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response of GetInstallationRootRequest
#[derive(PartialEq,Clone,Default)]
pub struct GetInstallationRootResponse {
    // message fields
    /// / Holds the absolute path of the Gauge installation directory
    installationRoot: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInstallationRootResponse {
    fn default() -> &'a GetInstallationRootResponse {
        <GetInstallationRootResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetInstallationRootResponse {
    pub fn new() -> GetInstallationRootResponse {
        ::std::default::Default::default()
    }

    // required string installationRoot = 1;

    pub fn get_installationRoot(&self) -> &str {
        match self.installationRoot.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_installationRoot(&mut self) {
        self.installationRoot = ::std::option::Option::None;
    }

    pub fn has_installationRoot(&self) -> bool {
        self.installationRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_installationRoot(&mut self, v: ::std::string::String) {
        self.installationRoot = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_installationRoot(&mut self) -> &mut ::std::string::String {
        if self.installationRoot.is_none() {
            self.installationRoot = ::std::option::Option::Some(::std::string::String::new());
        }
        self.installationRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_installationRoot(&mut self) -> ::std::string::String {
        self.installationRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "installationRoot",
            |m: &GetInstallationRootResponse| { &m.installationRoot },
            |m: &mut GetInstallationRootResponse| { &mut m.installationRoot },
            GetInstallationRootResponse::get_installationRoot,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetInstallationRootResponse>(
            "GetInstallationRootResponse",
            3,
            fields,
        )
    }
}

impl ::protobuf::Message for GetInstallationRootResponse {
    fn is_initialized(&self) -> bool {
        if self.installationRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.installationRoot = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.installationRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.installationRoot.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetInstallationRootResponse {
        GetInstallationRootResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 3)
    }

    fn default_instance() -> &'static GetInstallationRootResponse {
        static instance: GetInstallationRootResponse = GetInstallationRootResponse {
            installationRoot: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetInstallationRootResponse {
    fn clear(&mut self) {
        self.installationRoot = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInstallationRootResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInstallationRootResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request to get all Steps in the project
#[derive(PartialEq,Clone,Default)]
pub struct GetAllStepsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAllStepsRequest {
    fn default() -> &'a GetAllStepsRequest {
        <GetAllStepsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAllStepsRequest {
    pub fn new() -> GetAllStepsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllStepsRequest>(
            "GetAllStepsRequest",
            4,
            fields,
        )
    }
}

impl ::protobuf::Message for GetAllStepsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetAllStepsRequest {
        GetAllStepsRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 4)
    }

    fn default_instance() -> &'static GetAllStepsRequest {
        static instance: GetAllStepsRequest = GetAllStepsRequest {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetAllStepsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAllStepsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllStepsRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response to GetAllStepsRequest
#[derive(PartialEq,Clone,Default)]
pub struct GetAllStepsResponse {
    // message fields
    /// / Holds a collection of Steps that are defined in the project.
    pub allSteps: ::std::vec::Vec<super::spec::ProtoStepValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAllStepsResponse {
    fn default() -> &'a GetAllStepsResponse {
        <GetAllStepsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAllStepsResponse {
    pub fn new() -> GetAllStepsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allSteps",
            |m: &GetAllStepsResponse| { &m.allSteps },
            |m: &mut GetAllStepsResponse| { &mut m.allSteps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllStepsResponse>(
            "GetAllStepsResponse",
            5,
            fields,
        )
    }
}

impl ::protobuf::Message for GetAllStepsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.allSteps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.allSteps)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allSteps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allSteps {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetAllStepsResponse {
        GetAllStepsResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 5)
    }

    fn default_instance() -> &'static GetAllStepsResponse {
        static instance: GetAllStepsResponse = GetAllStepsResponse {
            allSteps: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetAllStepsResponse {
    fn clear(&mut self) {
        self.allSteps.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAllStepsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllStepsResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request to get all Specs in the project
#[derive(PartialEq,Clone,Default)]
pub struct GetAllSpecsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAllSpecsRequest {
    fn default() -> &'a GetAllSpecsRequest {
        <GetAllSpecsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAllSpecsRequest {
    pub fn new() -> GetAllSpecsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllSpecsRequest>(
            "GetAllSpecsRequest",
            6,
            fields,
        )
    }
}

impl ::protobuf::Message for GetAllSpecsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetAllSpecsRequest {
        GetAllSpecsRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 6)
    }

    fn default_instance() -> &'static GetAllSpecsRequest {
        static instance: GetAllSpecsRequest = GetAllSpecsRequest {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetAllSpecsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAllSpecsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllSpecsRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response to GetAllSpecsRequest
#[derive(PartialEq,Clone,Default)]
pub struct GetAllSpecsResponse {
    // message fields
    /// / Holds a collection of Specs that are defined in the project.
    pub specs: ::std::vec::Vec<super::spec::ProtoSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAllSpecsResponse {
    fn default() -> &'a GetAllSpecsResponse {
        <GetAllSpecsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAllSpecsResponse {
    pub fn new() -> GetAllSpecsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "specs",
            |m: &GetAllSpecsResponse| { &m.specs },
            |m: &mut GetAllSpecsResponse| { &mut m.specs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllSpecsResponse>(
            "GetAllSpecsResponse",
            7,
            fields,
        )
    }
}

impl ::protobuf::Message for GetAllSpecsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.specs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.specs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.specs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.specs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetAllSpecsResponse {
        GetAllSpecsResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 7)
    }

    fn default_instance() -> &'static GetAllSpecsResponse {
        static instance: GetAllSpecsResponse = GetAllSpecsResponse {
            specs: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetAllSpecsResponse {
    fn clear(&mut self) {
        self.specs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAllSpecsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllSpecsResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request to get all Concepts in the project
#[derive(PartialEq,Clone,Default)]
pub struct GetAllConceptsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAllConceptsRequest {
    fn default() -> &'a GetAllConceptsRequest {
        <GetAllConceptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAllConceptsRequest {
    pub fn new() -> GetAllConceptsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllConceptsRequest>(
            "GetAllConceptsRequest",
            8,
            fields,
        )
    }
}

impl ::protobuf::Message for GetAllConceptsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetAllConceptsRequest {
        GetAllConceptsRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 8)
    }

    fn default_instance() -> &'static GetAllConceptsRequest {
        static instance: GetAllConceptsRequest = GetAllConceptsRequest {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetAllConceptsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAllConceptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllConceptsRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response to GetAllConceptsResponse
#[derive(PartialEq,Clone,Default)]
pub struct GetAllConceptsResponse {
    // message fields
    /// / Holds a collection of Concepts that are defined in the project.
    pub concepts: ::std::vec::Vec<ConceptInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAllConceptsResponse {
    fn default() -> &'a GetAllConceptsResponse {
        <GetAllConceptsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAllConceptsResponse {
    pub fn new() -> GetAllConceptsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "concepts",
            |m: &GetAllConceptsResponse| { &m.concepts },
            |m: &mut GetAllConceptsResponse| { &mut m.concepts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllConceptsResponse>(
            "GetAllConceptsResponse",
            9,
            fields,
        )
    }
}

impl ::protobuf::Message for GetAllConceptsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.concepts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.concepts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.concepts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.concepts {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetAllConceptsResponse {
        GetAllConceptsResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 9)
    }

    fn default_instance() -> &'static GetAllConceptsResponse {
        static instance: GetAllConceptsResponse = GetAllConceptsResponse {
            concepts: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetAllConceptsResponse {
    fn clear(&mut self) {
        self.concepts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAllConceptsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllConceptsResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Details of a Concept
#[derive(PartialEq,Clone,Default)]
pub struct ConceptInfo {
    // message fields
    /// / The text that defines a concept
    pub stepValue: ::protobuf::MessageField<super::spec::ProtoStepValue>,
    /// / The absolute path to the file that contains the Concept
    filepath: ::std::option::Option<::std::string::String>,
    /// / The line number in the file where the concept is defined.
    lineNumber: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConceptInfo {
    fn default() -> &'a ConceptInfo {
        <ConceptInfo as ::protobuf::Message>::default_instance()
    }
}

impl ConceptInfo {
    pub fn new() -> ConceptInfo {
        ::std::default::Default::default()
    }

    // required string filepath = 2;

    pub fn get_filepath(&self) -> &str {
        match self.filepath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filepath(&mut self) {
        self.filepath = ::std::option::Option::None;
    }

    pub fn has_filepath(&self) -> bool {
        self.filepath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filepath(&mut self, v: ::std::string::String) {
        self.filepath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filepath(&mut self) -> &mut ::std::string::String {
        if self.filepath.is_none() {
            self.filepath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filepath.as_mut().unwrap()
    }

    // Take field
    pub fn take_filepath(&mut self) -> ::std::string::String {
        self.filepath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 lineNumber = 3;

    pub fn get_lineNumber(&self) -> i32 {
        self.lineNumber.unwrap_or(0)
    }

    pub fn clear_lineNumber(&mut self) {
        self.lineNumber = ::std::option::Option::None;
    }

    pub fn has_lineNumber(&self) -> bool {
        self.lineNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lineNumber(&mut self, v: i32) {
        self.lineNumber = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::spec::ProtoStepValue>(
            "stepValue",
            |m: &ConceptInfo| { &m.stepValue },
            |m: &mut ConceptInfo| { &mut m.stepValue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "filepath",
            |m: &ConceptInfo| { &m.filepath },
            |m: &mut ConceptInfo| { &mut m.filepath },
            ConceptInfo::get_filepath,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "lineNumber",
            |m: &ConceptInfo| { &m.lineNumber },
            |m: &mut ConceptInfo| { &mut m.lineNumber },
            ConceptInfo::get_lineNumber,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConceptInfo>(
            "ConceptInfo",
            10,
            fields,
        )
    }
}

impl ::protobuf::Message for ConceptInfo {
    fn is_initialized(&self) -> bool {
        if self.stepValue.is_none() {
            return false;
        }
        if self.filepath.is_none() {
            return false;
        }
        if self.lineNumber.is_none() {
            return false;
        }
        for v in &self.stepValue {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepValue)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filepath = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.lineNumber = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stepValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.filepath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lineNumber {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stepValue.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.filepath.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.lineNumber {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ConceptInfo {
        ConceptInfo::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 10)
    }

    fn default_instance() -> &'static ConceptInfo {
        static instance: ConceptInfo = ConceptInfo {
            stepValue: ::protobuf::MessageField::none(),
            filepath: ::std::option::Option::None,
            lineNumber: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ConceptInfo {
    fn clear(&mut self) {
        self.stepValue.clear();
        self.filepath = ::std::option::Option::None;
        self.lineNumber = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptInfo {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request to get a Step Value.
#[derive(PartialEq,Clone,Default)]
pub struct GetStepValueRequest {
    // message fields
    /// / The text of the Step.
    stepText: ::std::option::Option<::std::string::String>,
    /// / Flag to indicate if the Step has an inline table.
    hasInlineTable: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStepValueRequest {
    fn default() -> &'a GetStepValueRequest {
        <GetStepValueRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStepValueRequest {
    pub fn new() -> GetStepValueRequest {
        ::std::default::Default::default()
    }

    // required string stepText = 1;

    pub fn get_stepText(&self) -> &str {
        match self.stepText.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stepText(&mut self) {
        self.stepText = ::std::option::Option::None;
    }

    pub fn has_stepText(&self) -> bool {
        self.stepText.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stepText(&mut self, v: ::std::string::String) {
        self.stepText = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stepText(&mut self) -> &mut ::std::string::String {
        if self.stepText.is_none() {
            self.stepText = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stepText.as_mut().unwrap()
    }

    // Take field
    pub fn take_stepText(&mut self) -> ::std::string::String {
        self.stepText.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool hasInlineTable = 2;

    pub fn get_hasInlineTable(&self) -> bool {
        self.hasInlineTable.unwrap_or(false)
    }

    pub fn clear_hasInlineTable(&mut self) {
        self.hasInlineTable = ::std::option::Option::None;
    }

    pub fn has_hasInlineTable(&self) -> bool {
        self.hasInlineTable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasInlineTable(&mut self, v: bool) {
        self.hasInlineTable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "stepText",
            |m: &GetStepValueRequest| { &m.stepText },
            |m: &mut GetStepValueRequest| { &mut m.stepText },
            GetStepValueRequest::get_stepText,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "hasInlineTable",
            |m: &GetStepValueRequest| { &m.hasInlineTable },
            |m: &mut GetStepValueRequest| { &mut m.hasInlineTable },
            GetStepValueRequest::get_hasInlineTable,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetStepValueRequest>(
            "GetStepValueRequest",
            11,
            fields,
        )
    }
}

impl ::protobuf::Message for GetStepValueRequest {
    fn is_initialized(&self) -> bool {
        if self.stepText.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.stepText = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.hasInlineTable = ::std::option::Option::Some(is.read_bool()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stepText.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.hasInlineTable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stepText.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.hasInlineTable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetStepValueRequest {
        GetStepValueRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 11)
    }

    fn default_instance() -> &'static GetStepValueRequest {
        static instance: GetStepValueRequest = GetStepValueRequest {
            stepText: ::std::option::Option::None,
            hasInlineTable: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetStepValueRequest {
    fn clear(&mut self) {
        self.stepText = ::std::option::Option::None;
        self.hasInlineTable = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStepValueRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStepValueRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response to GetStepValueRequest
#[derive(PartialEq,Clone,Default)]
pub struct GetStepValueResponse {
    // message fields
    /// / The Step corresponding to the request provided.
    pub stepValue: ::protobuf::MessageField<super::spec::ProtoStepValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStepValueResponse {
    fn default() -> &'a GetStepValueResponse {
        <GetStepValueResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetStepValueResponse {
    pub fn new() -> GetStepValueResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::spec::ProtoStepValue>(
            "stepValue",
            |m: &GetStepValueResponse| { &m.stepValue },
            |m: &mut GetStepValueResponse| { &mut m.stepValue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetStepValueResponse>(
            "GetStepValueResponse",
            12,
            fields,
        )
    }
}

impl ::protobuf::Message for GetStepValueResponse {
    fn is_initialized(&self) -> bool {
        if self.stepValue.is_none() {
            return false;
        }
        for v in &self.stepValue {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepValue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stepValue.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stepValue.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetStepValueResponse {
        GetStepValueResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 12)
    }

    fn default_instance() -> &'static GetStepValueResponse {
        static instance: GetStepValueResponse = GetStepValueResponse {
            stepValue: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetStepValueResponse {
    fn clear(&mut self) {
        self.stepValue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStepValueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStepValueResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request to get the location of language plugin's Lib directory
#[derive(PartialEq,Clone,Default)]
pub struct GetLanguagePluginLibPathRequest {
    // message fields
    /// / The language to locate the lib directory for.
    language: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLanguagePluginLibPathRequest {
    fn default() -> &'a GetLanguagePluginLibPathRequest {
        <GetLanguagePluginLibPathRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLanguagePluginLibPathRequest {
    pub fn new() -> GetLanguagePluginLibPathRequest {
        ::std::default::Default::default()
    }

    // required string language = 1;

    pub fn get_language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "language",
            |m: &GetLanguagePluginLibPathRequest| { &m.language },
            |m: &mut GetLanguagePluginLibPathRequest| { &mut m.language },
            GetLanguagePluginLibPathRequest::get_language,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLanguagePluginLibPathRequest>(
            "GetLanguagePluginLibPathRequest",
            13,
            fields,
        )
    }
}

impl ::protobuf::Message for GetLanguagePluginLibPathRequest {
    fn is_initialized(&self) -> bool {
        if self.language.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetLanguagePluginLibPathRequest {
        GetLanguagePluginLibPathRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 13)
    }

    fn default_instance() -> &'static GetLanguagePluginLibPathRequest {
        static instance: GetLanguagePluginLibPathRequest = GetLanguagePluginLibPathRequest {
            language: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetLanguagePluginLibPathRequest {
    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLanguagePluginLibPathRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLanguagePluginLibPathRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response to GetLanguagePluginLibPathRequest
#[derive(PartialEq,Clone,Default)]
pub struct GetLanguagePluginLibPathResponse {
    // message fields
    /// / Absolute path to the Lib directory of the language.
    path: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLanguagePluginLibPathResponse {
    fn default() -> &'a GetLanguagePluginLibPathResponse {
        <GetLanguagePluginLibPathResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLanguagePluginLibPathResponse {
    pub fn new() -> GetLanguagePluginLibPathResponse {
        ::std::default::Default::default()
    }

    // required string path = 1;

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "path",
            |m: &GetLanguagePluginLibPathResponse| { &m.path },
            |m: &mut GetLanguagePluginLibPathResponse| { &mut m.path },
            GetLanguagePluginLibPathResponse::get_path,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetLanguagePluginLibPathResponse>(
            "GetLanguagePluginLibPathResponse",
            14,
            fields,
        )
    }
}

impl ::protobuf::Message for GetLanguagePluginLibPathResponse {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.path.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> GetLanguagePluginLibPathResponse {
        GetLanguagePluginLibPathResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 14)
    }

    fn default_instance() -> &'static GetLanguagePluginLibPathResponse {
        static instance: GetLanguagePluginLibPathResponse = GetLanguagePluginLibPathResponse {
            path: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for GetLanguagePluginLibPathResponse {
    fn clear(&mut self) {
        self.path = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLanguagePluginLibPathResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLanguagePluginLibPathResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A generic failure response
#[derive(PartialEq,Clone,Default)]
pub struct ErrorResponse {
    // message fields
    /// / Actual error message
    error: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ErrorResponse {
    fn default() -> &'a ErrorResponse {
        <ErrorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ErrorResponse {
    pub fn new() -> ErrorResponse {
        ::std::default::Default::default()
    }

    // required string error = 1;

    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "error",
            |m: &ErrorResponse| { &m.error },
            |m: &mut ErrorResponse| { &mut m.error },
            ErrorResponse::get_error,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorResponse>(
            "ErrorResponse",
            15,
            fields,
        )
    }
}

impl ::protobuf::Message for ErrorResponse {
    fn is_initialized(&self) -> bool {
        if self.error.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.error.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ErrorResponse {
        ErrorResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 15)
    }

    fn default_instance() -> &'static ErrorResponse {
        static instance: ErrorResponse = ErrorResponse {
            error: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ErrorResponse {
    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ErrorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request to perform a Refactor
#[derive(PartialEq,Clone,Default)]
pub struct PerformRefactoringRequest {
    // message fields
    /// / Step to refactor
    oldStep: ::std::option::Option<::std::string::String>,
    /// / Change to be made
    newStep: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerformRefactoringRequest {
    fn default() -> &'a PerformRefactoringRequest {
        <PerformRefactoringRequest as ::protobuf::Message>::default_instance()
    }
}

impl PerformRefactoringRequest {
    pub fn new() -> PerformRefactoringRequest {
        ::std::default::Default::default()
    }

    // required string oldStep = 1;

    pub fn get_oldStep(&self) -> &str {
        match self.oldStep.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_oldStep(&mut self) {
        self.oldStep = ::std::option::Option::None;
    }

    pub fn has_oldStep(&self) -> bool {
        self.oldStep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldStep(&mut self, v: ::std::string::String) {
        self.oldStep = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldStep(&mut self) -> &mut ::std::string::String {
        if self.oldStep.is_none() {
            self.oldStep = ::std::option::Option::Some(::std::string::String::new());
        }
        self.oldStep.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldStep(&mut self) -> ::std::string::String {
        self.oldStep.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string newStep = 2;

    pub fn get_newStep(&self) -> &str {
        match self.newStep.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_newStep(&mut self) {
        self.newStep = ::std::option::Option::None;
    }

    pub fn has_newStep(&self) -> bool {
        self.newStep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newStep(&mut self, v: ::std::string::String) {
        self.newStep = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newStep(&mut self) -> &mut ::std::string::String {
        if self.newStep.is_none() {
            self.newStep = ::std::option::Option::Some(::std::string::String::new());
        }
        self.newStep.as_mut().unwrap()
    }

    // Take field
    pub fn take_newStep(&mut self) -> ::std::string::String {
        self.newStep.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "oldStep",
            |m: &PerformRefactoringRequest| { &m.oldStep },
            |m: &mut PerformRefactoringRequest| { &mut m.oldStep },
            PerformRefactoringRequest::get_oldStep,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "newStep",
            |m: &PerformRefactoringRequest| { &m.newStep },
            |m: &mut PerformRefactoringRequest| { &mut m.newStep },
            PerformRefactoringRequest::get_newStep,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerformRefactoringRequest>(
            "PerformRefactoringRequest",
            16,
            fields,
        )
    }
}

impl ::protobuf::Message for PerformRefactoringRequest {
    fn is_initialized(&self) -> bool {
        if self.oldStep.is_none() {
            return false;
        }
        if self.newStep.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.oldStep = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.newStep = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.oldStep.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.newStep.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.oldStep.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.newStep.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PerformRefactoringRequest {
        PerformRefactoringRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 16)
    }

    fn default_instance() -> &'static PerformRefactoringRequest {
        static instance: PerformRefactoringRequest = PerformRefactoringRequest {
            oldStep: ::std::option::Option::None,
            newStep: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PerformRefactoringRequest {
    fn clear(&mut self) {
        self.oldStep = ::std::option::Option::None;
        self.newStep = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PerformRefactoringRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerformRefactoringRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response to PerformRefactoringRequest
#[derive(PartialEq,Clone,Default)]
pub struct PerformRefactoringResponse {
    // message fields
    /// / Flag indicating Success
    success: ::std::option::Option<bool>,
    /// / Error message if the refactoring was unsuccessful.
    pub errors: ::std::vec::Vec<::std::string::String>,
    /// / Collection of files that were changed as part of the Refactoring.
    pub filesChanged: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerformRefactoringResponse {
    fn default() -> &'a PerformRefactoringResponse {
        <PerformRefactoringResponse as ::protobuf::Message>::default_instance()
    }
}

impl PerformRefactoringResponse {
    pub fn new() -> PerformRefactoringResponse {
        ::std::default::Default::default()
    }

    // required bool success = 1;

    pub fn get_success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "success",
            |m: &PerformRefactoringResponse| { &m.success },
            |m: &mut PerformRefactoringResponse| { &mut m.success },
            PerformRefactoringResponse::get_success,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "errors",
            |m: &PerformRefactoringResponse| { &m.errors },
            |m: &mut PerformRefactoringResponse| { &mut m.errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filesChanged",
            |m: &PerformRefactoringResponse| { &m.filesChanged },
            |m: &mut PerformRefactoringResponse| { &mut m.filesChanged },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerformRefactoringResponse>(
            "PerformRefactoringResponse",
            17,
            fields,
        )
    }
}

impl ::protobuf::Message for PerformRefactoringResponse {
    fn is_initialized(&self) -> bool {
        if self.success.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.errors)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.filesChanged)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 2;
        }
        for value in &self.errors {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.filesChanged {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        for v in &self.errors {
            os.write_string(2, &v)?;
        };
        for v in &self.filesChanged {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> PerformRefactoringResponse {
        PerformRefactoringResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 17)
    }

    fn default_instance() -> &'static PerformRefactoringResponse {
        static instance: PerformRefactoringResponse = PerformRefactoringResponse {
            success: ::std::option::Option::None,
            errors: ::std::vec::Vec::new(),
            filesChanged: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for PerformRefactoringResponse {
    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.errors.clear();
        self.filesChanged.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PerformRefactoringResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerformRefactoringResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request to perform Extract to Concept refactoring
/// / The runner does not do the refactoring here, instead it provides inputs enabling the IDE to do refactoring
#[derive(PartialEq,Clone,Default)]
pub struct ExtractConceptInfoRequest {
    // message fields
    /// / The text blob containing steps that should be refactored to concept.
    text: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtractConceptInfoRequest {
    fn default() -> &'a ExtractConceptInfoRequest {
        <ExtractConceptInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExtractConceptInfoRequest {
    pub fn new() -> ExtractConceptInfoRequest {
        ::std::default::Default::default()
    }

    // required string text = 1;

    pub fn get_text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "text",
            |m: &ExtractConceptInfoRequest| { &m.text },
            |m: &mut ExtractConceptInfoRequest| { &mut m.text },
            ExtractConceptInfoRequest::get_text,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtractConceptInfoRequest>(
            "ExtractConceptInfoRequest",
            18,
            fields,
        )
    }
}

impl ::protobuf::Message for ExtractConceptInfoRequest {
    fn is_initialized(&self) -> bool {
        if self.text.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ExtractConceptInfoRequest {
        ExtractConceptInfoRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 18)
    }

    fn default_instance() -> &'static ExtractConceptInfoRequest {
        static instance: ExtractConceptInfoRequest = ExtractConceptInfoRequest {
            text: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ExtractConceptInfoRequest {
    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtractConceptInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtractConceptInfoRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request to perform Extract to Concept refactoring
#[derive(PartialEq,Clone,Default)]
pub struct ExtractConceptRequest {
    // message fields
    /// / The Concept name given by the user
    pub conceptName: ::protobuf::MessageField<Step>,
    /// / steps to extract
    pub steps: ::std::vec::Vec<Step>,
    /// / Flag indicating if refactoring should be done across project
    changeAcrossProject: ::std::option::Option<bool>,
    /// / The concept filename in which extracted concept will be added
    conceptFileName: ::std::option::Option<::std::string::String>,
    /// / Info related to selected text, required only if changeAcrossProject is false
    pub selectedTextInfo: ::protobuf::MessageField<TextInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtractConceptRequest {
    fn default() -> &'a ExtractConceptRequest {
        <ExtractConceptRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExtractConceptRequest {
    pub fn new() -> ExtractConceptRequest {
        ::std::default::Default::default()
    }

    // required bool changeAcrossProject = 3;

    pub fn get_changeAcrossProject(&self) -> bool {
        self.changeAcrossProject.unwrap_or(false)
    }

    pub fn clear_changeAcrossProject(&mut self) {
        self.changeAcrossProject = ::std::option::Option::None;
    }

    pub fn has_changeAcrossProject(&self) -> bool {
        self.changeAcrossProject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changeAcrossProject(&mut self, v: bool) {
        self.changeAcrossProject = ::std::option::Option::Some(v);
    }

    // required string conceptFileName = 4;

    pub fn get_conceptFileName(&self) -> &str {
        match self.conceptFileName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_conceptFileName(&mut self) {
        self.conceptFileName = ::std::option::Option::None;
    }

    pub fn has_conceptFileName(&self) -> bool {
        self.conceptFileName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conceptFileName(&mut self, v: ::std::string::String) {
        self.conceptFileName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conceptFileName(&mut self) -> &mut ::std::string::String {
        if self.conceptFileName.is_none() {
            self.conceptFileName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.conceptFileName.as_mut().unwrap()
    }

    // Take field
    pub fn take_conceptFileName(&mut self) -> ::std::string::String {
        self.conceptFileName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Step>(
            "conceptName",
            |m: &ExtractConceptRequest| { &m.conceptName },
            |m: &mut ExtractConceptRequest| { &mut m.conceptName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steps",
            |m: &ExtractConceptRequest| { &m.steps },
            |m: &mut ExtractConceptRequest| { &mut m.steps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "changeAcrossProject",
            |m: &ExtractConceptRequest| { &m.changeAcrossProject },
            |m: &mut ExtractConceptRequest| { &mut m.changeAcrossProject },
            ExtractConceptRequest::get_changeAcrossProject,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "conceptFileName",
            |m: &ExtractConceptRequest| { &m.conceptFileName },
            |m: &mut ExtractConceptRequest| { &mut m.conceptFileName },
            ExtractConceptRequest::get_conceptFileName,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TextInfo>(
            "selectedTextInfo",
            |m: &ExtractConceptRequest| { &m.selectedTextInfo },
            |m: &mut ExtractConceptRequest| { &mut m.selectedTextInfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtractConceptRequest>(
            "ExtractConceptRequest",
            19,
            fields,
        )
    }
}

impl ::protobuf::Message for ExtractConceptRequest {
    fn is_initialized(&self) -> bool {
        if self.conceptName.is_none() {
            return false;
        }
        if self.changeAcrossProject.is_none() {
            return false;
        }
        if self.conceptFileName.is_none() {
            return false;
        }
        for v in &self.conceptName {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.steps {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selectedTextInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.conceptName)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into_vec(wire_type, is, &mut self.steps)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.changeAcrossProject = ::std::option::Option::Some(is.read_bool()?);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.conceptFileName = ::std::option::Option::Some(is.read_string()?);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.selectedTextInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.conceptName.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.changeAcrossProject {
            my_size += 2;
        }
        if let Some(v) = self.conceptFileName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.selectedTextInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.conceptName.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.steps {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.changeAcrossProject {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.conceptFileName.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.selectedTextInfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ExtractConceptRequest {
        ExtractConceptRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 19)
    }

    fn default_instance() -> &'static ExtractConceptRequest {
        static instance: ExtractConceptRequest = ExtractConceptRequest {
            conceptName: ::protobuf::MessageField::none(),
            steps: ::std::vec::Vec::new(),
            changeAcrossProject: ::std::option::Option::None,
            conceptFileName: ::std::option::Option::None,
            selectedTextInfo: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ExtractConceptRequest {
    fn clear(&mut self) {
        self.conceptName.clear();
        self.steps.clear();
        self.changeAcrossProject = ::std::option::Option::None;
        self.conceptFileName = ::std::option::Option::None;
        self.selectedTextInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtractConceptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtractConceptRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct TextInfo {
    // message fields
    /// / The filename from where concept is being extracted
    fileName: ::std::option::Option<::std::string::String>,
    /// / storing the starting and ending line number of selected text
    startingLineNo: ::std::option::Option<i32>,
    endLineNo: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextInfo {
    fn default() -> &'a TextInfo {
        <TextInfo as ::protobuf::Message>::default_instance()
    }
}

impl TextInfo {
    pub fn new() -> TextInfo {
        ::std::default::Default::default()
    }

    // required string fileName = 1;

    pub fn get_fileName(&self) -> &str {
        match self.fileName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fileName(&mut self) {
        self.fileName = ::std::option::Option::None;
    }

    pub fn has_fileName(&self) -> bool {
        self.fileName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileName(&mut self, v: ::std::string::String) {
        self.fileName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileName(&mut self) -> &mut ::std::string::String {
        if self.fileName.is_none() {
            self.fileName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fileName.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileName(&mut self) -> ::std::string::String {
        self.fileName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 startingLineNo = 2;

    pub fn get_startingLineNo(&self) -> i32 {
        self.startingLineNo.unwrap_or(0)
    }

    pub fn clear_startingLineNo(&mut self) {
        self.startingLineNo = ::std::option::Option::None;
    }

    pub fn has_startingLineNo(&self) -> bool {
        self.startingLineNo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startingLineNo(&mut self, v: i32) {
        self.startingLineNo = ::std::option::Option::Some(v);
    }

    // required int32 endLineNo = 3;

    pub fn get_endLineNo(&self) -> i32 {
        self.endLineNo.unwrap_or(0)
    }

    pub fn clear_endLineNo(&mut self) {
        self.endLineNo = ::std::option::Option::None;
    }

    pub fn has_endLineNo(&self) -> bool {
        self.endLineNo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endLineNo(&mut self, v: i32) {
        self.endLineNo = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "fileName",
            |m: &TextInfo| { &m.fileName },
            |m: &mut TextInfo| { &mut m.fileName },
            TextInfo::get_fileName,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "startingLineNo",
            |m: &TextInfo| { &m.startingLineNo },
            |m: &mut TextInfo| { &mut m.startingLineNo },
            TextInfo::get_startingLineNo,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "endLineNo",
            |m: &TextInfo| { &m.endLineNo },
            |m: &mut TextInfo| { &mut m.endLineNo },
            TextInfo::get_endLineNo,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextInfo>(
            "textInfo",
            20,
            fields,
        )
    }
}

impl ::protobuf::Message for TextInfo {
    fn is_initialized(&self) -> bool {
        if self.fileName.is_none() {
            return false;
        }
        if self.startingLineNo.is_none() {
            return false;
        }
        if self.endLineNo.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.fileName = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.startingLineNo = ::std::option::Option::Some(is.read_int32()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.endLineNo = ::std::option::Option::Some(is.read_int32()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.startingLineNo {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.endLineNo {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileName.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.startingLineNo {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.endLineNo {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> TextInfo {
        TextInfo::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 20)
    }

    fn default_instance() -> &'static TextInfo {
        static instance: TextInfo = TextInfo {
            fileName: ::std::option::Option::None,
            startingLineNo: ::std::option::Option::None,
            endLineNo: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for TextInfo {
    fn clear(&mut self) {
        self.fileName = ::std::option::Option::None;
        self.startingLineNo = ::std::option::Option::None;
        self.endLineNo = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextInfo {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default)]
pub struct Step {
    // message fields
    /// / name of the step
    name: ::std::option::Option<::std::string::String>,
    /// /  table present in step as parameter
    table: ::std::option::Option<::std::string::String>,
    /// / name of table in concept heading, if it comes as a param to concept
    paramTableName: ::std::option::Option<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Step {
    fn default() -> &'a Step {
        <Step as ::protobuf::Message>::default_instance()
    }
}

impl Step {
    pub fn new() -> Step {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string table = 2;

    pub fn get_table(&self) -> &str {
        match self.table.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_table(&mut self) {
        self.table = ::std::option::Option::None;
    }

    pub fn has_table(&self) -> bool {
        self.table.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: ::std::string::String) {
        self.table = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table(&mut self) -> &mut ::std::string::String {
        if self.table.is_none() {
            self.table = ::std::option::Option::Some(::std::string::String::new());
        }
        self.table.as_mut().unwrap()
    }

    // Take field
    pub fn take_table(&mut self) -> ::std::string::String {
        self.table.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string paramTableName = 3;

    pub fn get_paramTableName(&self) -> &str {
        match self.paramTableName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_paramTableName(&mut self) {
        self.paramTableName = ::std::option::Option::None;
    }

    pub fn has_paramTableName(&self) -> bool {
        self.paramTableName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paramTableName(&mut self, v: ::std::string::String) {
        self.paramTableName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paramTableName(&mut self) -> &mut ::std::string::String {
        if self.paramTableName.is_none() {
            self.paramTableName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.paramTableName.as_mut().unwrap()
    }

    // Take field
    pub fn take_paramTableName(&mut self) -> ::std::string::String {
        self.paramTableName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "name",
            |m: &Step| { &m.name },
            |m: &mut Step| { &mut m.name },
            Step::get_name,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "table",
            |m: &Step| { &m.table },
            |m: &mut Step| { &mut m.table },
            Step::get_table,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "paramTableName",
            |m: &Step| { &m.paramTableName },
            |m: &mut Step| { &mut m.paramTableName },
            Step::get_paramTableName,
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Step>(
            "step",
            21,
            fields,
        )
    }
}

impl ::protobuf::Message for Step {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.table = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.paramTableName = ::std::option::Option::Some(is.read_string()?);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.table.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.paramTableName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.table.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.paramTableName.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> Step {
        Step::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 21)
    }

    fn default_instance() -> &'static Step {
        static instance: Step = Step {
            name: ::std::option::Option::None,
            table: ::std::option::Option::None,
            paramTableName: ::std::option::Option::None,
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for Step {
    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.table = ::std::option::Option::None;
        self.paramTableName = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Step {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Step {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response to perform Extract to Concept refactoring
#[derive(PartialEq,Clone,Default)]
pub struct ExtractConceptResponse {
    // message fields
    /// / Flag indicating Success
    isSuccess: ::std::option::Option<bool>,
    /// / Error message if the refactoring was unsuccessful.
    error: ::std::option::Option<::std::string::String>,
    /// / Collection of files that were changed as part of the Refactoring.
    pub filesChanged: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtractConceptResponse {
    fn default() -> &'a ExtractConceptResponse {
        <ExtractConceptResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExtractConceptResponse {
    pub fn new() -> ExtractConceptResponse {
        ::std::default::Default::default()
    }

    // required bool isSuccess = 1;

    pub fn get_isSuccess(&self) -> bool {
        self.isSuccess.unwrap_or(false)
    }

    pub fn clear_isSuccess(&mut self) {
        self.isSuccess = ::std::option::Option::None;
    }

    pub fn has_isSuccess(&self) -> bool {
        self.isSuccess.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isSuccess(&mut self, v: bool) {
        self.isSuccess = ::std::option::Option::Some(v);
    }

    // optional string error = 2;

    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "isSuccess",
            |m: &ExtractConceptResponse| { &m.isSuccess },
            |m: &mut ExtractConceptResponse| { &mut m.isSuccess },
            ExtractConceptResponse::get_isSuccess,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_ref_simpler_accessor::<_, _>(
            "error",
            |m: &ExtractConceptResponse| { &m.error },
            |m: &mut ExtractConceptResponse| { &mut m.error },
            ExtractConceptResponse::get_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filesChanged",
            |m: &ExtractConceptResponse| { &m.filesChanged },
            |m: &mut ExtractConceptResponse| { &mut m.filesChanged },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtractConceptResponse>(
            "ExtractConceptResponse",
            22,
            fields,
        )
    }
}

impl ::protobuf::Message for ExtractConceptResponse {
    fn is_initialized(&self) -> bool {
        if self.isSuccess.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.isSuccess = ::std::option::Option::Some(is.read_bool()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.filesChanged)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.isSuccess {
            my_size += 2;
        }
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.filesChanged {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.isSuccess {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.error.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.filesChanged {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> ExtractConceptResponse {
        ExtractConceptResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 22)
    }

    fn default_instance() -> &'static ExtractConceptResponse {
        static instance: ExtractConceptResponse = ExtractConceptResponse {
            isSuccess: ::std::option::Option::None,
            error: ::std::option::Option::None,
            filesChanged: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for ExtractConceptResponse {
    fn clear(&mut self) {
        self.isSuccess = ::std::option::Option::None;
        self.error = ::std::option::Option::None;
        self.filesChanged.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtractConceptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtractConceptResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Request to format spec files
#[derive(PartialEq,Clone,Default)]
pub struct FormatSpecsRequest {
    // message fields
    /// / Specs to be formatted
    pub specs: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FormatSpecsRequest {
    fn default() -> &'a FormatSpecsRequest {
        <FormatSpecsRequest as ::protobuf::Message>::default_instance()
    }
}

impl FormatSpecsRequest {
    pub fn new() -> FormatSpecsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "specs",
            |m: &FormatSpecsRequest| { &m.specs },
            |m: &mut FormatSpecsRequest| { &mut m.specs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FormatSpecsRequest>(
            "FormatSpecsRequest",
            23,
            fields,
        )
    }
}

impl ::protobuf::Message for FormatSpecsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.specs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.specs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.specs {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FormatSpecsRequest {
        FormatSpecsRequest::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 23)
    }

    fn default_instance() -> &'static FormatSpecsRequest {
        static instance: FormatSpecsRequest = FormatSpecsRequest {
            specs: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FormatSpecsRequest {
    fn clear(&mut self) {
        self.specs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FormatSpecsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormatSpecsRequest {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response on formatting spec files
#[derive(PartialEq,Clone,Default)]
pub struct FormatSpecsResponse {
    // message fields
    /// / Errors occurred on formatting
    pub errors: ::std::vec::Vec<::std::string::String>,
    /// / Warnings occurred on formatting
    pub warnings: ::std::vec::Vec<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a FormatSpecsResponse {
    fn default() -> &'a FormatSpecsResponse {
        <FormatSpecsResponse as ::protobuf::Message>::default_instance()
    }
}

impl FormatSpecsResponse {
    pub fn new() -> FormatSpecsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "errors",
            |m: &FormatSpecsResponse| { &m.errors },
            |m: &mut FormatSpecsResponse| { &mut m.errors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "warnings",
            |m: &FormatSpecsResponse| { &m.warnings },
            |m: &mut FormatSpecsResponse| { &mut m.warnings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FormatSpecsResponse>(
            "FormatSpecsResponse",
            24,
            fields,
        )
    }
}

impl ::protobuf::Message for FormatSpecsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.errors)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.warnings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.errors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.warnings {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.errors {
            os.write_string(1, &v)?;
        };
        for v in &self.warnings {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> FormatSpecsResponse {
        FormatSpecsResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 24)
    }

    fn default_instance() -> &'static FormatSpecsResponse {
        static instance: FormatSpecsResponse = FormatSpecsResponse {
            errors: ::std::vec::Vec::new(),
            warnings: ::std::vec::Vec::new(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for FormatSpecsResponse {
    fn clear(&mut self) {
        self.errors.clear();
        self.warnings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FormatSpecsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FormatSpecsResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / Response when a API message request is not supported.
#[derive(PartialEq,Clone,Default)]
pub struct UnsupportedApiMessageResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnsupportedApiMessageResponse {
    fn default() -> &'a UnsupportedApiMessageResponse {
        <UnsupportedApiMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl UnsupportedApiMessageResponse {
    pub fn new() -> UnsupportedApiMessageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnsupportedApiMessageResponse>(
            "UnsupportedApiMessageResponse",
            25,
            fields,
        )
    }
}

impl ::protobuf::Message for UnsupportedApiMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> UnsupportedApiMessageResponse {
        UnsupportedApiMessageResponse::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 25)
    }

    fn default_instance() -> &'static UnsupportedApiMessageResponse {
        static instance: UnsupportedApiMessageResponse = UnsupportedApiMessageResponse {
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for UnsupportedApiMessageResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnsupportedApiMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsupportedApiMessageResponse {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// / A generic message composing of all possible operations.
/// / One of the Request/Response fields will have value, depending on the MessageType set.
#[derive(PartialEq,Clone,Default)]
pub struct APIMessage {
    // message fields
    /// / Type of API call being made
    messageType: ::std::option::Option<::protobuf::ProtobufEnumOrUnknown<apimessage::APIMessageType>>,
    /// / A unique id to represent this message. A response to the message should copy over this value.
    /// / This is used to synchronize messages & responses
    messageId: ::std::option::Option<i64>,
    /// / [GetProjectRootRequest](#gauge.messages.GetProjectRootRequest)
    pub projectRootRequest: ::protobuf::MessageField<GetProjectRootRequest>,
    /// / [GetProjectRootResponse](#gauge.messages.GetProjectRootResponse)
    pub projectRootResponse: ::protobuf::MessageField<GetProjectRootResponse>,
    /// / [GetInstallationRootRequest](#gauge.messages.GetInstallationRootRequest)
    pub installationRootRequest: ::protobuf::MessageField<GetInstallationRootRequest>,
    /// / [GetInstallationRootResponse](#gauge.messages.GetInstallationRootResponse)
    pub installationRootResponse: ::protobuf::MessageField<GetInstallationRootResponse>,
    /// / [GetAllStepsRequest](#gauge.messages.GetAllStepsRequest)
    pub allStepsRequest: ::protobuf::MessageField<GetAllStepsRequest>,
    /// / [GetAllStepsResponse](#gauge.messages.GetAllStepsResponse)
    pub allStepsResponse: ::protobuf::MessageField<GetAllStepsResponse>,
    /// / [GetAllSpecsRequest](#gauge.messages.GetAllSpecsRequest)
    pub allSpecsRequest: ::protobuf::MessageField<GetAllSpecsRequest>,
    /// / [GetAllSpecsResponse](#gauge.messages.GetAllSpecsResponse)
    pub allSpecsResponse: ::protobuf::MessageField<GetAllSpecsResponse>,
    /// / [GetStepValueRequest](#gauge.messages.GetStepValueRequest)
    pub stepValueRequest: ::protobuf::MessageField<GetStepValueRequest>,
    /// / [GetStepValueResponse](#gauge.messages.GetStepValueResponse)
    pub stepValueResponse: ::protobuf::MessageField<GetStepValueResponse>,
    /// / [GetLanguagePluginLibPathRequest](#gauge.messages.GetLanguagePluginLibPathRequest)
    pub libPathRequest: ::protobuf::MessageField<GetLanguagePluginLibPathRequest>,
    /// / [GetLanguagePluginLibPathResponse](#gauge.messages.GetLanguagePluginLibPathResponse)
    pub libPathResponse: ::protobuf::MessageField<GetLanguagePluginLibPathResponse>,
    /// / [ErrorResponse](#gauge.messages.ErrorResponse)
    pub error: ::protobuf::MessageField<ErrorResponse>,
    /// / [GetAllConceptsRequest](#gauge.messages.GetAllConceptsRequest)
    pub allConceptsRequest: ::protobuf::MessageField<GetAllConceptsRequest>,
    /// / [GetAllConceptsResponse](#gauge.messages.GetAllConceptsResponse)
    pub allConceptsResponse: ::protobuf::MessageField<GetAllConceptsResponse>,
    /// / [PerformRefactoringRequest](#gauge.messages.PerformRefactoringRequest)
    pub performRefactoringRequest: ::protobuf::MessageField<PerformRefactoringRequest>,
    /// / [PerformRefactoringResponse](#gauge.messages.PerformRefactoringResponse)
    pub performRefactoringResponse: ::protobuf::MessageField<PerformRefactoringResponse>,
    /// / [ExtractConceptRequest](#gauge.messages.ExtractConceptRequest)
    pub extractConceptRequest: ::protobuf::MessageField<ExtractConceptRequest>,
    /// / [ExtractConceptResponse](#gauge.messages.ExtractConceptResponse)
    pub extractConceptResponse: ::protobuf::MessageField<ExtractConceptResponse>,
    /// / [FormatSpecsRequest] (#gauge.messages.FormatSpecsRequest)
    pub formatSpecsRequest: ::protobuf::MessageField<FormatSpecsRequest>,
    /// / [FormatSpecsResponse] (#gauge.messages.FormatSpecsResponse)
    pub formatSpecsResponse: ::protobuf::MessageField<FormatSpecsResponse>,
    /// / [UnsupportedApiMessageResponse] (#gauge.messages.UnsupportedApiMessageResponse)
    pub unsupportedApiMessageResponse: ::protobuf::MessageField<UnsupportedApiMessageResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a APIMessage {
    fn default() -> &'a APIMessage {
        <APIMessage as ::protobuf::Message>::default_instance()
    }
}

impl APIMessage {
    pub fn new() -> APIMessage {
        ::std::default::Default::default()
    }

    // required .gauge.messages.APIMessage.APIMessageType messageType = 1;

    pub fn get_messageType(&self) -> apimessage::APIMessageType {
        match self.messageType {
            Some(e) => e.enum_value_or(apimessage::APIMessageType::GetProjectRootRequest),
            None => apimessage::APIMessageType::GetProjectRootRequest,
        }
    }

    pub fn clear_messageType(&mut self) {
        self.messageType = ::std::option::Option::None;
    }

    pub fn has_messageType(&self) -> bool {
        self.messageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageType(&mut self, v: apimessage::APIMessageType) {
        self.messageType = ::std::option::Option::Some(::protobuf::ProtobufEnumOrUnknown::new(v));
    }

    // required int64 messageId = 2;

    pub fn get_messageId(&self) -> i64 {
        self.messageId.unwrap_or(0)
    }

    pub fn clear_messageId(&mut self) {
        self.messageId = ::std::option::Option::None;
    }

    pub fn has_messageId(&self) -> bool {
        self.messageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageId(&mut self, v: i64) {
        self.messageId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_option_enum_accessor::<_, apimessage::APIMessageType>(
            "messageType",
            |m: &APIMessage| { &m.messageType },
            |m: &mut APIMessage| { &mut m.messageType },
            apimessage::APIMessageType::GetProjectRootRequest,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_get_copy_simpler_accessor::<_, _>(
            "messageId",
            |m: &APIMessage| { &m.messageId },
            |m: &mut APIMessage| { &mut m.messageId },
            APIMessage::get_messageId,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetProjectRootRequest>(
            "projectRootRequest",
            |m: &APIMessage| { &m.projectRootRequest },
            |m: &mut APIMessage| { &mut m.projectRootRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetProjectRootResponse>(
            "projectRootResponse",
            |m: &APIMessage| { &m.projectRootResponse },
            |m: &mut APIMessage| { &mut m.projectRootResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetInstallationRootRequest>(
            "installationRootRequest",
            |m: &APIMessage| { &m.installationRootRequest },
            |m: &mut APIMessage| { &mut m.installationRootRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetInstallationRootResponse>(
            "installationRootResponse",
            |m: &APIMessage| { &m.installationRootResponse },
            |m: &mut APIMessage| { &mut m.installationRootResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetAllStepsRequest>(
            "allStepsRequest",
            |m: &APIMessage| { &m.allStepsRequest },
            |m: &mut APIMessage| { &mut m.allStepsRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetAllStepsResponse>(
            "allStepsResponse",
            |m: &APIMessage| { &m.allStepsResponse },
            |m: &mut APIMessage| { &mut m.allStepsResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetAllSpecsRequest>(
            "allSpecsRequest",
            |m: &APIMessage| { &m.allSpecsRequest },
            |m: &mut APIMessage| { &mut m.allSpecsRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetAllSpecsResponse>(
            "allSpecsResponse",
            |m: &APIMessage| { &m.allSpecsResponse },
            |m: &mut APIMessage| { &mut m.allSpecsResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetStepValueRequest>(
            "stepValueRequest",
            |m: &APIMessage| { &m.stepValueRequest },
            |m: &mut APIMessage| { &mut m.stepValueRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetStepValueResponse>(
            "stepValueResponse",
            |m: &APIMessage| { &m.stepValueResponse },
            |m: &mut APIMessage| { &mut m.stepValueResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetLanguagePluginLibPathRequest>(
            "libPathRequest",
            |m: &APIMessage| { &m.libPathRequest },
            |m: &mut APIMessage| { &mut m.libPathRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetLanguagePluginLibPathResponse>(
            "libPathResponse",
            |m: &APIMessage| { &m.libPathResponse },
            |m: &mut APIMessage| { &mut m.libPathResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ErrorResponse>(
            "error",
            |m: &APIMessage| { &m.error },
            |m: &mut APIMessage| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetAllConceptsRequest>(
            "allConceptsRequest",
            |m: &APIMessage| { &m.allConceptsRequest },
            |m: &mut APIMessage| { &mut m.allConceptsRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GetAllConceptsResponse>(
            "allConceptsResponse",
            |m: &APIMessage| { &m.allConceptsResponse },
            |m: &mut APIMessage| { &mut m.allConceptsResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PerformRefactoringRequest>(
            "performRefactoringRequest",
            |m: &APIMessage| { &m.performRefactoringRequest },
            |m: &mut APIMessage| { &mut m.performRefactoringRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PerformRefactoringResponse>(
            "performRefactoringResponse",
            |m: &APIMessage| { &m.performRefactoringResponse },
            |m: &mut APIMessage| { &mut m.performRefactoringResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExtractConceptRequest>(
            "extractConceptRequest",
            |m: &APIMessage| { &m.extractConceptRequest },
            |m: &mut APIMessage| { &mut m.extractConceptRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ExtractConceptResponse>(
            "extractConceptResponse",
            |m: &APIMessage| { &m.extractConceptResponse },
            |m: &mut APIMessage| { &mut m.extractConceptResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FormatSpecsRequest>(
            "formatSpecsRequest",
            |m: &APIMessage| { &m.formatSpecsRequest },
            |m: &mut APIMessage| { &mut m.formatSpecsRequest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FormatSpecsResponse>(
            "formatSpecsResponse",
            |m: &APIMessage| { &m.formatSpecsResponse },
            |m: &mut APIMessage| { &mut m.formatSpecsResponse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UnsupportedApiMessageResponse>(
            "unsupportedApiMessageResponse",
            |m: &APIMessage| { &m.unsupportedApiMessageResponse },
            |m: &mut APIMessage| { &mut m.unsupportedApiMessageResponse },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<APIMessage>(
            "APIMessage",
            26,
            fields,
        )
    }
}

impl ::protobuf::Message for APIMessage {
    fn is_initialized(&self) -> bool {
        if self.messageType.is_none() {
            return false;
        }
        if self.messageId.is_none() {
            return false;
        }
        for v in &self.projectRootRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.projectRootResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.installationRootRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.installationRootResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allStepsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allStepsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allSpecsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allSpecsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stepValueRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stepValueResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libPathRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.libPathResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allConceptsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allConceptsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.performRefactoringRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.performRefactoringResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extractConceptRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extractConceptResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.formatSpecsRequest {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.formatSpecsResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unsupportedApiMessageResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.messageType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.messageId = ::std::option::Option::Some(is.read_int64()?);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.projectRootRequest)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.projectRootResponse)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.installationRootRequest)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.installationRootResponse)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.allStepsRequest)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.allStepsResponse)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.allSpecsRequest)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.allSpecsResponse)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepValueRequest)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.stepValueResponse)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.libPathRequest)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.libPathResponse)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.error)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.allConceptsRequest)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.allConceptsResponse)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.performRefactoringRequest)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.performRefactoringResponse)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.extractConceptRequest)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.extractConceptResponse)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.formatSpecsRequest)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.formatSpecsResponse)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into_field(wire_type, is, &mut self.unsupportedApiMessageResponse)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.messageType {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, v);
        }
        if let Some(v) = self.messageId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.projectRootRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.projectRootResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.installationRootRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.installationRootResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.allStepsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.allStepsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.allSpecsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.allSpecsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stepValueRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stepValueResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.libPathRequest.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.libPathResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.allConceptsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.allConceptsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.performRefactoringRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.performRefactoringResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.extractConceptRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.extractConceptResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.formatSpecsRequest.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.formatSpecsResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.unsupportedApiMessageResponse.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.messageType {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.messageId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.projectRootRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.projectRootResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.installationRootRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.installationRootResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.allStepsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.allStepsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.allSpecsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.allSpecsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.stepValueRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.stepValueResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.libPathRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.libPathResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.error.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.allConceptsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.allConceptsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.performRefactoringRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.performRefactoringResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.extractConceptRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.extractConceptResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.formatSpecsRequest.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.formatSpecsResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.unsupportedApiMessageResponse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn new() -> APIMessage {
        APIMessage::new()
    }

    fn descriptor_static() -> ::protobuf::reflect::MessageDescriptor {
        ::protobuf::reflect::MessageDescriptor::new_generated_2(file_descriptor(), 26)
    }

    fn default_instance() -> &'static APIMessage {
        static instance: APIMessage = APIMessage {
            messageType: ::std::option::Option::None,
            messageId: ::std::option::Option::None,
            projectRootRequest: ::protobuf::MessageField::none(),
            projectRootResponse: ::protobuf::MessageField::none(),
            installationRootRequest: ::protobuf::MessageField::none(),
            installationRootResponse: ::protobuf::MessageField::none(),
            allStepsRequest: ::protobuf::MessageField::none(),
            allStepsResponse: ::protobuf::MessageField::none(),
            allSpecsRequest: ::protobuf::MessageField::none(),
            allSpecsResponse: ::protobuf::MessageField::none(),
            stepValueRequest: ::protobuf::MessageField::none(),
            stepValueResponse: ::protobuf::MessageField::none(),
            libPathRequest: ::protobuf::MessageField::none(),
            libPathResponse: ::protobuf::MessageField::none(),
            error: ::protobuf::MessageField::none(),
            allConceptsRequest: ::protobuf::MessageField::none(),
            allConceptsResponse: ::protobuf::MessageField::none(),
            performRefactoringRequest: ::protobuf::MessageField::none(),
            performRefactoringResponse: ::protobuf::MessageField::none(),
            extractConceptRequest: ::protobuf::MessageField::none(),
            extractConceptResponse: ::protobuf::MessageField::none(),
            formatSpecsRequest: ::protobuf::MessageField::none(),
            formatSpecsResponse: ::protobuf::MessageField::none(),
            unsupportedApiMessageResponse: ::protobuf::MessageField::none(),
            unknown_fields: ::protobuf::UnknownFields::new(),
            cached_size: ::protobuf::rt::CachedSize::new(),
        };
        &instance
    }
}

impl ::protobuf::Clear for APIMessage {
    fn clear(&mut self) {
        self.messageType = ::std::option::Option::None;
        self.messageId = ::std::option::Option::None;
        self.projectRootRequest.clear();
        self.projectRootResponse.clear();
        self.installationRootRequest.clear();
        self.installationRootResponse.clear();
        self.allStepsRequest.clear();
        self.allStepsResponse.clear();
        self.allSpecsRequest.clear();
        self.allSpecsResponse.clear();
        self.stepValueRequest.clear();
        self.stepValueResponse.clear();
        self.libPathRequest.clear();
        self.libPathResponse.clear();
        self.error.clear();
        self.allConceptsRequest.clear();
        self.allConceptsResponse.clear();
        self.performRefactoringRequest.clear();
        self.performRefactoringResponse.clear();
        self.extractConceptRequest.clear();
        self.extractConceptResponse.clear();
        self.formatSpecsRequest.clear();
        self.formatSpecsResponse.clear();
        self.unsupportedApiMessageResponse.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for APIMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIMessage {
    type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `APIMessage`
pub mod apimessage {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    pub enum APIMessageType {
        GetProjectRootRequest = 1,
        GetProjectRootResponse = 2,
        GetInstallationRootRequest = 3,
        GetInstallationRootResponse = 4,
        GetAllStepsRequest = 5,
        GetAllStepResponse = 6,
        GetAllSpecsRequest = 7,
        GetAllSpecsResponse = 8,
        GetStepValueRequest = 9,
        GetStepValueResponse = 10,
        GetLanguagePluginLibPathRequest = 11,
        GetLanguagePluginLibPathResponse = 12,
        ErrorResponse = 13,
        GetAllConceptsRequest = 14,
        GetAllConceptsResponse = 15,
        PerformRefactoringRequest = 16,
        PerformRefactoringResponse = 17,
        ExtractConceptRequest = 18,
        ExtractConceptResponse = 19,
        FormatSpecsRequest = 20,
        FormatSpecsResponse = 21,
        UnsupportedApiMessageResponse = 22,
    }

    impl ::protobuf::ProtobufEnum for APIMessageType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<APIMessageType> {
            match value {
                1 => ::std::option::Option::Some(APIMessageType::GetProjectRootRequest),
                2 => ::std::option::Option::Some(APIMessageType::GetProjectRootResponse),
                3 => ::std::option::Option::Some(APIMessageType::GetInstallationRootRequest),
                4 => ::std::option::Option::Some(APIMessageType::GetInstallationRootResponse),
                5 => ::std::option::Option::Some(APIMessageType::GetAllStepsRequest),
                6 => ::std::option::Option::Some(APIMessageType::GetAllStepResponse),
                7 => ::std::option::Option::Some(APIMessageType::GetAllSpecsRequest),
                8 => ::std::option::Option::Some(APIMessageType::GetAllSpecsResponse),
                9 => ::std::option::Option::Some(APIMessageType::GetStepValueRequest),
                10 => ::std::option::Option::Some(APIMessageType::GetStepValueResponse),
                11 => ::std::option::Option::Some(APIMessageType::GetLanguagePluginLibPathRequest),
                12 => ::std::option::Option::Some(APIMessageType::GetLanguagePluginLibPathResponse),
                13 => ::std::option::Option::Some(APIMessageType::ErrorResponse),
                14 => ::std::option::Option::Some(APIMessageType::GetAllConceptsRequest),
                15 => ::std::option::Option::Some(APIMessageType::GetAllConceptsResponse),
                16 => ::std::option::Option::Some(APIMessageType::PerformRefactoringRequest),
                17 => ::std::option::Option::Some(APIMessageType::PerformRefactoringResponse),
                18 => ::std::option::Option::Some(APIMessageType::ExtractConceptRequest),
                19 => ::std::option::Option::Some(APIMessageType::ExtractConceptResponse),
                20 => ::std::option::Option::Some(APIMessageType::FormatSpecsRequest),
                21 => ::std::option::Option::Some(APIMessageType::FormatSpecsResponse),
                22 => ::std::option::Option::Some(APIMessageType::UnsupportedApiMessageResponse),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [APIMessageType] = &[
                APIMessageType::GetProjectRootRequest,
                APIMessageType::GetProjectRootResponse,
                APIMessageType::GetInstallationRootRequest,
                APIMessageType::GetInstallationRootResponse,
                APIMessageType::GetAllStepsRequest,
                APIMessageType::GetAllStepResponse,
                APIMessageType::GetAllSpecsRequest,
                APIMessageType::GetAllSpecsResponse,
                APIMessageType::GetStepValueRequest,
                APIMessageType::GetStepValueResponse,
                APIMessageType::GetLanguagePluginLibPathRequest,
                APIMessageType::GetLanguagePluginLibPathResponse,
                APIMessageType::ErrorResponse,
                APIMessageType::GetAllConceptsRequest,
                APIMessageType::GetAllConceptsResponse,
                APIMessageType::PerformRefactoringRequest,
                APIMessageType::PerformRefactoringResponse,
                APIMessageType::ExtractConceptRequest,
                APIMessageType::ExtractConceptResponse,
                APIMessageType::FormatSpecsRequest,
                APIMessageType::FormatSpecsResponse,
                APIMessageType::UnsupportedApiMessageResponse,
            ];
            values
        }

        fn enum_descriptor_static() -> ::protobuf::reflect::EnumDescriptor {
            ::protobuf::reflect::EnumDescriptor::new_generated_2(super::file_descriptor(), 0)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for APIMessageType {
        fn default() -> Self {
            APIMessageType::GetProjectRootRequest
        }
    }

    impl ::protobuf::reflect::ProtobufValue for APIMessageType {
        type RuntimeType = ::protobuf::reflect::runtime_types::RuntimeTypeEnum<Self>;
    }

    impl APIMessageType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new_2::<APIMessageType>("APIMessage.APIMessageType", 0)
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tapi.proto\x12\x0egauge.messages\x1a\nspec.proto\"\x17\n\x15GetProjec\
    tRootRequest\":\n\x16GetProjectRootResponse\x12\x20\n\x0bprojectRoot\x18\
    \x01\x20\x02(\tR\x0bprojectRoot\"\x1c\n\x1aGetInstallationRootRequest\"I\
    \n\x1bGetInstallationRootResponse\x12*\n\x10installationRoot\x18\x01\x20\
    \x02(\tR\x10installationRoot\"\x14\n\x12GetAllStepsRequest\"Q\n\x13GetAl\
    lStepsResponse\x12:\n\x08allSteps\x18\x01\x20\x03(\x0b2\x1e.gauge.messag\
    es.ProtoStepValueR\x08allSteps\"\x14\n\x12GetAllSpecsRequest\"F\n\x13Get\
    AllSpecsResponse\x12/\n\x05specs\x18\x01\x20\x03(\x0b2\x19.gauge.message\
    s.ProtoSpecR\x05specs\"\x17\n\x15GetAllConceptsRequest\"Q\n\x16GetAllCon\
    ceptsResponse\x127\n\x08concepts\x18\x01\x20\x03(\x0b2\x1b.gauge.message\
    s.ConceptInfoR\x08concepts\"\x87\x01\n\x0bConceptInfo\x12<\n\tstepValue\
    \x18\x01\x20\x02(\x0b2\x1e.gauge.messages.ProtoStepValueR\tstepValue\x12\
    \x1a\n\x08filepath\x18\x02\x20\x02(\tR\x08filepath\x12\x1e\n\nlineNumber\
    \x18\x03\x20\x02(\x05R\nlineNumber\"Y\n\x13GetStepValueRequest\x12\x1a\n\
    \x08stepText\x18\x01\x20\x02(\tR\x08stepText\x12&\n\x0ehasInlineTable\
    \x18\x02\x20\x01(\x08R\x0ehasInlineTable\"T\n\x14GetStepValueResponse\
    \x12<\n\tstepValue\x18\x01\x20\x02(\x0b2\x1e.gauge.messages.ProtoStepVal\
    ueR\tstepValue\"=\n\x1fGetLanguagePluginLibPathRequest\x12\x1a\n\x08lang\
    uage\x18\x01\x20\x02(\tR\x08language\"6\n\x20GetLanguagePluginLibPathRes\
    ponse\x12\x12\n\x04path\x18\x01\x20\x02(\tR\x04path\"%\n\rErrorResponse\
    \x12\x14\n\x05error\x18\x01\x20\x02(\tR\x05error\"O\n\x19PerformRefactor\
    ingRequest\x12\x18\n\x07oldStep\x18\x01\x20\x02(\tR\x07oldStep\x12\x18\n\
    \x07newStep\x18\x02\x20\x02(\tR\x07newStep\"r\n\x1aPerformRefactoringRes\
    ponse\x12\x18\n\x07success\x18\x01\x20\x02(\x08R\x07success\x12\x16\n\
    \x06errors\x18\x02\x20\x03(\tR\x06errors\x12\"\n\x0cfilesChanged\x18\x03\
    \x20\x03(\tR\x0cfilesChanged\"/\n\x19ExtractConceptInfoRequest\x12\x12\n\
    \x04text\x18\x01\x20\x02(\tR\x04text\"\x9d\x02\n\x15ExtractConceptReques\
    t\x126\n\x0bconceptName\x18\x01\x20\x02(\x0b2\x14.gauge.messages.stepR\
    \x0bconceptName\x12*\n\x05steps\x18\x02\x20\x03(\x0b2\x14.gauge.messages\
    .stepR\x05steps\x120\n\x13changeAcrossProject\x18\x03\x20\x02(\x08R\x13c\
    hangeAcrossProject\x12(\n\x0fconceptFileName\x18\x04\x20\x02(\tR\x0fconc\
    eptFileName\x12D\n\x10selectedTextInfo\x18\x05\x20\x01(\x0b2\x18.gauge.m\
    essages.textInfoR\x10selectedTextInfo\"l\n\x08textInfo\x12\x1a\n\x08file\
    Name\x18\x01\x20\x02(\tR\x08fileName\x12&\n\x0estartingLineNo\x18\x02\
    \x20\x02(\x05R\x0estartingLineNo\x12\x1c\n\tendLineNo\x18\x03\x20\x02(\
    \x05R\tendLineNo\"X\n\x04step\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04n\
    ame\x12\x14\n\x05table\x18\x02\x20\x01(\tR\x05table\x12&\n\x0eparamTable\
    Name\x18\x03\x20\x01(\tR\x0eparamTableName\"p\n\x16ExtractConceptRespons\
    e\x12\x1c\n\tisSuccess\x18\x01\x20\x02(\x08R\tisSuccess\x12\x14\n\x05err\
    or\x18\x02\x20\x01(\tR\x05error\x12\"\n\x0cfilesChanged\x18\x03\x20\x03(\
    \tR\x0cfilesChanged\"*\n\x12FormatSpecsRequest\x12\x14\n\x05specs\x18\
    \x01\x20\x03(\tR\x05specs\"I\n\x13FormatSpecsResponse\x12\x16\n\x06error\
    s\x18\x01\x20\x03(\tR\x06errors\x12\x1a\n\x08warnings\x18\x02\x20\x03(\t\
    R\x08warnings\"\x1f\n\x1dUnsupportedApiMessageResponse\"\xa5\x15\n\nAPIM\
    essage\x12K\n\x0bmessageType\x18\x01\x20\x02(\x0e2).gauge.messages.APIMe\
    ssage.APIMessageTypeR\x0bmessageType\x12\x1c\n\tmessageId\x18\x02\x20\
    \x02(\x03R\tmessageId\x12U\n\x12projectRootRequest\x18\x03\x20\x01(\x0b2\
    %.gauge.messages.GetProjectRootRequestR\x12projectRootRequest\x12X\n\x13\
    projectRootResponse\x18\x04\x20\x01(\x0b2&.gauge.messages.GetProjectRoot\
    ResponseR\x13projectRootResponse\x12d\n\x17installationRootRequest\x18\
    \x05\x20\x01(\x0b2*.gauge.messages.GetInstallationRootRequestR\x17instal\
    lationRootRequest\x12g\n\x18installationRootResponse\x18\x06\x20\x01(\
    \x0b2+.gauge.messages.GetInstallationRootResponseR\x18installationRootRe\
    sponse\x12L\n\x0fallStepsRequest\x18\x07\x20\x01(\x0b2\".gauge.messages.\
    GetAllStepsRequestR\x0fallStepsRequest\x12O\n\x10allStepsResponse\x18\
    \x08\x20\x01(\x0b2#.gauge.messages.GetAllStepsResponseR\x10allStepsRespo\
    nse\x12L\n\x0fallSpecsRequest\x18\t\x20\x01(\x0b2\".gauge.messages.GetAl\
    lSpecsRequestR\x0fallSpecsRequest\x12O\n\x10allSpecsResponse\x18\n\x20\
    \x01(\x0b2#.gauge.messages.GetAllSpecsResponseR\x10allSpecsResponse\x12O\
    \n\x10stepValueRequest\x18\x0b\x20\x01(\x0b2#.gauge.messages.GetStepValu\
    eRequestR\x10stepValueRequest\x12R\n\x11stepValueResponse\x18\x0c\x20\
    \x01(\x0b2$.gauge.messages.GetStepValueResponseR\x11stepValueResponse\
    \x12W\n\x0elibPathRequest\x18\r\x20\x01(\x0b2/.gauge.messages.GetLanguag\
    ePluginLibPathRequestR\x0elibPathRequest\x12Z\n\x0flibPathResponse\x18\
    \x0e\x20\x01(\x0b20.gauge.messages.GetLanguagePluginLibPathResponseR\x0f\
    libPathResponse\x123\n\x05error\x18\x0f\x20\x01(\x0b2\x1d.gauge.messages\
    .ErrorResponseR\x05error\x12U\n\x12allConceptsRequest\x18\x10\x20\x01(\
    \x0b2%.gauge.messages.GetAllConceptsRequestR\x12allConceptsRequest\x12X\
    \n\x13allConceptsResponse\x18\x11\x20\x01(\x0b2&.gauge.messages.GetAllCo\
    nceptsResponseR\x13allConceptsResponse\x12g\n\x19performRefactoringReque\
    st\x18\x12\x20\x01(\x0b2).gauge.messages.PerformRefactoringRequestR\x19p\
    erformRefactoringRequest\x12j\n\x1aperformRefactoringResponse\x18\x13\
    \x20\x01(\x0b2*.gauge.messages.PerformRefactoringResponseR\x1aperformRef\
    actoringResponse\x12[\n\x15extractConceptRequest\x18\x14\x20\x01(\x0b2%.\
    gauge.messages.ExtractConceptRequestR\x15extractConceptRequest\x12^\n\
    \x16extractConceptResponse\x18\x15\x20\x01(\x0b2&.gauge.messages.Extract\
    ConceptResponseR\x16extractConceptResponse\x12R\n\x12formatSpecsRequest\
    \x18\x16\x20\x01(\x0b2\".gauge.messages.FormatSpecsRequestR\x12formatSpe\
    csRequest\x12U\n\x13formatSpecsResponse\x18\x17\x20\x01(\x0b2#.gauge.mes\
    sages.FormatSpecsResponseR\x13formatSpecsResponse\x12s\n\x1dunsupportedA\
    piMessageResponse\x18\x18\x20\x01(\x0b2-.gauge.messages.UnsupportedApiMe\
    ssageResponseR\x1dunsupportedApiMessageResponse\"\xfb\x04\n\x0eAPIMessag\
    eType\x12\x19\n\x15GetProjectRootRequest\x10\x01\x12\x1a\n\x16GetProject\
    RootResponse\x10\x02\x12\x1e\n\x1aGetInstallationRootRequest\x10\x03\x12\
    \x1f\n\x1bGetInstallationRootResponse\x10\x04\x12\x16\n\x12GetAllStepsRe\
    quest\x10\x05\x12\x16\n\x12GetAllStepResponse\x10\x06\x12\x16\n\x12GetAl\
    lSpecsRequest\x10\x07\x12\x17\n\x13GetAllSpecsResponse\x10\x08\x12\x17\n\
    \x13GetStepValueRequest\x10\t\x12\x18\n\x14GetStepValueResponse\x10\n\
    \x12#\n\x1fGetLanguagePluginLibPathRequest\x10\x0b\x12$\n\x20GetLanguage\
    PluginLibPathResponse\x10\x0c\x12\x11\n\rErrorResponse\x10\r\x12\x19\n\
    \x15GetAllConceptsRequest\x10\x0e\x12\x1a\n\x16GetAllConceptsResponse\
    \x10\x0f\x12\x1d\n\x19PerformRefactoringRequest\x10\x10\x12\x1e\n\x1aPer\
    formRefactoringResponse\x10\x11\x12\x19\n\x15ExtractConceptRequest\x10\
    \x12\x12\x1a\n\x16ExtractConceptResponse\x10\x13\x12\x16\n\x12FormatSpec\
    sRequest\x10\x14\x12\x17\n\x13FormatSpecsResponse\x10\x15\x12!\n\x1dUnsu\
    pportedApiMessageResponse\x10\x16J\xd0]\n\x07\x12\x05\x16\0\x98\x02\x01\
    \n\x85\x07\n\x01\x0c\x12\x03\x16\0\x122#\x20Copyright\x202015\x20Thought\
    Works,\x20Inc.\n2#\x20This\x20file\x20is\x20part\x20of\x20gauge-proto.\n\
    2\xf3\x01\x20gauge-proto\x20is\x20free\x20software:\x20you\x20can\x20red\
    istribute\x20it\x20and/or\x20modify\n\x20it\x20under\x20the\x20terms\x20\
    of\x20the\x20GNU\x20General\x20Public\x20License\x20as\x20published\x20b\
    y\n\x20the\x20Free\x20Software\x20Foundation,\x20either\x20version\x203\
    \x20of\x20the\x20License,\x20or\n\x20(at\x20your\x20option)\x20any\x20la\
    ter\x20version.\n2\xed\x01\x20gauge-proto\x20is\x20distributed\x20in\x20\
    the\x20hope\x20that\x20it\x20will\x20be\x20useful,\n\x20but\x20WITHOUT\
    \x20ANY\x20WARRANTY;\x20without\x20even\x20the\x20implied\x20warranty\
    \x20of\n\x20MERCHANTABILITY\x20or\x20FITNESS\x20FOR\x20A\x20PARTICULAR\
    \x20PURPOSE.\x20\x20See\x20the\n\x20GNU\x20General\x20Public\x20License\
    \x20for\x20more\x20details.\n2\x89\x01\x20You\x20should\x20have\x20recei\
    ved\x20a\x20copy\x20of\x20the\x20GNU\x20General\x20Public\x20License\n\
    \x20along\x20with\x20gauge-proto.\x20\x20If\x20not,\x20see\x20<http://ww\
    w.gnu.org/licenses/>.\n2^/\x20Defines\x20communication\x20messages\x20fo\
    r\x20API\n/\x20Every\x20API\x20call\x20will\x20have\x20a\x20Request\x20&\
    \x20Response\x20pair\n2_\x20The\x20comments\x20are\x20exported\x20to\x20\
    Markdown,\x20hence\x20they\x20may\x20contain\x20markdown\x20syntax\x20an\
    d\x20cross-refs.\n\n\x08\n\x01\x02\x12\x03\x17\0\x17\n\t\n\x02\x03\0\x12\
    \x03\x18\0\x14\n?\n\x02\x04\0\x12\x04\x1b\0\x1c\x01\x1a3/\x20Request\x20\
    to\x20get\x20the\x20Root\x20Directory\x20of\x20the\x20project\n\n\n\n\
    \x03\x04\0\x01\x12\x03\x1b\x08\x1d\n1\n\x02\x04\x01\x12\x04\x1f\0\"\x01\
    \x1a%/\x20Response\x20of\x20GetProjectRootRequest.\n\n\n\n\x03\x04\x01\
    \x01\x12\x03\x1f\x08\x1e\nF\n\x04\x04\x01\x02\0\x12\x03!\x02\"\x1a9/\x20\
    Holds\x20the\x20absolute\x20path\x20of\x20the\x20Project\x20Root\x20dire\
    ctory.\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03!\x02\n\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03!\x0b\x11\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03!\
    \x12\x1d\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03!\x20!\nJ\n\x02\x04\x02\
    \x12\x04%\0&\x01\x1a>/\x20Request\x20to\x20get\x20the\x20Root\x20Directo\
    ry\x20of\x20the\x20Gauge\x20installation\n\n\n\n\x03\x04\x02\x01\x12\x03\
    %\x08\"\n5\n\x02\x04\x03\x12\x04)\0,\x01\x1a)/\x20Response\x20of\x20GetI\
    nstallationRootRequest\n\n\n\n\x03\x04\x03\x01\x12\x03)\x08#\nK\n\x04\
    \x04\x03\x02\0\x12\x03+\x02'\x1a>/\x20Holds\x20the\x20absolute\x20path\
    \x20of\x20the\x20Gauge\x20installation\x20directory\n\n\x0c\n\x05\x04\
    \x03\x02\0\x04\x12\x03+\x02\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03+\x0b\
    \x11\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03+\x12\"\n\x0c\n\x05\x04\x03\
    \x02\0\x03\x12\x03+%&\n6\n\x02\x04\x04\x12\x04/\00\x01\x1a*/\x20Request\
    \x20to\x20get\x20all\x20Steps\x20in\x20the\x20project\n\n\n\n\x03\x04\
    \x04\x01\x12\x03/\x08\x1a\n-\n\x02\x04\x05\x12\x043\06\x01\x1a!/\x20Resp\
    onse\x20to\x20GetAllStepsRequest\n\n\n\n\x03\x04\x05\x01\x12\x033\x08\
    \x1b\nL\n\x04\x04\x05\x02\0\x12\x035\x026\x1a?/\x20Holds\x20a\x20collect\
    ion\x20of\x20Steps\x20that\x20are\x20defined\x20in\x20the\x20project.\n\
    \n\x0c\n\x05\x04\x05\x02\0\x04\x12\x035\x02\n\n\x0c\n\x05\x04\x05\x02\0\
    \x06\x12\x035\x0b(\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x035)1\n\x0c\n\x05\
    \x04\x05\x02\0\x03\x12\x03545\n6\n\x02\x04\x06\x12\x049\0:\x01\x1a*/\x20\
    Request\x20to\x20get\x20all\x20Specs\x20in\x20the\x20project\n\n\n\n\x03\
    \x04\x06\x01\x12\x039\x08\x1a\n-\n\x02\x04\x07\x12\x04=\0@\x01\x1a!/\x20\
    Response\x20to\x20GetAllSpecsRequest\n\n\n\n\x03\x04\x07\x01\x12\x03=\
    \x08\x1b\nL\n\x04\x04\x07\x02\0\x12\x03?\x02.\x1a?/\x20Holds\x20a\x20col\
    lection\x20of\x20Specs\x20that\x20are\x20defined\x20in\x20the\x20project\
    .\n\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03?\x02\n\n\x0c\n\x05\x04\x07\x02\
    \0\x06\x12\x03?\x0b#\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03?$)\n\x0c\n\
    \x05\x04\x07\x02\0\x03\x12\x03?,-\n9\n\x02\x04\x08\x12\x04C\0D\x01\x1a-/\
    \x20Request\x20to\x20get\x20all\x20Concepts\x20in\x20the\x20project\n\n\
    \n\n\x03\x04\x08\x01\x12\x03C\x08\x1d\n1\n\x02\x04\t\x12\x04G\0J\x01\x1a\
    %/\x20Response\x20to\x20GetAllConceptsResponse\n\n\n\n\x03\x04\t\x01\x12\
    \x03G\x08\x1e\nO\n\x04\x04\t\x02\0\x12\x03I\x02$\x1aB/\x20Holds\x20a\x20\
    collection\x20of\x20Concepts\x20that\x20are\x20defined\x20in\x20the\x20p\
    roject.\n\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03I\x02\n\n\x0c\n\x05\x04\t\
    \x02\0\x06\x12\x03I\x0b\x16\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03I\x17\x1f\
    \n\x0c\n\x05\x04\t\x02\0\x03\x12\x03I\"#\n#\n\x02\x04\n\x12\x04M\0T\x01\
    \x1a\x17/\x20Details\x20of\x20a\x20Concept\n\n\n\n\x03\x04\n\x01\x12\x03\
    M\x08\x13\n/\n\x04\x04\n\x02\0\x12\x03O\x027\x1a\"/\x20The\x20text\x20th\
    at\x20defines\x20a\x20concept\n\n\x0c\n\x05\x04\n\x02\0\x04\x12\x03O\x02\
    \n\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03O\x0b(\n\x0c\n\x05\x04\n\x02\0\x01\
    \x12\x03O)2\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03O56\nG\n\x04\x04\n\x02\
    \x01\x12\x03Q\x02\x1f\x1a:/\x20The\x20absolute\x20path\x20to\x20the\x20f\
    ile\x20that\x20contains\x20the\x20Concept\n\n\x0c\n\x05\x04\n\x02\x01\
    \x04\x12\x03Q\x02\n\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x03Q\x0b\x11\n\x0c\
    \n\x05\x04\n\x02\x01\x01\x12\x03Q\x12\x1a\n\x0c\n\x05\x04\n\x02\x01\x03\
    \x12\x03Q\x1d\x1e\nI\n\x04\x04\n\x02\x02\x12\x03S\x02\x20\x1a</\x20The\
    \x20line\x20number\x20in\x20the\x20file\x20where\x20the\x20concept\x20is\
    \x20defined.\n\n\x0c\n\x05\x04\n\x02\x02\x04\x12\x03S\x02\n\n\x0c\n\x05\
    \x04\n\x02\x02\x05\x12\x03S\x0b\x10\n\x0c\n\x05\x04\n\x02\x02\x01\x12\
    \x03S\x11\x1b\n\x0c\n\x05\x04\n\x02\x02\x03\x12\x03S\x1e\x1f\n+\n\x02\
    \x04\x0b\x12\x04W\0\\\x01\x1a\x1f/\x20Request\x20to\x20get\x20a\x20Step\
    \x20Value.\n\n\n\n\x03\x04\x0b\x01\x12\x03W\x08\x1b\n%\n\x04\x04\x0b\x02\
    \0\x12\x03Y\x02\x1f\x1a\x18/\x20The\x20text\x20of\x20the\x20Step.\n\n\
    \x0c\n\x05\x04\x0b\x02\0\x04\x12\x03Y\x02\n\n\x0c\n\x05\x04\x0b\x02\0\
    \x05\x12\x03Y\x0b\x11\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03Y\x12\x1a\n\
    \x0c\n\x05\x04\x0b\x02\0\x03\x12\x03Y\x1d\x1e\nA\n\x04\x04\x0b\x02\x01\
    \x12\x03[\x02#\x1a4/\x20Flag\x20to\x20indicate\x20if\x20the\x20Step\x20h\
    as\x20an\x20inline\x20table.\n\n\x0c\n\x05\x04\x0b\x02\x01\x04\x12\x03[\
    \x02\n\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03[\x0b\x0f\n\x0c\n\x05\x04\
    \x0b\x02\x01\x01\x12\x03[\x10\x1e\n\x0c\n\x05\x04\x0b\x02\x01\x03\x12\
    \x03[!\"\n.\n\x02\x04\x0c\x12\x04_\0b\x01\x1a\"/\x20Response\x20to\x20Ge\
    tStepValueRequest\n\n\n\n\x03\x04\x0c\x01\x12\x03_\x08\x1c\n?\n\x04\x04\
    \x0c\x02\0\x12\x03a\x027\x1a2/\x20The\x20Step\x20corresponding\x20to\x20\
    the\x20request\x20provided.\n\n\x0c\n\x05\x04\x0c\x02\0\x04\x12\x03a\x02\
    \n\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\x03a\x0b(\n\x0c\n\x05\x04\x0c\x02\0\
    \x01\x12\x03a)2\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03a56\nM\n\x02\x04\r\
    \x12\x04e\0h\x01\x1aA/\x20Request\x20to\x20get\x20the\x20location\x20of\
    \x20language\x20plugin's\x20Lib\x20directory\n\n\n\n\x03\x04\r\x01\x12\
    \x03e\x08'\n=\n\x04\x04\r\x02\0\x12\x03g\x02\x1f\x1a0/\x20The\x20languag\
    e\x20to\x20locate\x20the\x20lib\x20directory\x20for.\n\n\x0c\n\x05\x04\r\
    \x02\0\x04\x12\x03g\x02\n\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03g\x0b\x11\n\
    \x0c\n\x05\x04\r\x02\0\x01\x12\x03g\x12\x1a\n\x0c\n\x05\x04\r\x02\0\x03\
    \x12\x03g\x1d\x1e\n:\n\x02\x04\x0e\x12\x04k\0n\x01\x1a./\x20Response\x20\
    to\x20GetLanguagePluginLibPathRequest\n\n\n\n\x03\x04\x0e\x01\x12\x03k\
    \x08(\nC\n\x04\x04\x0e\x02\0\x12\x03m\x02\x1b\x1a6/\x20Absolute\x20path\
    \x20to\x20the\x20Lib\x20directory\x20of\x20the\x20language.\n\n\x0c\n\
    \x05\x04\x0e\x02\0\x04\x12\x03m\x02\n\n\x0c\n\x05\x04\x0e\x02\0\x05\x12\
    \x03m\x0b\x11\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03m\x12\x16\n\x0c\n\x05\
    \x04\x0e\x02\0\x03\x12\x03m\x19\x1a\n)\n\x02\x04\x0f\x12\x04q\0t\x01\x1a\
    \x1d/\x20A\x20generic\x20failure\x20response\n\n\n\n\x03\x04\x0f\x01\x12\
    \x03q\x08\x15\n$\n\x04\x04\x0f\x02\0\x12\x03s\x02\x1c\x1a\x17/\x20Actual\
    \x20error\x20message\n\n\x0c\n\x05\x04\x0f\x02\0\x04\x12\x03s\x02\n\n\
    \x0c\n\x05\x04\x0f\x02\0\x05\x12\x03s\x0b\x11\n\x0c\n\x05\x04\x0f\x02\0\
    \x01\x12\x03s\x12\x17\n\x0c\n\x05\x04\x0f\x02\0\x03\x12\x03s\x1a\x1b\n,\
    \n\x02\x04\x10\x12\x04w\0|\x01\x1a\x20/\x20Request\x20to\x20perform\x20a\
    \x20Refactor\n\n\n\n\x03\x04\x10\x01\x12\x03w\x08!\n\x20\n\x04\x04\x10\
    \x02\0\x12\x03y\x02\x1e\x1a\x13/\x20Step\x20to\x20refactor\n\n\x0c\n\x05\
    \x04\x10\x02\0\x04\x12\x03y\x02\n\n\x0c\n\x05\x04\x10\x02\0\x05\x12\x03y\
    \x0b\x11\n\x0c\n\x05\x04\x10\x02\0\x01\x12\x03y\x12\x19\n\x0c\n\x05\x04\
    \x10\x02\0\x03\x12\x03y\x1c\x1d\n!\n\x04\x04\x10\x02\x01\x12\x03{\x02\
    \x1e\x1a\x14/\x20Change\x20to\x20be\x20made\n\n\x0c\n\x05\x04\x10\x02\
    \x01\x04\x12\x03{\x02\n\n\x0c\n\x05\x04\x10\x02\x01\x05\x12\x03{\x0b\x11\
    \n\x0c\n\x05\x04\x10\x02\x01\x01\x12\x03{\x12\x19\n\x0c\n\x05\x04\x10\
    \x02\x01\x03\x12\x03{\x1c\x1d\n5\n\x02\x04\x11\x12\x05\x7f\0\x86\x01\x01\
    \x1a(/\x20Response\x20to\x20PerformRefactoringRequest\n\n\n\n\x03\x04\
    \x11\x01\x12\x03\x7f\x08\"\n(\n\x04\x04\x11\x02\0\x12\x04\x81\x01\x02\
    \x1c\x1a\x1a/\x20Flag\x20indicating\x20Success\n\n\r\n\x05\x04\x11\x02\0\
    \x04\x12\x04\x81\x01\x02\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\x81\x01\
    \x0b\x0f\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x81\x01\x10\x17\n\r\n\x05\
    \x04\x11\x02\0\x03\x12\x04\x81\x01\x1a\x1b\nC\n\x04\x04\x11\x02\x01\x12\
    \x04\x83\x01\x02\x1d\x1a5/\x20Error\x20message\x20if\x20the\x20refactori\
    ng\x20was\x20unsuccessful.\n\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\x83\
    \x01\x02\n\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\x83\x01\x0b\x11\n\r\n\
    \x05\x04\x11\x02\x01\x01\x12\x04\x83\x01\x12\x18\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\x83\x01\x1b\x1c\nR\n\x04\x04\x11\x02\x02\x12\x04\x85\
    \x01\x02#\x1aD/\x20Collection\x20of\x20files\x20that\x20were\x20changed\
    \x20as\x20part\x20of\x20the\x20Refactoring.\n\n\r\n\x05\x04\x11\x02\x02\
    \x04\x12\x04\x85\x01\x02\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\x85\x01\
    \x0b\x11\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\x85\x01\x12\x1e\n\r\n\x05\
    \x04\x11\x02\x02\x03\x12\x04\x85\x01!\"\n\xb0\x01\n\x02\x04\x12\x12\x06\
    \x8a\x01\0\x8d\x01\x01\x1a\xa1\x01/\x20Request\x20to\x20perform\x20Extra\
    ct\x20to\x20Concept\x20refactoring\n/\x20The\x20runner\x20does\x20not\
    \x20do\x20the\x20refactoring\x20here,\x20instead\x20it\x20provides\x20in\
    puts\x20enabling\x20the\x20IDE\x20to\x20do\x20refactoring\n\n\x0b\n\x03\
    \x04\x12\x01\x12\x04\x8a\x01\x08!\nU\n\x04\x04\x12\x02\0\x12\x04\x8c\x01\
    \x02\x1b\x1aG/\x20The\x20text\x20blob\x20containing\x20steps\x20that\x20\
    should\x20be\x20refactored\x20to\x20concept.\n\n\r\n\x05\x04\x12\x02\0\
    \x04\x12\x04\x8c\x01\x02\n\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\x8c\x01\
    \x0b\x11\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\x8c\x01\x12\x16\n\r\n\x05\
    \x04\x12\x02\0\x03\x12\x04\x8c\x01\x19\x1a\nB\n\x02\x04\x13\x12\x06\x90\
    \x01\0\x9b\x01\x01\x1a4/\x20Request\x20to\x20perform\x20Extract\x20to\
    \x20Concept\x20refactoring\n\n\x0b\n\x03\x04\x13\x01\x12\x04\x90\x01\x08\
    \x1d\n3\n\x04\x04\x13\x02\0\x12\x04\x92\x01\x02\x20\x1a%/\x20The\x20Conc\
    ept\x20name\x20given\x20by\x20the\x20user\n\n\r\n\x05\x04\x13\x02\0\x04\
    \x12\x04\x92\x01\x02\n\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\x92\x01\x0b\
    \x0f\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x92\x01\x10\x1b\n\r\n\x05\x04\
    \x13\x02\0\x03\x12\x04\x92\x01\x1e\x1f\n!\n\x04\x04\x13\x02\x01\x12\x04\
    \x94\x01\x02\x1a\x1a\x13/\x20steps\x20to\x20extract\n\n\r\n\x05\x04\x13\
    \x02\x01\x04\x12\x04\x94\x01\x02\n\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\
    \x94\x01\x0b\x0f\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\x94\x01\x10\x15\n\
    \r\n\x05\x04\x13\x02\x01\x03\x12\x04\x94\x01\x18\x19\nM\n\x04\x04\x13\
    \x02\x02\x12\x04\x96\x01\x02(\x1a?/\x20Flag\x20indicating\x20if\x20refac\
    toring\x20should\x20be\x20done\x20across\x20project\n\n\r\n\x05\x04\x13\
    \x02\x02\x04\x12\x04\x96\x01\x02\n\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\
    \x96\x01\x0b\x0f\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\x96\x01\x10#\n\r\
    \n\x05\x04\x13\x02\x02\x03\x12\x04\x96\x01&'\nN\n\x04\x04\x13\x02\x03\
    \x12\x04\x98\x01\x02&\x1a@/\x20The\x20concept\x20filename\x20in\x20which\
    \x20extracted\x20concept\x20will\x20be\x20added\n\n\r\n\x05\x04\x13\x02\
    \x03\x04\x12\x04\x98\x01\x02\n\n\r\n\x05\x04\x13\x02\x03\x05\x12\x04\x98\
    \x01\x0b\x11\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\x98\x01\x12!\n\r\n\
    \x05\x04\x13\x02\x03\x03\x12\x04\x98\x01$%\n]\n\x04\x04\x13\x02\x04\x12\
    \x04\x9a\x01\x02)\x1aO/\x20Info\x20related\x20to\x20selected\x20text,\
    \x20required\x20only\x20if\x20changeAcrossProject\x20is\x20false\n\n\r\n\
    \x05\x04\x13\x02\x04\x04\x12\x04\x9a\x01\x02\n\n\r\n\x05\x04\x13\x02\x04\
    \x06\x12\x04\x9a\x01\x0b\x13\n\r\n\x05\x04\x13\x02\x04\x01\x12\x04\x9a\
    \x01\x14$\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\x9a\x01'(\n\x0c\n\x02\
    \x04\x14\x12\x06\x9d\x01\0\xa3\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\
    \x9d\x01\x08\x10\nC\n\x04\x04\x14\x02\0\x12\x04\x9f\x01\x02\x1f\x1a5/\
    \x20The\x20filename\x20from\x20where\x20concept\x20is\x20being\x20extrac\
    ted\n\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\x9f\x01\x02\n\n\r\n\x05\x04\
    \x14\x02\0\x05\x12\x04\x9f\x01\x0b\x11\n\r\n\x05\x04\x14\x02\0\x01\x12\
    \x04\x9f\x01\x12\x1a\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x9f\x01\x1d\x1e\
    \nM\n\x04\x04\x14\x02\x01\x12\x04\xa1\x01\x02$\x1a?/\x20storing\x20the\
    \x20starting\x20and\x20ending\x20line\x20number\x20of\x20selected\x20tex\
    t\n\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xa1\x01\x02\n\n\r\n\x05\x04\
    \x14\x02\x01\x05\x12\x04\xa1\x01\x0b\x10\n\r\n\x05\x04\x14\x02\x01\x01\
    \x12\x04\xa1\x01\x11\x1f\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xa1\x01\"\
    #\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xa2\x01\x02\x1f\n\r\n\x05\x04\x14\
    \x02\x02\x04\x12\x04\xa2\x01\x02\n\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\
    \xa2\x01\x0b\x10\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xa2\x01\x11\x1a\n\
    \r\n\x05\x04\x14\x02\x02\x03\x12\x04\xa2\x01\x1d\x1e\n\x0c\n\x02\x04\x15\
    \x12\x06\xa5\x01\0\xac\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xa5\x01\
    \x08\x0c\n!\n\x04\x04\x15\x02\0\x12\x04\xa7\x01\x02\x1b\x1a\x13/\x20name\
    \x20of\x20the\x20step\n\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xa7\x01\x02\
    \n\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xa7\x01\x0b\x11\n\r\n\x05\x04\x15\
    \x02\0\x01\x12\x04\xa7\x01\x12\x16\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\
    \xa7\x01\x19\x1a\n4\n\x04\x04\x15\x02\x01\x12\x04\xa9\x01\x02\x1c\x1a&/\
    \x20\x20table\x20present\x20in\x20step\x20as\x20parameter\n\n\r\n\x05\
    \x04\x15\x02\x01\x04\x12\x04\xa9\x01\x02\n\n\r\n\x05\x04\x15\x02\x01\x05\
    \x12\x04\xa9\x01\x0b\x11\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xa9\x01\
    \x12\x17\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xa9\x01\x1a\x1b\nT\n\x04\
    \x04\x15\x02\x02\x12\x04\xab\x01\x02%\x1aF/\x20name\x20of\x20table\x20in\
    \x20concept\x20heading,\x20if\x20it\x20comes\x20as\x20a\x20param\x20to\
    \x20concept\n\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xab\x01\x02\n\n\r\n\
    \x05\x04\x15\x02\x02\x05\x12\x04\xab\x01\x0b\x11\n\r\n\x05\x04\x15\x02\
    \x02\x01\x12\x04\xab\x01\x12\x20\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\
    \xab\x01#$\nC\n\x02\x04\x16\x12\x06\xaf\x01\0\xb6\x01\x01\x1a5/\x20Respo\
    nse\x20to\x20perform\x20Extract\x20to\x20Concept\x20refactoring\n\n\x0b\
    \n\x03\x04\x16\x01\x12\x04\xaf\x01\x08\x1e\n(\n\x04\x04\x16\x02\0\x12\
    \x04\xb1\x01\x02\x1e\x1a\x1a/\x20Flag\x20indicating\x20Success\n\n\r\n\
    \x05\x04\x16\x02\0\x04\x12\x04\xb1\x01\x02\n\n\r\n\x05\x04\x16\x02\0\x05\
    \x12\x04\xb1\x01\x0b\x0f\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xb1\x01\x10\
    \x19\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xb1\x01\x1c\x1d\nC\n\x04\x04\
    \x16\x02\x01\x12\x04\xb3\x01\x02\x1c\x1a5/\x20Error\x20message\x20if\x20\
    the\x20refactoring\x20was\x20unsuccessful.\n\n\r\n\x05\x04\x16\x02\x01\
    \x04\x12\x04\xb3\x01\x02\n\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xb3\x01\
    \x0b\x11\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xb3\x01\x12\x17\n\r\n\x05\
    \x04\x16\x02\x01\x03\x12\x04\xb3\x01\x1a\x1b\nR\n\x04\x04\x16\x02\x02\
    \x12\x04\xb5\x01\x02#\x1aD/\x20Collection\x20of\x20files\x20that\x20were\
    \x20changed\x20as\x20part\x20of\x20the\x20Refactoring.\n\n\r\n\x05\x04\
    \x16\x02\x02\x04\x12\x04\xb5\x01\x02\n\n\r\n\x05\x04\x16\x02\x02\x05\x12\
    \x04\xb5\x01\x0b\x11\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xb5\x01\x12\
    \x1e\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xb5\x01!\"\n-\n\x02\x04\x17\
    \x12\x06\xb9\x01\0\xbc\x01\x01\x1a\x1f/\x20Request\x20to\x20format\x20sp\
    ec\x20files\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xb9\x01\x08\x1a\n&\n\x04\
    \x04\x17\x02\0\x12\x04\xbb\x01\x04\x1e\x1a\x18/\x20Specs\x20to\x20be\x20\
    formatted\n\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xbb\x01\x04\x0c\n\r\n\
    \x05\x04\x17\x02\0\x05\x12\x04\xbb\x01\r\x13\n\r\n\x05\x04\x17\x02\0\x01\
    \x12\x04\xbb\x01\x14\x19\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xbb\x01\x1c\
    \x1d\n2\n\x02\x04\x18\x12\x06\xbf\x01\0\xc4\x01\x01\x1a$/\x20Response\
    \x20on\x20formatting\x20spec\x20files\n\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \xbf\x01\x08\x1b\n.\n\x04\x04\x18\x02\0\x12\x04\xc1\x01\x04\x1f\x1a\x20/\
    \x20Errors\x20occurred\x20on\x20formatting\n\n\r\n\x05\x04\x18\x02\0\x04\
    \x12\x04\xc1\x01\x04\x0c\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xc1\x01\r\
    \x13\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xc1\x01\x14\x1a\n\r\n\x05\x04\
    \x18\x02\0\x03\x12\x04\xc1\x01\x1d\x1e\n0\n\x04\x04\x18\x02\x01\x12\x04\
    \xc3\x01\x04!\x1a\"/\x20Warnings\x20occurred\x20on\x20formatting\n\n\r\n\
    \x05\x04\x18\x02\x01\x04\x12\x04\xc3\x01\x04\x0c\n\r\n\x05\x04\x18\x02\
    \x01\x05\x12\x04\xc3\x01\r\x13\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xc3\
    \x01\x14\x1c\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xc3\x01\x1f\x20\nF\n\
    \x02\x04\x19\x12\x06\xc7\x01\0\xc8\x01\x01\x1a8/\x20Response\x20when\x20\
    a\x20API\x20message\x20request\x20is\x20not\x20supported.\n\n\x0b\n\x03\
    \x04\x19\x01\x12\x04\xc7\x01\x08%\n\xa1\x01\n\x02\x04\x1a\x12\x06\xcc\
    \x01\0\x98\x02\x01\x1a\x92\x01/\x20A\x20generic\x20message\x20composing\
    \x20of\x20all\x20possible\x20operations.\n/\x20One\x20of\x20the\x20Reque\
    st/Response\x20fields\x20will\x20have\x20value,\x20depending\x20on\x20th\
    e\x20MessageType\x20set.\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\xcc\x01\x08\
    \x12\n\x0e\n\x04\x04\x1a\x04\0\x12\x06\xcd\x01\x02\xe4\x01\x03\n\r\n\x05\
    \x04\x1a\x04\0\x01\x12\x04\xcd\x01\x07\x15\n\x0e\n\x06\x04\x1a\x04\0\x02\
    \0\x12\x04\xce\x01\x04\x1e\n\x0f\n\x07\x04\x1a\x04\0\x02\0\x01\x12\x04\
    \xce\x01\x04\x19\n\x0f\n\x07\x04\x1a\x04\0\x02\0\x02\x12\x04\xce\x01\x1c\
    \x1d\n\x0e\n\x06\x04\x1a\x04\0\x02\x01\x12\x04\xcf\x01\x04\x1f\n\x0f\n\
    \x07\x04\x1a\x04\0\x02\x01\x01\x12\x04\xcf\x01\x04\x1a\n\x0f\n\x07\x04\
    \x1a\x04\0\x02\x01\x02\x12\x04\xcf\x01\x1d\x1e\n\x0e\n\x06\x04\x1a\x04\0\
    \x02\x02\x12\x04\xd0\x01\x04#\n\x0f\n\x07\x04\x1a\x04\0\x02\x02\x01\x12\
    \x04\xd0\x01\x04\x1e\n\x0f\n\x07\x04\x1a\x04\0\x02\x02\x02\x12\x04\xd0\
    \x01!\"\n\x0e\n\x06\x04\x1a\x04\0\x02\x03\x12\x04\xd1\x01\x04$\n\x0f\n\
    \x07\x04\x1a\x04\0\x02\x03\x01\x12\x04\xd1\x01\x04\x1f\n\x0f\n\x07\x04\
    \x1a\x04\0\x02\x03\x02\x12\x04\xd1\x01\"#\n\x0e\n\x06\x04\x1a\x04\0\x02\
    \x04\x12\x04\xd2\x01\x04\x1b\n\x0f\n\x07\x04\x1a\x04\0\x02\x04\x01\x12\
    \x04\xd2\x01\x04\x16\n\x0f\n\x07\x04\x1a\x04\0\x02\x04\x02\x12\x04\xd2\
    \x01\x19\x1a\n\x0e\n\x06\x04\x1a\x04\0\x02\x05\x12\x04\xd3\x01\x04\x1b\n\
    \x0f\n\x07\x04\x1a\x04\0\x02\x05\x01\x12\x04\xd3\x01\x04\x16\n\x0f\n\x07\
    \x04\x1a\x04\0\x02\x05\x02\x12\x04\xd3\x01\x19\x1a\n\x0e\n\x06\x04\x1a\
    \x04\0\x02\x06\x12\x04\xd4\x01\x04\x1b\n\x0f\n\x07\x04\x1a\x04\0\x02\x06\
    \x01\x12\x04\xd4\x01\x04\x16\n\x0f\n\x07\x04\x1a\x04\0\x02\x06\x02\x12\
    \x04\xd4\x01\x19\x1a\n\x0e\n\x06\x04\x1a\x04\0\x02\x07\x12\x04\xd5\x01\
    \x04\x1c\n\x0f\n\x07\x04\x1a\x04\0\x02\x07\x01\x12\x04\xd5\x01\x04\x17\n\
    \x0f\n\x07\x04\x1a\x04\0\x02\x07\x02\x12\x04\xd5\x01\x1a\x1b\n\x0e\n\x06\
    \x04\x1a\x04\0\x02\x08\x12\x04\xd6\x01\x04\x1c\n\x0f\n\x07\x04\x1a\x04\0\
    \x02\x08\x01\x12\x04\xd6\x01\x04\x17\n\x0f\n\x07\x04\x1a\x04\0\x02\x08\
    \x02\x12\x04\xd6\x01\x1a\x1b\n\x0e\n\x06\x04\x1a\x04\0\x02\t\x12\x04\xd7\
    \x01\x04\x1e\n\x0f\n\x07\x04\x1a\x04\0\x02\t\x01\x12\x04\xd7\x01\x04\x18\
    \n\x0f\n\x07\x04\x1a\x04\0\x02\t\x02\x12\x04\xd7\x01\x1b\x1d\n\x0e\n\x06\
    \x04\x1a\x04\0\x02\n\x12\x04\xd8\x01\x04)\n\x0f\n\x07\x04\x1a\x04\0\x02\
    \n\x01\x12\x04\xd8\x01\x04#\n\x0f\n\x07\x04\x1a\x04\0\x02\n\x02\x12\x04\
    \xd8\x01&(\n\x0e\n\x06\x04\x1a\x04\0\x02\x0b\x12\x04\xd9\x01\x04*\n\x0f\
    \n\x07\x04\x1a\x04\0\x02\x0b\x01\x12\x04\xd9\x01\x04$\n\x0f\n\x07\x04\
    \x1a\x04\0\x02\x0b\x02\x12\x04\xd9\x01')\n\x0e\n\x06\x04\x1a\x04\0\x02\
    \x0c\x12\x04\xda\x01\x04\x17\n\x0f\n\x07\x04\x1a\x04\0\x02\x0c\x01\x12\
    \x04\xda\x01\x04\x11\n\x0f\n\x07\x04\x1a\x04\0\x02\x0c\x02\x12\x04\xda\
    \x01\x14\x16\n\x0e\n\x06\x04\x1a\x04\0\x02\r\x12\x04\xdb\x01\x04\x1f\n\
    \x0f\n\x07\x04\x1a\x04\0\x02\r\x01\x12\x04\xdb\x01\x04\x19\n\x0f\n\x07\
    \x04\x1a\x04\0\x02\r\x02\x12\x04\xdb\x01\x1c\x1e\n\x0e\n\x06\x04\x1a\x04\
    \0\x02\x0e\x12\x04\xdc\x01\x04\x20\n\x0f\n\x07\x04\x1a\x04\0\x02\x0e\x01\
    \x12\x04\xdc\x01\x04\x1a\n\x0f\n\x07\x04\x1a\x04\0\x02\x0e\x02\x12\x04\
    \xdc\x01\x1d\x1f\n\x0e\n\x06\x04\x1a\x04\0\x02\x0f\x12\x04\xdd\x01\x04#\
    \n\x0f\n\x07\x04\x1a\x04\0\x02\x0f\x01\x12\x04\xdd\x01\x04\x1d\n\x0f\n\
    \x07\x04\x1a\x04\0\x02\x0f\x02\x12\x04\xdd\x01\x20\"\n\x0e\n\x06\x04\x1a\
    \x04\0\x02\x10\x12\x04\xde\x01\x04$\n\x0f\n\x07\x04\x1a\x04\0\x02\x10\
    \x01\x12\x04\xde\x01\x04\x1e\n\x0f\n\x07\x04\x1a\x04\0\x02\x10\x02\x12\
    \x04\xde\x01!#\n\x0e\n\x06\x04\x1a\x04\0\x02\x11\x12\x04\xdf\x01\x04\x1f\
    \n\x0f\n\x07\x04\x1a\x04\0\x02\x11\x01\x12\x04\xdf\x01\x04\x19\n\x0f\n\
    \x07\x04\x1a\x04\0\x02\x11\x02\x12\x04\xdf\x01\x1c\x1e\n\x0e\n\x06\x04\
    \x1a\x04\0\x02\x12\x12\x04\xe0\x01\x04\x20\n\x0f\n\x07\x04\x1a\x04\0\x02\
    \x12\x01\x12\x04\xe0\x01\x04\x1a\n\x0f\n\x07\x04\x1a\x04\0\x02\x12\x02\
    \x12\x04\xe0\x01\x1d\x1f\n\x0e\n\x06\x04\x1a\x04\0\x02\x13\x12\x04\xe1\
    \x01\x04\x1c\n\x0f\n\x07\x04\x1a\x04\0\x02\x13\x01\x12\x04\xe1\x01\x04\
    \x16\n\x0f\n\x07\x04\x1a\x04\0\x02\x13\x02\x12\x04\xe1\x01\x19\x1b\n\x0e\
    \n\x06\x04\x1a\x04\0\x02\x14\x12\x04\xe2\x01\x04\x1d\n\x0f\n\x07\x04\x1a\
    \x04\0\x02\x14\x01\x12\x04\xe2\x01\x04\x17\n\x0f\n\x07\x04\x1a\x04\0\x02\
    \x14\x02\x12\x04\xe2\x01\x1a\x1c\n\x0e\n\x06\x04\x1a\x04\0\x02\x15\x12\
    \x04\xe3\x01\x04'\n\x0f\n\x07\x04\x1a\x04\0\x02\x15\x01\x12\x04\xe3\x01\
    \x04!\n\x0f\n\x07\x04\x1a\x04\0\x02\x15\x02\x12\x04\xe3\x01$&\n,\n\x04\
    \x04\x1a\x02\0\x12\x04\xe7\x01\x02*\x1a\x1e/\x20Type\x20of\x20API\x20cal\
    l\x20being\x20made\n\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xe7\x01\x02\n\n\
    \r\n\x05\x04\x1a\x02\0\x06\x12\x04\xe7\x01\x0b\x19\n\r\n\x05\x04\x1a\x02\
    \0\x01\x12\x04\xe7\x01\x1a%\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xe7\x01(\
    )\n\xa2\x01\n\x04\x04\x1a\x02\x01\x12\x04\xea\x01\x02\x1f\x1a\x93\x01/\
    \x20A\x20unique\x20id\x20to\x20represent\x20this\x20message.\x20A\x20res\
    ponse\x20to\x20the\x20message\x20should\x20copy\x20over\x20this\x20value\
    .\n/\x20This\x20is\x20used\x20to\x20synchronize\x20messages\x20&\x20resp\
    onses\n\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xea\x01\x02\n\n\r\n\x05\
    \x04\x1a\x02\x01\x05\x12\x04\xea\x01\x0b\x10\n\r\n\x05\x04\x1a\x02\x01\
    \x01\x12\x04\xea\x01\x11\x1a\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xea\
    \x01\x1d\x1e\nO\n\x04\x04\x1a\x02\x02\x12\x04\xed\x01\x028\x1aA/\x20[Get\
    ProjectRootRequest](#gauge.messages.GetProjectRootRequest)\n\n\r\n\x05\
    \x04\x1a\x02\x02\x04\x12\x04\xed\x01\x02\n\n\r\n\x05\x04\x1a\x02\x02\x06\
    \x12\x04\xed\x01\x0b\x20\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xed\x01!3\
    \n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xed\x0167\nQ\n\x04\x04\x1a\x02\
    \x03\x12\x04\xef\x01\x02:\x1aC/\x20[GetProjectRootResponse](#gauge.messa\
    ges.GetProjectRootResponse)\n\n\r\n\x05\x04\x1a\x02\x03\x04\x12\x04\xef\
    \x01\x02\n\n\r\n\x05\x04\x1a\x02\x03\x06\x12\x04\xef\x01\x0b!\n\r\n\x05\
    \x04\x1a\x02\x03\x01\x12\x04\xef\x01\"5\n\r\n\x05\x04\x1a\x02\x03\x03\
    \x12\x04\xef\x0189\nY\n\x04\x04\x1a\x02\x04\x12\x04\xf1\x01\x02B\x1aK/\
    \x20[GetInstallationRootRequest](#gauge.messages.GetInstallationRootRequ\
    est)\n\n\r\n\x05\x04\x1a\x02\x04\x04\x12\x04\xf1\x01\x02\n\n\r\n\x05\x04\
    \x1a\x02\x04\x06\x12\x04\xf1\x01\x0b%\n\r\n\x05\x04\x1a\x02\x04\x01\x12\
    \x04\xf1\x01&=\n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\xf1\x01@A\n[\n\x04\
    \x04\x1a\x02\x05\x12\x04\xf3\x01\x02D\x1aM/\x20[GetInstallationRootRespo\
    nse](#gauge.messages.GetInstallationRootResponse)\n\n\r\n\x05\x04\x1a\
    \x02\x05\x04\x12\x04\xf3\x01\x02\n\n\r\n\x05\x04\x1a\x02\x05\x06\x12\x04\
    \xf3\x01\x0b&\n\r\n\x05\x04\x1a\x02\x05\x01\x12\x04\xf3\x01'?\n\r\n\x05\
    \x04\x1a\x02\x05\x03\x12\x04\xf3\x01BC\nI\n\x04\x04\x1a\x02\x06\x12\x04\
    \xf5\x01\x022\x1a;/\x20[GetAllStepsRequest](#gauge.messages.GetAllStepsR\
    equest)\n\n\r\n\x05\x04\x1a\x02\x06\x04\x12\x04\xf5\x01\x02\n\n\r\n\x05\
    \x04\x1a\x02\x06\x06\x12\x04\xf5\x01\x0b\x1d\n\r\n\x05\x04\x1a\x02\x06\
    \x01\x12\x04\xf5\x01\x1e-\n\r\n\x05\x04\x1a\x02\x06\x03\x12\x04\xf5\x010\
    1\nK\n\x04\x04\x1a\x02\x07\x12\x04\xf7\x01\x024\x1a=/\x20[GetAllStepsRes\
    ponse](#gauge.messages.GetAllStepsResponse)\n\n\r\n\x05\x04\x1a\x02\x07\
    \x04\x12\x04\xf7\x01\x02\n\n\r\n\x05\x04\x1a\x02\x07\x06\x12\x04\xf7\x01\
    \x0b\x1e\n\r\n\x05\x04\x1a\x02\x07\x01\x12\x04\xf7\x01\x1f/\n\r\n\x05\
    \x04\x1a\x02\x07\x03\x12\x04\xf7\x0123\nI\n\x04\x04\x1a\x02\x08\x12\x04\
    \xf9\x01\x022\x1a;/\x20[GetAllSpecsRequest](#gauge.messages.GetAllSpecsR\
    equest)\n\n\r\n\x05\x04\x1a\x02\x08\x04\x12\x04\xf9\x01\x02\n\n\r\n\x05\
    \x04\x1a\x02\x08\x06\x12\x04\xf9\x01\x0b\x1d\n\r\n\x05\x04\x1a\x02\x08\
    \x01\x12\x04\xf9\x01\x1e-\n\r\n\x05\x04\x1a\x02\x08\x03\x12\x04\xf9\x010\
    1\nK\n\x04\x04\x1a\x02\t\x12\x04\xfb\x01\x025\x1a=/\x20[GetAllSpecsRespo\
    nse](#gauge.messages.GetAllSpecsResponse)\n\n\r\n\x05\x04\x1a\x02\t\x04\
    \x12\x04\xfb\x01\x02\n\n\r\n\x05\x04\x1a\x02\t\x06\x12\x04\xfb\x01\x0b\
    \x1e\n\r\n\x05\x04\x1a\x02\t\x01\x12\x04\xfb\x01\x1f/\n\r\n\x05\x04\x1a\
    \x02\t\x03\x12\x04\xfb\x0124\nK\n\x04\x04\x1a\x02\n\x12\x04\xfd\x01\x025\
    \x1a=/\x20[GetStepValueRequest](#gauge.messages.GetStepValueRequest)\n\n\
    \r\n\x05\x04\x1a\x02\n\x04\x12\x04\xfd\x01\x02\n\n\r\n\x05\x04\x1a\x02\n\
    \x06\x12\x04\xfd\x01\x0b\x1e\n\r\n\x05\x04\x1a\x02\n\x01\x12\x04\xfd\x01\
    \x1f/\n\r\n\x05\x04\x1a\x02\n\x03\x12\x04\xfd\x0124\nM\n\x04\x04\x1a\x02\
    \x0b\x12\x04\xff\x01\x027\x1a?/\x20[GetStepValueResponse](#gauge.message\
    s.GetStepValueResponse)\n\n\r\n\x05\x04\x1a\x02\x0b\x04\x12\x04\xff\x01\
    \x02\n\n\r\n\x05\x04\x1a\x02\x0b\x06\x12\x04\xff\x01\x0b\x1f\n\r\n\x05\
    \x04\x1a\x02\x0b\x01\x12\x04\xff\x01\x201\n\r\n\x05\x04\x1a\x02\x0b\x03\
    \x12\x04\xff\x0146\nc\n\x04\x04\x1a\x02\x0c\x12\x04\x81\x02\x02?\x1aU/\
    \x20[GetLanguagePluginLibPathRequest](#gauge.messages.GetLanguagePluginL\
    ibPathRequest)\n\n\r\n\x05\x04\x1a\x02\x0c\x04\x12\x04\x81\x02\x02\n\n\r\
    \n\x05\x04\x1a\x02\x0c\x06\x12\x04\x81\x02\x0b*\n\r\n\x05\x04\x1a\x02\
    \x0c\x01\x12\x04\x81\x02+9\n\r\n\x05\x04\x1a\x02\x0c\x03\x12\x04\x81\x02\
    <>\ne\n\x04\x04\x1a\x02\r\x12\x04\x83\x02\x02A\x1aW/\x20[GetLanguagePlug\
    inLibPathResponse](#gauge.messages.GetLanguagePluginLibPathResponse)\n\n\
    \r\n\x05\x04\x1a\x02\r\x04\x12\x04\x83\x02\x02\n\n\r\n\x05\x04\x1a\x02\r\
    \x06\x12\x04\x83\x02\x0b+\n\r\n\x05\x04\x1a\x02\r\x01\x12\x04\x83\x02,;\
    \n\r\n\x05\x04\x1a\x02\r\x03\x12\x04\x83\x02>@\n?\n\x04\x04\x1a\x02\x0e\
    \x12\x04\x85\x02\x02$\x1a1/\x20[ErrorResponse](#gauge.messages.ErrorResp\
    onse)\n\n\r\n\x05\x04\x1a\x02\x0e\x04\x12\x04\x85\x02\x02\n\n\r\n\x05\
    \x04\x1a\x02\x0e\x06\x12\x04\x85\x02\x0b\x18\n\r\n\x05\x04\x1a\x02\x0e\
    \x01\x12\x04\x85\x02\x19\x1e\n\r\n\x05\x04\x1a\x02\x0e\x03\x12\x04\x85\
    \x02!#\nO\n\x04\x04\x1a\x02\x0f\x12\x04\x87\x02\x029\x1aA/\x20[GetAllCon\
    ceptsRequest](#gauge.messages.GetAllConceptsRequest)\n\n\r\n\x05\x04\x1a\
    \x02\x0f\x04\x12\x04\x87\x02\x02\n\n\r\n\x05\x04\x1a\x02\x0f\x06\x12\x04\
    \x87\x02\x0b\x20\n\r\n\x05\x04\x1a\x02\x0f\x01\x12\x04\x87\x02!3\n\r\n\
    \x05\x04\x1a\x02\x0f\x03\x12\x04\x87\x0268\nQ\n\x04\x04\x1a\x02\x10\x12\
    \x04\x89\x02\x02;\x1aC/\x20[GetAllConceptsResponse](#gauge.messages.GetA\
    llConceptsResponse)\n\n\r\n\x05\x04\x1a\x02\x10\x04\x12\x04\x89\x02\x02\
    \n\n\r\n\x05\x04\x1a\x02\x10\x06\x12\x04\x89\x02\x0b!\n\r\n\x05\x04\x1a\
    \x02\x10\x01\x12\x04\x89\x02\"5\n\r\n\x05\x04\x1a\x02\x10\x03\x12\x04\
    \x89\x028:\nW\n\x04\x04\x1a\x02\x11\x12\x04\x8b\x02\x02D\x1aI/\x20[Perfo\
    rmRefactoringRequest](#gauge.messages.PerformRefactoringRequest)\n\n\r\n\
    \x05\x04\x1a\x02\x11\x04\x12\x04\x8b\x02\x02\n\n\r\n\x05\x04\x1a\x02\x11\
    \x06\x12\x04\x8b\x02\x0b$\n\r\n\x05\x04\x1a\x02\x11\x01\x12\x04\x8b\x02%\
    >\n\r\n\x05\x04\x1a\x02\x11\x03\x12\x04\x8b\x02AC\nY\n\x04\x04\x1a\x02\
    \x12\x12\x04\x8d\x02\x02F\x1aK/\x20[PerformRefactoringResponse](#gauge.m\
    essages.PerformRefactoringResponse)\n\n\r\n\x05\x04\x1a\x02\x12\x04\x12\
    \x04\x8d\x02\x02\n\n\r\n\x05\x04\x1a\x02\x12\x06\x12\x04\x8d\x02\x0b%\n\
    \r\n\x05\x04\x1a\x02\x12\x01\x12\x04\x8d\x02&@\n\r\n\x05\x04\x1a\x02\x12\
    \x03\x12\x04\x8d\x02CE\nO\n\x04\x04\x1a\x02\x13\x12\x04\x8f\x02\x02<\x1a\
    A/\x20[ExtractConceptRequest](#gauge.messages.ExtractConceptRequest)\n\n\
    \r\n\x05\x04\x1a\x02\x13\x04\x12\x04\x8f\x02\x02\n\n\r\n\x05\x04\x1a\x02\
    \x13\x06\x12\x04\x8f\x02\x0b\x20\n\r\n\x05\x04\x1a\x02\x13\x01\x12\x04\
    \x8f\x02!6\n\r\n\x05\x04\x1a\x02\x13\x03\x12\x04\x8f\x029;\nQ\n\x04\x04\
    \x1a\x02\x14\x12\x04\x91\x02\x02>\x1aC/\x20[ExtractConceptResponse](#gau\
    ge.messages.ExtractConceptResponse)\n\n\r\n\x05\x04\x1a\x02\x14\x04\x12\
    \x04\x91\x02\x02\n\n\r\n\x05\x04\x1a\x02\x14\x06\x12\x04\x91\x02\x0b!\n\
    \r\n\x05\x04\x1a\x02\x14\x01\x12\x04\x91\x02\"8\n\r\n\x05\x04\x1a\x02\
    \x14\x03\x12\x04\x91\x02;=\nJ\n\x04\x04\x1a\x02\x15\x12\x04\x93\x02\x026\
    \x1a</\x20[FormatSpecsRequest]\x20(#gauge.messages.FormatSpecsRequest)\n\
    \n\r\n\x05\x04\x1a\x02\x15\x04\x12\x04\x93\x02\x02\n\n\r\n\x05\x04\x1a\
    \x02\x15\x06\x12\x04\x93\x02\x0b\x1d\n\r\n\x05\x04\x1a\x02\x15\x01\x12\
    \x04\x93\x02\x1e0\n\r\n\x05\x04\x1a\x02\x15\x03\x12\x04\x93\x0235\nL\n\
    \x04\x04\x1a\x02\x16\x12\x04\x95\x02\x028\x1a>/\x20[FormatSpecsResponse]\
    \x20(#gauge.messages.FormatSpecsResponse)\n\n\r\n\x05\x04\x1a\x02\x16\
    \x04\x12\x04\x95\x02\x02\n\n\r\n\x05\x04\x1a\x02\x16\x06\x12\x04\x95\x02\
    \x0b\x1e\n\r\n\x05\x04\x1a\x02\x16\x01\x12\x04\x95\x02\x1f2\n\r\n\x05\
    \x04\x1a\x02\x16\x03\x12\x04\x95\x0257\n`\n\x04\x04\x1a\x02\x17\x12\x04\
    \x97\x02\x02K\x1aR/\x20[UnsupportedApiMessageResponse]\x20(#gauge.messag\
    es.UnsupportedApiMessageResponse)\n\n\r\n\x05\x04\x1a\x02\x17\x04\x12\
    \x04\x97\x02\x02\n\n\r\n\x05\x04\x1a\x02\x17\x06\x12\x04\x97\x02\x0b(\n\
    \r\n\x05\x04\x1a\x02\x17\x01\x12\x04\x97\x02)F\n\r\n\x05\x04\x1a\x02\x17\
    \x03\x12\x04\x97\x02HJ\
";

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> ::protobuf::reflect::FileDescriptor {
    static file_descriptor_lazy: ::protobuf::rt::LazyV2<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::LazyV2::INIT;
    let file_descriptor = file_descriptor_lazy.get(|| {
        let mut deps = ::std::vec::Vec::new();
        deps.push(super::spec::file_descriptor());
        let mut messages = ::std::vec::Vec::new();
        messages.push(GetProjectRootRequest::generated_message_descriptor_data());
        messages.push(GetProjectRootResponse::generated_message_descriptor_data());
        messages.push(GetInstallationRootRequest::generated_message_descriptor_data());
        messages.push(GetInstallationRootResponse::generated_message_descriptor_data());
        messages.push(GetAllStepsRequest::generated_message_descriptor_data());
        messages.push(GetAllStepsResponse::generated_message_descriptor_data());
        messages.push(GetAllSpecsRequest::generated_message_descriptor_data());
        messages.push(GetAllSpecsResponse::generated_message_descriptor_data());
        messages.push(GetAllConceptsRequest::generated_message_descriptor_data());
        messages.push(GetAllConceptsResponse::generated_message_descriptor_data());
        messages.push(ConceptInfo::generated_message_descriptor_data());
        messages.push(GetStepValueRequest::generated_message_descriptor_data());
        messages.push(GetStepValueResponse::generated_message_descriptor_data());
        messages.push(GetLanguagePluginLibPathRequest::generated_message_descriptor_data());
        messages.push(GetLanguagePluginLibPathResponse::generated_message_descriptor_data());
        messages.push(ErrorResponse::generated_message_descriptor_data());
        messages.push(PerformRefactoringRequest::generated_message_descriptor_data());
        messages.push(PerformRefactoringResponse::generated_message_descriptor_data());
        messages.push(ExtractConceptInfoRequest::generated_message_descriptor_data());
        messages.push(ExtractConceptRequest::generated_message_descriptor_data());
        messages.push(TextInfo::generated_message_descriptor_data());
        messages.push(Step::generated_message_descriptor_data());
        messages.push(ExtractConceptResponse::generated_message_descriptor_data());
        messages.push(FormatSpecsRequest::generated_message_descriptor_data());
        messages.push(FormatSpecsResponse::generated_message_descriptor_data());
        messages.push(UnsupportedApiMessageResponse::generated_message_descriptor_data());
        messages.push(APIMessage::generated_message_descriptor_data());
        let mut enums = ::std::vec::Vec::new();
        enums.push(apimessage::APIMessageType::generated_enum_descriptor_data());
        ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
            file_descriptor_proto(),
            deps,
            messages,
            enums,
        )
    });
    ::protobuf::reflect::FileDescriptor::new_generated_2(file_descriptor)
}
